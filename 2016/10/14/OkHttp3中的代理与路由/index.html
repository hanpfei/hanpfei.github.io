<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>OkHttp3中的代理与路由 | WolfcsTech</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.2.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.2.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">OkHttp3中的代理与路由</h1><a id="logo" href="/.">WolfcsTech</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">OkHttp3中的代理与路由</h1><div class="post-meta">Oct 14, 2016<span> | </span><span class="category"><a href="/categories/网络协议/">网络协议</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/10/14/OkHttp3中的代理与路由/" href="/2016/10/14/OkHttp3中的代理与路由/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>HTTP请求的整体处理过程大体可以理解为，</p>
<ol>
<li>建立TCP连接。</li>
<li>如果是HTTPS的话，完成SSL/TLS的协商。</li>
<li>发送请求。</li>
<li>获取响应。</li>
<li>结束请求，关闭连接。</li>
</ol>
<a id="more"></a>
<p>然而，当为系统设置了代理的时候，整个数据流都会经过代理服务器。那么代理设置究竟是如何工作的呢？它是如何影响我们上面看到的HTTP请求的处理过程的呢？是在操作系统内核的TCP实现中的策略呢，还是HTTP stack中的机制？这里我们通过OkHttp3中的实现来一探究竟。</p>
<p>代理分为两种类型，一种是SOCKS代理，另一种是HTTP代理。对于SOCKS代理，在HTTP的场景下，代理服务器完成TCP数据包的转发工作。而HTTP代理服务器，在转发数据之外，还会解析HTTP的请求及响应，并根据请求及响应的内容做一些处理。这里看一下OkHttp中对代理的处理。</p>
<h1 id="代理服务器的描述"><a href="#代理服务器的描述" class="headerlink" title="代理服务器的描述"></a>代理服务器的描述</h1><p>在Java中，通过 <strong><em>java.net.Proxy</em></strong> 类描述一个代理服务器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Represents the proxy type.</div><div class="line">     *</div><div class="line">     * @since 1.5</div><div class="line">     */</div><div class="line">    public enum <span class="type">Type</span> &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Represents a direct connection, or the absence of a proxy.</div><div class="line">         */</div><div class="line">        <span class="type">DIRECT</span>,</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Represents proxy for high level protocols such as HTTP or FTP.</div><div class="line">         */</div><div class="line">        <span class="type">HTTP</span>,</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Represents a SOCKS (V4 or V5) proxy.</div><div class="line">         */</div><div class="line">        <span class="type">SOCKS</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="type">Type</span> <span class="class"><span class="keyword">type</span></span>;</div><div class="line">    <span class="keyword">private</span> <span class="type">SocketAddress</span> sa;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A proxy setting that represents a &#123;@code DIRECT&#125; connection,</div><div class="line">     * basically telling the protocol handler not to use any proxying.</div><div class="line">     * Used, for instance, to create sockets bypassing any other global</div><div class="line">     * proxy settings (like SOCKS):</div><div class="line">     * &lt;P&gt;</div><div class="line">     * &#123;@code Socket s = new Socket(Proxy.NO_PROXY);&#125;</div><div class="line">     *</div><div class="line">     */</div><div class="line">    public <span class="keyword">final</span> static <span class="type">Proxy</span> <span class="type">NO_PROXY</span> = <span class="keyword">new</span> <span class="type">Proxy</span>();</div><div class="line"></div><div class="line">    <span class="comment">// Creates the proxy that represents a &#123;@code DIRECT&#125; connection.</span></div><div class="line">    <span class="keyword">private</span> <span class="type">Proxy</span>() &#123;</div><div class="line">        <span class="class"><span class="keyword">type</span> </span>= <span class="type">Type</span>.<span class="type">DIRECT</span>;</div><div class="line">        sa = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates an entry representing a PROXY connection.</div><div class="line">     * Certain combinations are illegal. For instance, for types Http, and</div><div class="line">     * Socks, a SocketAddress &lt;b&gt;must&lt;/b&gt; be provided.</div><div class="line">     * &lt;P&gt;</div><div class="line">     * Use the &#123;@code Proxy.NO_PROXY&#125; constant</div><div class="line">     * for representing a direct connection.</div><div class="line">     *</div><div class="line">     * @param type the &#123;@code Type&#125; of the proxy</div><div class="line">     * @param sa the &#123;@code SocketAddress&#125; for that proxy</div><div class="line">     * @throws IllegalArgumentException when the type and the address are</div><div class="line">     * incompatible</div><div class="line">     */</div><div class="line">    public <span class="type">Proxy</span>(<span class="type">Type</span> <span class="class"><span class="keyword">type</span>, <span class="title">SocketAddress</span> <span class="title">sa</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((<span class="class"><span class="keyword">type</span> <span class="title">==</span> <span class="title">Type</span>.<span class="title">DIRECT</span>) <span class="title">||</span> <span class="title">!</span>(<span class="params">sa instanceof <span class="type">InetSocketAddress</span></span>))</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"type "</span> + <span class="class"><span class="keyword">type</span> <span class="title">+</span> " <span class="title">is</span> <span class="title">not</span> <span class="title">compatible</span> <span class="keyword">with</span> <span class="title">address</span> " <span class="title">+</span> <span class="title">sa</span>)</span>;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">type</span> = <span class="class"><span class="keyword">type</span></span>;</div><div class="line">        <span class="keyword">this</span>.sa = sa;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the proxy type.</div><div class="line">     *</div><div class="line">     * @return a Type representing the proxy type</div><div class="line">     */</div><div class="line">    public <span class="type">Type</span> <span class="class"><span class="keyword">type</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">type</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the socket address of the proxy, or</div><div class="line">     * &#123;@code null&#125; if its a direct connection.</div><div class="line">     *</div><div class="line">     * @return a &#123;@code SocketAddress&#125; representing the socket end</div><div class="line">     *         point of the proxy</div><div class="line">     */</div><div class="line">    public <span class="type">SocketAddress</span> address() &#123;</div><div class="line">        <span class="keyword">return</span> sa;</div><div class="line">    &#125;</div><div class="line">......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只用代理的类型及代理服务器地址即可描述代理服务器的全部。对于HTTP代理，代理服务器地址可以通过域名和IP地址等方式来描述。</p>
<h1 id="代理选择器ProxySelector"><a href="#代理选择器ProxySelector" class="headerlink" title="代理选择器ProxySelector"></a>代理选择器ProxySelector</h1><p>在Java中通过ProxySelector为一个特定的URI选择代理：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySelector</span> </span>&#123;</div><div class="line">......</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Selects all the applicable proxies based on the protocol to</div><div class="line">     * access the resource with and a destination address to access</div><div class="line">     * the resource at.</div><div class="line">     * The format of the URI is defined as follow:</div><div class="line">     * &lt;UL&gt;</div><div class="line">     * &lt;LI&gt;http URI for http connections&lt;/LI&gt;</div><div class="line">     * &lt;LI&gt;https URI for https connections</div><div class="line">     * &lt;LI&gt;&#123;<span class="doctag">@code</span> socket://host:port&#125;&lt;br&gt;</div><div class="line">     *     for tcp client sockets connections&lt;/LI&gt;</div><div class="line">     * &lt;/UL&gt;</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span>   uri</div><div class="line">     *          The URI that a connection is required to</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span>  a List of Proxies. Each element in the</div><div class="line">     *          the List is of type</div><div class="line">     *          &#123;<span class="doctag">@link</span> java.net.Proxy Proxy&#125;;</div><div class="line">     *          when no proxy is available, the list will</div><div class="line">     *          contain one element of type</div><div class="line">     *          &#123;<span class="doctag">@link</span> java.net.Proxy Proxy&#125;</div><div class="line">     *          that represents a direct connection.</div><div class="line">     * <span class="doctag">@throws</span> IllegalArgumentException if the argument is null</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">List</span>&lt;Proxy&gt; select(URI uri);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Called to indicate that a connection could not be established</div><div class="line">     * to a proxy/socks server. An implementation of this method can</div><div class="line">     * temporarily remove the proxies or reorder the sequence of</div><div class="line">     * proxies returned by &#123;<span class="doctag">@link</span> #select(URI)&#125;, using the address</div><div class="line">     * and the IOException caught when trying to connect.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span>   uri</div><div class="line">     *          The URI that the proxy at sa failed to serve.</div><div class="line">     * <span class="doctag">@param</span>   sa</div><div class="line">     *          The socket address of the proxy/SOCKS server</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span>   ioe</div><div class="line">     *          The I/O exception thrown when the connect failed.</div><div class="line">     * <span class="doctag">@throws</span> IllegalArgumentException if either argument is null</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> void connectFailed(URI uri, SocketAddress sa, IOException ioe);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个组件会读区系统中配置的所有代理，并根据调用者传入的URI，返回特定的代理服务器集合。由于不同系统中，配置代理服务器的方法，及相关配置的保存机制不同，该接口在不同的系统中有着不同的实现。</p>
<h1 id="OkHttp3的路由"><a href="#OkHttp3的路由" class="headerlink" title="OkHttp3的路由"></a>OkHttp3的路由</h1><p>OkHttp3中抽象出Route来描述网络数据包的传输路径，最主要还是要描述直接与其建立TCP连接的目标端点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Route</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> Address address;</div><div class="line">  <span class="keyword">final</span> Proxy proxy;</div><div class="line">  <span class="keyword">final</span> InetSocketAddress inetSocketAddress;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Route</span><span class="params">(Address address, Proxy proxy, InetSocketAddress inetSocketAddress)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (address == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"address == null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (proxy == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"proxy == null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (inetSocketAddress == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"inetSocketAddress == null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.address = address;</div><div class="line">    <span class="keyword">this</span>.proxy = proxy;</div><div class="line">    <span class="keyword">this</span>.inetSocketAddress = inetSocketAddress;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Address <span class="title">address</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> address;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Returns the &#123;<span class="doctag">@link</span> Proxy&#125; of this route.</div><div class="line">   *</div><div class="line">   * &lt;strong&gt;Warning:&lt;/strong&gt; This may disagree with &#123;<span class="doctag">@link</span> Address#proxy&#125; when it is null. When</div><div class="line">   * the address's proxy is null, the proxy selector is used.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> Proxy <span class="title">proxy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> proxy;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">socketAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> inetSocketAddress;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Returns true if this route tunnels HTTPS through an HTTP proxy. See &lt;a</div><div class="line">   * href="http://www.ietf.org/rfc/rfc2817.txt"&gt;RFC 2817, Section 5.2&lt;/a&gt;.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requiresTunnel</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> address.sslSocketFactory != <span class="keyword">null</span> &amp;&amp; proxy.type() == Proxy.Type.HTTP;</div><div class="line">  &#125;</div><div class="line">......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要通过 <strong>代理服务器的信息proxy</strong> ，及 <strong>连接的目标地址</strong> 描述路由。 <strong>连接的目标地址inetSocketAddress</strong> 根据代理类型的不同而有着不同的含义，这主要是由不同代理协议的差异而造成的。对于无需代理的情况， <strong>连接的目标地址inetSocketAddress</strong> 中包含HTTP服务器经过了DNS域名解析的IP地址及协议端口号；对于SOCKS代理，其中包含HTTP服务器的域名及协议端口号；对于HTTP代理，其中则包含代理服务器经过域名解析的IP地址及端口号。</p>
<h1 id="路由选择器RouteSelector"><a href="#路由选择器RouteSelector" class="headerlink" title="路由选择器RouteSelector"></a>路由选择器RouteSelector</h1><p>HTTP请求处理过程中所需的TCP连接建立过程，主要是找到一个Route，然后依据代理协议的规则与特定目标建立TCP连接。对于无代理的情况，是与HTTP服务器建立TCP连接；对于SOCKS代理及HTTP代理，是与代理服务器建立TCP连接，虽然都是与代理服务器建立TCP连接，而SOCKS代理协议与HTTP代理协议做这个动作的方式又会有一定的区别。</p>
<p>借助于域名解析做负载均衡已经是网络中非常常见的手法了，因而，常常会有相同域名对应不同IP地址的情况。同时相同系统也可以设置多个代理，这使Route的选择变得复杂起来。</p>
<p>在OkHttp中，对Route连接失败有一定的错误处理机制。OkHttp会逐个尝试找到的Route建立TCP连接，直到找到可用的那一个。这同样要求，对Route信息有良好的管理。</p>
<p>OkHttp3借助于 <strong><code>RouteSelector</code></strong> 类管理所有的路由信息，并帮助选择路由。 <strong><code>RouteSelector</code></strong> 主要完成3件事：</p>
<ol>
<li>收集所有可用的路由。<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteSelector</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Address address;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RouteDatabase routeDatabase;</div><div class="line"></div><div class="line">  <span class="comment">/* The most recently attempted route. */</span></div><div class="line">  <span class="keyword">private</span> Proxy lastProxy;</div><div class="line">  <span class="keyword">private</span> InetSocketAddress lastInetSocketAddress;</div><div class="line"></div><div class="line">  <span class="comment">/* State for negotiating the next proxy to use. */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">List</span>&lt;Proxy&gt; proxies = Collections.emptyList();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> nextProxyIndex;</div><div class="line"></div><div class="line">  <span class="comment">/* State for negotiating the next socket address to use. */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">List</span>&lt;InetSocketAddress&gt; inetSocketAddresses = Collections.emptyList();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> nextInetSocketAddressIndex;</div><div class="line"></div><div class="line">  <span class="comment">/* State for negotiating failed routes */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">List</span>&lt;Route&gt; postponedRoutes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">public</span> RouteSelector(Address address, RouteDatabase routeDatabase) &#123;</div><div class="line">    this.address = address;</div><div class="line">    this.routeDatabase = routeDatabase;</div><div class="line"></div><div class="line">    resetNextProxy(address.url(), address.proxy());</div><div class="line">  &#125;</div><div class="line">......</div><div class="line"></div><div class="line">  <span class="comment">/** Prepares the proxy servers to try. */</span></div><div class="line">  <span class="keyword">private</span> void resetNextProxy(HttpUrl url, Proxy proxy) &#123;</div><div class="line">    <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// If the user specifies a proxy, try that and only that.</span></div><div class="line">      proxies = Collections.singletonList(proxy);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Try each of the ProxySelector choices until one connection succeeds. If none succeed</span></div><div class="line">      <span class="comment">// then we'll try a direct connection below.</span></div><div class="line">      proxies = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">      <span class="keyword">List</span>&lt;Proxy&gt; selectedProxies = address.proxySelector().select(url.uri());</div><div class="line">      <span class="keyword">if</span> (selectedProxies != <span class="keyword">null</span>) proxies.addAll(selectedProxies);</div><div class="line">      <span class="comment">// Finally try a direct connection. We only try it once!</span></div><div class="line">      proxies.removeAll(Collections.singleton(Proxy.NO_PROXY));</div><div class="line">      proxies.add(Proxy.NO_PROXY);</div><div class="line">    &#125;</div><div class="line">    nextProxyIndex = <span class="number">0</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>收集路由分为两个步骤：第一步收集所有的代理；第二步则是收集特定代理服务器选择情况下的所有 <strong>连接的目标地址</strong> 。<br>收集代理的过程如上面的这段代码所示，有两种方式，一是外部通过address传入了代理，此时代理集合将包含这唯一的代理。address的代理最终来源于OkHttpClient，我们可以在构造OkHttpClient时设置代理，来指定由该client执行的所有请求经过特定的代理。<br>另一种方式是，借助于ProxySelector获取多个代理。ProxySelector最终也来源于OkHttpClient，OkHttp的用户当然也可以对此进行配置。但通常情况下，使用系统默认的ProxySelector，来获取系统中配置的代理。<br>收集到的所有代理保存在列表 <strong><code>proxies</code></strong> 中。<br>为OkHttpClient配置Proxy或ProxySelector的场景大概是，需要让连接使用代理，但不使用系统的代理配置的情况。<br>收集特定代理服务器选择情况下的所有路由，因代理类型的不同而有着不同的过程：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Returns the next proxy to try. May be PROXY.NO_PROXY but never null. */</span></div><div class="line"><span class="keyword">private</span> Proxy nextProxy() <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">if</span> (!hasNextProxy()) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"No route to "</span> + address.url().host()</div><div class="line">        + <span class="string">"; exhausted proxy configurations: "</span> + proxies);</div><div class="line">  &#125;</div><div class="line">  Proxy result = proxies.<span class="built_in">get</span>(nextProxyIndex++);</div><div class="line">  resetNextInetSocketAddress(result);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Prepares the socket addresses to attempt for the current proxy or host. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> resetNextInetSocketAddress(Proxy proxy) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="comment">// Clear the addresses. Necessary if getAllByName() below throws!</span></div><div class="line">  inetSocketAddresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">String</span> socketHost;</div><div class="line">  <span class="built_in">int</span> socketPort;</div><div class="line">  <span class="keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;</div><div class="line">    socketHost = address.url().host();</div><div class="line">    socketPort = address.url().port();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    SocketAddress proxyAddress = proxy.address();</div><div class="line">    <span class="keyword">if</span> (!(proxyAddress <span class="keyword">instanceof</span> InetSocketAddress)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">          <span class="string">"Proxy.address() is not an "</span> + <span class="string">"InetSocketAddress: "</span> + proxyAddress.getClass());</div><div class="line">    &#125;</div><div class="line">    InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;</div><div class="line">    socketHost = getHostString(proxySocketAddress);</div><div class="line">    socketPort = proxySocketAddress.getPort();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (socketPort &lt; <span class="number">1</span> || socketPort &gt; <span class="number">65535</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"No route to "</span> + socketHost + <span class="string">":"</span> + socketPort</div><div class="line">        + <span class="string">"; port is out of range"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;</div><div class="line">    inetSocketAddresses.<span class="built_in">add</span>(InetSocketAddress.createUnresolved(socketHost, socketPort));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Try each address for best behavior in mixed IPv4/IPv6 environments.</span></div><div class="line">    List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = addresses.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</div><div class="line">      InetAddress inetAddress = addresses.<span class="built_in">get</span>(i);</div><div class="line">      inetSocketAddresses.<span class="built_in">add</span>(<span class="keyword">new</span> InetSocketAddress(inetAddress, socketPort));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  nextInetSocketAddressIndex = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Obtain a "host" from an &#123;@link InetSocketAddress&#125;. This returns a string containing either an</div><div class="line"> * actual host name or a numeric IP address.</div><div class="line"> */</div><div class="line"><span class="comment">// Visible for testing</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">String</span> getHostString(InetSocketAddress socketAddress) &#123;</div><div class="line">  InetAddress address = socketAddress.getAddress();</div><div class="line">  <span class="keyword">if</span> (address == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// The InetSocketAddress was specified with a string (either a numeric IP or a host name). If</span></div><div class="line">    <span class="comment">// it is a name, all IPs for that name should be tried. If it is an IP address, only that IP</span></div><div class="line">    <span class="comment">// address should be tried.</span></div><div class="line">    <span class="keyword">return</span> socketAddress.getHostName();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// The InetSocketAddress has a specific address: we should only try that address. Therefore we</span></div><div class="line">  <span class="comment">// return the address and ignore any host name that may be available.</span></div><div class="line">  <span class="keyword">return</span> address.getHostAddress();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>收集一个特定代理服务器选择下的 <strong>连接的目标地址</strong> 因代理类型的不同而不同，这主要分为3种情况。 对于没有配置代理的情况，会对HTTP服务器的域名进行DNS域名解析，并为每个解析到的IP地址创建 <strong>连接的目标地址</strong>；对于SOCKS代理，直接以HTTP服务器的域名及协议端口号创建  <strong>连接的目标地址</strong>；而对于HTTP代理，则会对HTTP代理服务器的域名进行DNS域名解析，并为每个解析到的IP地址创建 <strong>连接的目标地址</strong>。<br>这里是OkHttp中发生DNS域名解析唯一的场合。对于使用代理的场景，没有对HTTP服务器的域名做DNS域名解析，也就意味着HTTP服务器的域名解析要由代理服务器完成。<br>代理服务器的收集是在创建 <strong><code>RouteSelector</code></strong> 完成的；而一个特定代理服务器选择下的 <strong>连接的目标地址</strong> 收集则是在选择Route时根据需要完成的。</p>
<ol>
<li><p><strong><code>RouteSelector</code></strong> 做的第二件事情是选择可用的路由。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns true if there's another route to attempt. Every address has at least one route.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> hasNextInetSocketAddress()</div><div class="line">      || hasNextProxy()</div><div class="line">      || hasNextPostponed();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function">Route <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">// Compute the next route to attempt.</span></div><div class="line">  <span class="keyword">if</span> (!hasNextInetSocketAddress()) &#123;</div><div class="line">    <span class="keyword">if</span> (!hasNextProxy()) &#123;</div><div class="line">      <span class="keyword">if</span> (!hasNextPostponed()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">      &#125;</div><div class="line">      <span class="function"><span class="keyword">return</span> <span class="title">nextPostponed</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">    lastProxy = nextProxy();</div><div class="line">  &#125;</div><div class="line">  lastInetSocketAddress = nextInetSocketAddress();</div><div class="line"></div><div class="line">  Route route = <span class="keyword">new</span> Route(address, lastProxy, lastInetSocketAddress);</div><div class="line">  <span class="keyword">if</span> (routeDatabase.shouldPostpone(route)) &#123;</div><div class="line">    postponedRoutes.add(route);</div><div class="line">    <span class="comment">// We will only recurse in order to skip previously failed routes. They will be tried last.</span></div><div class="line">    <span class="function"><span class="keyword">return</span> <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> route;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns true if there's another proxy to try. */</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasNextProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> nextProxyIndex &lt; proxies.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns true if there's another socket address to try. */</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasNextInetSocketAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> nextInetSocketAddressIndex &lt; inetSocketAddresses.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns the next socket address to try. */</span></div><div class="line"><span class="keyword">private</span> <span class="function">InetSocketAddress <span class="title">nextInetSocketAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!hasNextInetSocketAddress()) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SocketException(<span class="string">"No route to "</span> + address.url().host()</div><div class="line">        + <span class="string">"; exhausted inet socket addresses: "</span> + inetSocketAddresses);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">return</span> inetSocketAddresses.<span class="title">get</span><span class="params">(nextInetSocketAddressIndex++)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns true if there is another postponed route to try. */</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasNextPostponed</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> !postponedRoutes.isEmpty();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** Returns the next postponed route to try. */</span></div><div class="line"><span class="keyword">private</span> <span class="function">Route <span class="title">nextPostponed</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">return</span> postponedRoutes.<span class="title">remove</span><span class="params">(<span class="number">0</span>)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><code>RouteSelector</code></strong> 实现了两级迭代器来提供选择路由的服务。</p>
</li>
<li>维护接失败的路由的信息，以避免浪费时间去连接一些不可用的路由。 <strong><code>RouteSelector</code></strong> 借助于<strong><code>RouteDatabase</code></strong> 维护失败的路由的信息。<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Clients should invoke this method when they encounter a connectivity failure on a connection</div><div class="line"> * returned by this route selector.</div><div class="line"> */</div><div class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">connectFailed</span>(Route failedRoute, IOException failure) &#123;</div><div class="line">  <span class="selector-tag">if</span> (failedRoute.proxy().type() != Proxy.Type.DIRECT &amp;&amp; address.proxySelector() != null) &#123;</div><div class="line">    <span class="comment">// Tell the proxy selector when we fail to connect on a fresh connection.</span></div><div class="line">    <span class="selector-tag">address</span><span class="selector-class">.proxySelector</span>()<span class="selector-class">.connectFailed</span>(</div><div class="line">        address.url(<span class="string"></span>).uri(), failedRoute.proxy().address(), failure);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="selector-tag">routeDatabase</span><span class="selector-class">.failed</span>(failedRoute);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>RouteDatabase</code>是一个简单的容器：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteDatabase</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Route&gt; failedRoutes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="comment">/** Records a failure connecting to &#123;<span class="doctag">@code</span> failedRoute&#125;. */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(Route failedRoute)</span> </span>&#123;</div><div class="line">    failedRoutes.add(failedRoute);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Records success connecting to &#123;<span class="doctag">@code</span> failedRoute&#125;. */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">connected</span><span class="params">(Route route)</span> </span>&#123;</div><div class="line">    failedRoutes.remove(route);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns true if &#123;<span class="doctag">@code</span> route&#125; has failed recently and should be avoided. */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">boolean</span> <span class="title">shouldPostpone</span><span class="params">(Route route)</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> failedRoutes.<span class="title">contains</span><span class="params">(route)</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="代理选择器ProxySelector的实现"><a href="#代理选择器ProxySelector的实现" class="headerlink" title="代理选择器ProxySelector的实现"></a>代理选择器ProxySelector的实现</h1><p>在OkHttp3中，<code>ProxySelector</code>对象由OkHttpClient维护。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="title">implements</span> <span class="title">Cloneable</span>, <span class="type">Call.Factory &#123;</span></span></div><div class="line">......</div><div class="line">  <span class="keyword">final</span> ProxySelector proxySelector;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> OkHttpClient(Builder builder) &#123;</div><div class="line">    <span class="keyword">this</span>.dispatcher = builder.dispatcher;</div><div class="line">    <span class="keyword">this</span>.proxy = builder.proxy;</div><div class="line">    <span class="keyword">this</span>.protocols = builder.protocols;</div><div class="line">    <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;</div><div class="line">    <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);</div><div class="line">    <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);</div><div class="line">    <span class="keyword">this</span>.proxySelector = builder.proxySelector;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">  <span class="keyword">public</span> ProxySelector proxySelector() &#123;</div><div class="line">    <span class="keyword">return</span> proxySelector;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Builder() &#123;</div><div class="line">      dispatcher = new Dispatcher();</div><div class="line">      protocols = DEFAULT_PROTOCOLS;</div><div class="line">      connectionSpecs = DEFAULT_CONNECTION_SPECS;</div><div class="line">      proxySelector = ProxySelector.getDefault();</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">    Builder(OkHttpClient okHttpClient) &#123;</div><div class="line">      <span class="keyword">this</span>.dispatcher = okHttpClient.dispatcher;</div><div class="line">      <span class="keyword">this</span>.proxy = okHttpClient.proxy;</div><div class="line">      <span class="keyword">this</span>.protocols = okHttpClient.protocols;</div><div class="line">      <span class="keyword">this</span>.connectionSpecs = okHttpClient.connectionSpecs;</div><div class="line">      <span class="keyword">this</span>.interceptors.addAll(okHttpClient.interceptors);</div><div class="line">      <span class="keyword">this</span>.networkInterceptors.addAll(okHttpClient.networkInterceptors);</div><div class="line">      <span class="keyword">this</span>.proxySelector = okHttpClient.proxySelector;</div></pre></td></tr></table></figure>
<p>在创建OkHttpClient时，可以通过为OkHttpClient.Builder设置<code>ProxySelector</code>来定制<code>ProxySelector</code>。若没有指定，则使用系统默认的<code>ProxySelector</code>。OpenJDK 1.8版默认的<code>ProxySelector</code>为<code>sun.net.spi.DefaultProxySelector</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySelector</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The system wide proxy selector that selects the proxy server to</div><div class="line">     * use, if any, when connecting to a remote object referenced by</div><div class="line">     * an URL.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span> #setDefault(ProxySelector)</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ProxySelector theProxySelector;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class&lt;?&gt; c = Class.forName(<span class="string">"sun.net.spi.DefaultProxySelector"</span>);</div><div class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; ProxySelector.class.isAssignableFrom(c)) &#123;</div><div class="line">                theProxySelector = (ProxySelector) c.newInstance();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            theProxySelector = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Gets the system-wide proxy selector.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span>  SecurityException</div><div class="line">     *          If a security manager has been installed and it denies</div><div class="line">     * &#123;<span class="doctag">@link</span> NetPermission&#125;&#123;<span class="doctag">@code</span> ("getProxySelector")&#125;</div><div class="line">     * <span class="doctag">@see</span> #setDefault(ProxySelector)</div><div class="line">     * <span class="doctag">@return</span> the system-wide &#123;<span class="doctag">@code</span> ProxySelector&#125;</div><div class="line">     * <span class="doctag">@since</span> 1.5</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProxySelector <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">        SecurityManager sm = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">            sm.checkPermission(SecurityConstants.GET_PROXYSELECTOR_PERMISSION);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> theProxySelector;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在Android平台上，默认<code>ProxySelector</code>所用的则是<a href="http://androidxref.com/6.0.1_r10/xref/libcore/luni/src/main/java/java/net/ProxySelector.java" target="_blank" rel="external">另外的实现</a>：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ProxySelector</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ProxySelector defaultSelector = <span class="keyword">new</span> ProxySelectorImpl();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the default proxy selector, or null if none exists.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProxySelector <span class="title">getDefault</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> defaultSelector;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets the default proxy selector. If &#123;@code selector&#125; is null, the current</div><div class="line">     * proxy selector will be removed.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefault</span>(<span class="params">ProxySelector selector</span>) </span>&#123;</div><div class="line">        defaultSelector = selector;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Android平台下，默认的<code>ProxySelector</code> ProxySelectorImpl，其<a href="https://android.googlesource.com/platform/libcore/+/android-6.0.1_r61/luni/src/main/java/java/net/ProxySelectorImpl.java" target="_blank" rel="external">实现 (不同Android版本实现不同，这里以android-6.0.1_r61为例)</a> 如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.net;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySelectorImpl</span> <span class="keyword">extends</span> <span class="title">ProxySelector</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">connectFailed</span><span class="params">(URI uri, SocketAddress sa, IOException ioe)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (uri == <span class="keyword">null</span> || sa == <span class="keyword">null</span> || ioe == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> List&lt;Proxy&gt; select(URI uri) &#123;</div><div class="line">        <span class="keyword">return</span> Collections.singletonList(selectOneProxy(uri));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="function">Proxy <span class="title">selectOneProxy</span><span class="params">(URI uri)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (uri == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"uri == null"</span>);</div><div class="line">        &#125;</div><div class="line">        String scheme = uri.getScheme();</div><div class="line">        <span class="keyword">if</span> (scheme == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"scheme == null"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> port = <span class="number">-1</span>;</div><div class="line">        Proxy proxy = <span class="keyword">null</span>;</div><div class="line">        String nonProxyHostsKey = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">boolean</span> httpProxyOkay = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="string">"http"</span>.equalsIgnoreCase(scheme)) &#123;</div><div class="line">            port = <span class="number">80</span>;</div><div class="line">            nonProxyHostsKey = <span class="string">"http.nonProxyHosts"</span>;</div><div class="line">            proxy = lookupProxy(<span class="string">"http.proxyHost"</span>, <span class="string">"http.proxyPort"</span>, Proxy.Type.HTTP, port);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"https"</span>.equalsIgnoreCase(scheme)) &#123;</div><div class="line">            port = <span class="number">443</span>;</div><div class="line">            nonProxyHostsKey = <span class="string">"https.nonProxyHosts"</span>; <span class="comment">// RI doesn't support this</span></div><div class="line">            proxy = lookupProxy(<span class="string">"https.proxyHost"</span>, <span class="string">"https.proxyPort"</span>, Proxy.Type.HTTP, port);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"ftp"</span>.equalsIgnoreCase(scheme)) &#123;</div><div class="line">            port = <span class="number">80</span>; <span class="comment">// not 21 as you might guess</span></div><div class="line">            nonProxyHostsKey = <span class="string">"ftp.nonProxyHosts"</span>;</div><div class="line">            proxy = lookupProxy(<span class="string">"ftp.proxyHost"</span>, <span class="string">"ftp.proxyPort"</span>, Proxy.Type.HTTP, port);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"socket"</span>.equalsIgnoreCase(scheme)) &#123;</div><div class="line">            httpProxyOkay = <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> Proxy.NO_PROXY;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (nonProxyHostsKey != <span class="keyword">null</span></div><div class="line">                &amp;&amp; isNonProxyHost(uri.getHost(), System.getProperty(nonProxyHostsKey))) &#123;</div><div class="line">            <span class="keyword">return</span> Proxy.NO_PROXY;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> proxy;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (httpProxyOkay) &#123;</div><div class="line">            proxy = lookupProxy(<span class="string">"proxyHost"</span>, <span class="string">"proxyPort"</span>, Proxy.Type.HTTP, port);</div><div class="line">            <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> proxy;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        proxy = lookupProxy(<span class="string">"socksProxyHost"</span>, <span class="string">"socksProxyPort"</span>, Proxy.Type.SOCKS, <span class="number">1080</span>);</div><div class="line">        <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> proxy;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Proxy.NO_PROXY;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the proxy identified by the &#123;<span class="doctag">@code</span> hostKey&#125; system property, or</div><div class="line">     * null.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="function">Proxy <span class="title">lookupProxy</span><span class="params">(String hostKey, String portKey, Proxy.Type type, <span class="keyword">int</span> defaultPort)</span> </span>&#123;</div><div class="line">        String host = System.getProperty(hostKey);</div><div class="line">        <span class="keyword">if</span> (host == <span class="keyword">null</span> || host.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> port = getSystemPropertyInt(portKey, defaultPort);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Proxy(type, InetSocketAddress.createUnresolved(host, port));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">getSystemPropertyInt</span><span class="params">(String key, <span class="keyword">int</span> defaultValue)</span> </span>&#123;</div><div class="line">        String string = System.getProperty(key);</div><div class="line">        <span class="keyword">if</span> (string != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="function"><span class="keyword">return</span> Integer.<span class="title">parseInt</span><span class="params">(string)</span></span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException ignored) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> defaultValue;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns true if the &#123;<span class="doctag">@code</span> nonProxyHosts&#125; system property pattern exists</div><div class="line">     * and matches &#123;<span class="doctag">@code</span> host&#125;.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isNonProxyHost</span><span class="params">(String host, String nonProxyHosts)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (host == <span class="keyword">null</span> || nonProxyHosts == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// construct pattern</span></div><div class="line">        StringBuilder patternBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nonProxyHosts.length(); i++) &#123;</div><div class="line">            <span class="keyword">char</span> c = nonProxyHosts.charAt(i);</div><div class="line">            <span class="keyword">switch</span> (c) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'.'</span>:</div><div class="line">                patternBuilder.append(<span class="string">"\\."</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</div><div class="line">                patternBuilder.append(<span class="string">".*"</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                patternBuilder.append(c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// check whether the host is the nonProxyHosts.</span></div><div class="line">        String pattern = patternBuilder.toString();</div><div class="line">        <span class="function"><span class="keyword">return</span> host.<span class="title">matches</span><span class="params">(pattern)</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Android平台上，主要是从系统属性System properties中获取代理服务器的配置信息，这里会过滤掉不能进行代理的主机的访问。</p>
<p>前面我们看到 <strong><code>RouteSelector</code></strong> 通过 <strong><code>Address</code></strong> 提供的Proxy和ProxySelector来收集Proxy信息及连接的目标地址信息。OkHttp3中用 <strong><code>Address</code></strong> 描述建立连接所需的配置信息，包括HTTP服务器的地址，DNS，SocketFactory，Proxy，ProxySelector及TLS所需的一些设施等等：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> HttpUrl url;</div><div class="line">  <span class="keyword">final</span> Dns dns;</div><div class="line">  <span class="keyword">final</span> SocketFactory socketFactory;</div><div class="line">  <span class="keyword">final</span> Authenticator proxyAuthenticator;</div><div class="line">  <span class="keyword">final</span> List&lt;Protocol&gt; protocols;</div><div class="line">  <span class="keyword">final</span> List&lt;ConnectionSpec&gt; connectionSpecs;</div><div class="line">  <span class="keyword">final</span> ProxySelector proxySelector;</div><div class="line">  <span class="keyword">final</span> Proxy proxy;</div><div class="line">  <span class="keyword">final</span> SSLSocketFactory sslSocketFactory;</div><div class="line">  <span class="keyword">final</span> HostnameVerifier hostnameVerifier;</div><div class="line">  <span class="keyword">final</span> CertificatePinner certificatePinner;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,</div><div class="line">      SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,</div><div class="line">      CertificatePinner certificatePinner, Authenticator proxyAuthenticator, Proxy proxy,</div><div class="line">      List&lt;Protocol&gt; protocols, List&lt;ConnectionSpec&gt; connectionSpecs, ProxySelector proxySelector) &#123;</div><div class="line">    <span class="keyword">this</span>.url = new HttpUrl.Builder()</div><div class="line">        .scheme(sslSocketFactory != <span class="literal">null</span> ? <span class="string">"https"</span> : <span class="string">"http"</span>)</div><div class="line">        .host(uriHost)</div><div class="line">        .port(uriPort)</div><div class="line">        .build();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (dns == <span class="literal">null</span>) <span class="keyword">throw</span> new NullPointerException(<span class="string">"dns == null"</span>);</div><div class="line">    <span class="keyword">this</span>.dns = dns;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (socketFactory == <span class="literal">null</span>) <span class="keyword">throw</span> new NullPointerException(<span class="string">"socketFactory == null"</span>);</div><div class="line">    <span class="keyword">this</span>.socketFactory = socketFactory;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proxyAuthenticator == <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> new NullPointerException(<span class="string">"proxyAuthenticator == null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.proxyAuthenticator = proxyAuthenticator;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (protocols == <span class="literal">null</span>) <span class="keyword">throw</span> new NullPointerException(<span class="string">"protocols == null"</span>);</div><div class="line">    <span class="keyword">this</span>.protocols = Util.immutableList(protocols);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (connectionSpecs == <span class="literal">null</span>) <span class="keyword">throw</span> new NullPointerException(<span class="string">"connectionSpecs == null"</span>);</div><div class="line">    <span class="keyword">this</span>.connectionSpecs = Util.immutableList(connectionSpecs);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proxySelector == <span class="literal">null</span>) <span class="keyword">throw</span> new NullPointerException(<span class="string">"proxySelector == null"</span>);</div><div class="line">    <span class="keyword">this</span>.proxySelector = proxySelector;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.proxy = proxy;</div><div class="line">    <span class="keyword">this</span>.sslSocketFactory = sslSocketFactory;</div><div class="line">    <span class="keyword">this</span>.hostnameVerifier = hostnameVerifier;</div><div class="line">    <span class="keyword">this</span>.certificatePinner = certificatePinner;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of</div><div class="line">   * this URL are always empty, since they are not significant for planning a route.</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> HttpUrl url() &#123;</div><div class="line">    <span class="keyword">return</span> url;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns the service that will be used to resolve IP addresses for hostnames. */</span></div><div class="line">  <span class="keyword">public</span> Dns dns() &#123;</div><div class="line">    <span class="keyword">return</span> dns;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns the socket factory for new connections. */</span></div><div class="line">  <span class="keyword">public</span> SocketFactory socketFactory() &#123;</div><div class="line">    <span class="keyword">return</span> socketFactory;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns the client's proxy authenticator. */</span></div><div class="line">  <span class="keyword">public</span> Authenticator proxyAuthenticator() &#123;</div><div class="line">    <span class="keyword">return</span> proxyAuthenticator;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Returns the protocols the client supports. This method always returns a non-null list that</div><div class="line">   * contains minimally &#123;<span class="doctag">@link</span> Protocol#HTTP_1_1&#125;.</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> List&lt;Protocol&gt; protocols() &#123;</div><div class="line">    <span class="keyword">return</span> protocols;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> List&lt;ConnectionSpec&gt; connectionSpecs() &#123;</div><div class="line">    <span class="keyword">return</span> connectionSpecs;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Returns this address's proxy selector. Only used if the proxy is null. If none of this</div><div class="line">   * selector's proxies are reachable, a direct connection will be attempted.</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> ProxySelector proxySelector() &#123;</div><div class="line">    <span class="keyword">return</span> proxySelector;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the &#123;<span class="doctag">@linkplain</span></div><div class="line">   * #proxySelector proxy selector&#125;.</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> Proxy proxy() &#123;</div><div class="line">    <span class="keyword">return</span> proxy;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns the SSL socket factory, or null if this is not an HTTPS address. */</span></div><div class="line">  <span class="keyword">public</span> SSLSocketFactory sslSocketFactory() &#123;</div><div class="line">    <span class="keyword">return</span> sslSocketFactory;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns the hostname verifier, or null if this is not an HTTPS address. */</span></div><div class="line">  <span class="keyword">public</span> HostnameVerifier hostnameVerifier() &#123;</div><div class="line">    <span class="keyword">return</span> hostnameVerifier;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns this address's certificate pinner, or null if this is not an HTTPS address. */</span></div><div class="line">  <span class="keyword">public</span> CertificatePinner certificatePinner() &#123;</div><div class="line">    <span class="keyword">return</span> certificatePinner;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OkHttp3中通过职责链执行HTTP请求。在其中的RetryAndFollowUpInterceptor里创建Address对象时，从OkHttpClient对象获取ProxySelector。Address对象会被用于创建StreamAllocation对象。StreamAllocation在建立连接时，从Address对象中获取ProxySelector以选择路由。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryAndFollowUpInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">......</div><div class="line">  <span class="keyword">private</span> Address createAddress(HttpUrl url) &#123;</div><div class="line">    SSLSocketFactory sslSocketFactory = <span class="keyword">null</span>;</div><div class="line">    HostnameVerifier hostnameVerifier = <span class="keyword">null</span>;</div><div class="line">    CertificatePinner certificatePinner = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (url.isHttps()) &#123;</div><div class="line">      sslSocketFactory = <span class="keyword">client</span>.sslSocketFactory();</div><div class="line">      hostnameVerifier = <span class="keyword">client</span>.hostnameVerifier();</div><div class="line">      certificatePinner = <span class="keyword">client</span>.certificatePinner();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Address(url.host(), url.port(), <span class="keyword">client</span>.dns(), <span class="keyword">client</span>.socketFactory(),</div><div class="line">        sslSocketFactory, hostnameVerifier, certificatePinner, <span class="keyword">client</span>.proxyAuthenticator(),</div><div class="line">        <span class="keyword">client</span>.proxy(), <span class="keyword">client</span>.protocols(), <span class="keyword">client</span>.connectionSpecs(), <span class="keyword">client</span>.proxySelector());</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在StreamAllocation中，Address对象会被用于创建 <strong><code>RouteSelector</code></strong> 对象：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAllocation</span> </span>&#123;</div><div class="line">......</div><div class="line"></div><div class="line">  <span class="keyword">public</span> StreamAllocation(ConnectionPool connectionPool, Address address) &#123;</div><div class="line">    <span class="keyword">this</span>.connectionPool = connectionPool;</div><div class="line">    <span class="keyword">this</span>.address = address;</div><div class="line">    <span class="keyword">this</span>.routeSelector = new RouteSelector(address, routeDatabase());</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h1><p>如我们在 <a href="http://www.jianshu.com/p/230e2e2988e0" target="_blank" rel="external">OkHttp3 HTTP请求执行流程分析</a> 中看到的，OkHttp3对HTTP请求是通过Interceptor链来处理的。<br><code>RetryAndFollowUpInterceptor</code>创建<code>StreamAllocation</code>对象，处理http的重定向及出错重试。对后续Interceptor的执行的影响为修改Request并创建StreamAllocation对象。<br><code>BridgeInterceptor</code>补全缺失的一些http header。对后续Interceptor的执行的影响主要为修改了Request。<br><code>CacheInterceptor</code>处理http缓存。对后续Interceptor的执行的影响为，若缓存中有所需请求的响应，则后续Interceptor不再执行。<br><code>ConnectInterceptor</code>借助于前面分配的<code>StreamAllocation</code>对象建立与服务器之间的连接，并选定交互所用的协议是HTTP 1.1还是HTTP 2。对后续Interceptor的执行的影响为，创建了HttpStream和connection。<br><code>CallServerInterceptor</code>作为Interceptor链中的最后一个Interceptor，用于处理IO，与服务器进行数据交换。</p>
<p>在OkHttp3中，收集的路由信息，是在<code>ConnectInterceptor</code>中建立连接时用到的。<code>ConnectInterceptor</code> 借助于 <strong><code>StreamAllocation</code></strong> 完成整个连接的建立，包括TCP连接建立，代理协议所要求的协商，以及SSL/TLS协议的协商，如ALPN等。我们暂时略过整个连接建立的完整过程，主要关注TCP连接建立及代理协议的协商过程的部分。</p>
<p> <strong><code>StreamAllocation</code></strong> 的findConnection()用来为某次特定的网络请求寻找一个可用的连接。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a connection to host a new stream. This prefers the existing connection if it exists,</div><div class="line"> * then the pool, finally building a new connection.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> RealConnection findConnection(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</div><div class="line">    <span class="keyword">boolean</span> connectionRetryEnabled) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  Route selectedRoute;</div><div class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">    <span class="keyword">if</span> (released) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"released"</span>);</div><div class="line">    <span class="keyword">if</span> (codec != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"codec != null"</span>);</div><div class="line">    <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line"></div><div class="line">    RealConnection allocatedConnection = <span class="keyword">this</span>.connection;</div><div class="line">    <span class="keyword">if</span> (allocatedConnection != <span class="keyword">null</span> &amp;&amp; !allocatedConnection.noNewStreams) &#123;</div><div class="line">      <span class="keyword">return</span> allocatedConnection;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Attempt to get a connection from the pool.</span></div><div class="line">    RealConnection pooledConnection = Internal.instance.get(connectionPool, address, <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (pooledConnection != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.connection = pooledConnection;</div><div class="line">      <span class="keyword">return</span> pooledConnection;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    selectedRoute = route;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</div><div class="line">    selectedRoute = routeSelector.<span class="keyword">next</span>();</div><div class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">      route = selectedRoute;</div><div class="line">      refusedStreamCount = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  RealConnection newConnection = <span class="keyword">new</span> RealConnection(selectedRoute);</div><div class="line">  acquire(newConnection);</div><div class="line"></div><div class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">    Internal.instance.put(connectionPool, newConnection);</div><div class="line">    <span class="keyword">this</span>.connection = newConnection;</div><div class="line">    <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),</div><div class="line">      connectionRetryEnabled);</div><div class="line">  routeDatabase().connected(newConnection.route());</div><div class="line"></div><div class="line">  <span class="keyword">return</span> newConnection;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OkHttp3中有一套连接池的机制，这里先尝试从连接池中寻找可用的连接，找不到时才会新建连接。新建连接的过程是：</p>
<ol>
<li>选择一个Route；</li>
<li>创建 <strong><code>RealConnection</code></strong> 连接对象。</li>
<li>将连接对象保存进连接池中。</li>
<li>建立连接。</li>
</ol>
<p><strong><code>RealConnection</code></strong> 中建立连接的过程是这样的：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span> <span class="keyword">extends</span> <span class="title">Http2Connection</span>.<span class="title">Listener</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Route route;</div><div class="line"></div><div class="line">  <span class="comment">/** The low-level TCP socket. */</span></div><div class="line">  <span class="keyword">private</span> Socket rawSocket;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The application layer socket. Either an &#123;<span class="doctag">@link</span> SSLSocket&#125; layered over &#123;<span class="doctag">@link</span> #rawSocket&#125;, or</div><div class="line">   * &#123;<span class="doctag">@link</span> #rawSocket&#125; itself if this connection does not use SSL.</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> Socket socket;</div><div class="line">  <span class="keyword">private</span> Handshake handshake;</div><div class="line">  <span class="keyword">private</span> Protocol protocol;</div><div class="line">  <span class="keyword">public</span> volatile Http2Connection http2Connection;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> successCount;</div><div class="line">  <span class="keyword">public</span> BufferedSource source;</div><div class="line">  <span class="keyword">public</span> BufferedSink sink;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">int</span> allocationLimit;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">List</span>&lt;Reference&lt;StreamAllocation&gt;&gt; allocations = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  <span class="keyword">public</span> <span class="keyword">boolean</span> noNewStreams;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">long</span> idleAtNanos = <span class="keyword">Long</span>.MAX_VALUE;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> RealConnection(Route route) &#123;</div><div class="line">    this.route = route;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> void connect(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</div><div class="line">      <span class="keyword">List</span>&lt;ConnectionSpec&gt; connectionSpecs, <span class="keyword">boolean</span> connectionRetryEnabled) &#123;</div><div class="line">    <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"already connected"</span>);</div><div class="line"></div><div class="line">    RouteException routeException = <span class="keyword">null</span>;</div><div class="line">    ConnectionSpecSelector connectionSpecSelector = <span class="keyword">new</span> ConnectionSpecSelector(connectionSpecs);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</div><div class="line">            <span class="string">"CLEARTEXT communication not enabled for client"</span>));</div><div class="line">      &#125;</div><div class="line">      String host = route.address().url().host();</div><div class="line">      <span class="keyword">if</span> (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</div><div class="line">            <span class="string">"CLEARTEXT communication to "</span> + host + <span class="string">" not permitted by network security policy"</span>));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (protocol == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (route.requiresTunnel()) &#123;</div><div class="line">          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,</div><div class="line">              connectionSpecSelector);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        closeQuietly(socket);</div><div class="line">        closeQuietly(rawSocket);</div><div class="line">        socket = <span class="keyword">null</span>;</div><div class="line">        rawSocket = <span class="keyword">null</span>;</div><div class="line">        source = <span class="keyword">null</span>;</div><div class="line">        sink = <span class="keyword">null</span>;</div><div class="line">        handshake = <span class="keyword">null</span>;</div><div class="line">        protocol = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (routeException == <span class="keyword">null</span>) &#123;</div><div class="line">          routeException = <span class="keyword">new</span> RouteException(e);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          routeException.addConnectException(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</div><div class="line">          <span class="keyword">throw</span> routeException;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在这个方法中，SSLSocketFactory为空，也就是要求请求/响应明文传输时，先做安全性检查，以确认系统允许明文传输，允许以请求的域名做明文传输。</p>
<p>然后根据路由的具体情况，执行不同的连接建立过程。对于需要创建隧道连接的路由，执行buildTunneledConnection()，对于其它情况，则执行buildConnection()。</p>
<p>判断是否要建立隧道连接的依据是代理的类型，以及连接的类型：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns true if this route tunnels HTTPS through an HTTP proxy. See &lt;a</div><div class="line"> * href="http://www.ietf.org/rfc/rfc2817.txt"&gt;RFC 2817, Section 5.2&lt;/a&gt;.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> requiresTunnel() &#123;</div><div class="line">  <span class="keyword">return</span> address.sslSocketFactory != <span class="built_in">null</span> &amp;&amp; proxy.<span class="keyword">type</span>() == Proxy.<span class="keyword">Type</span>.HTTP;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果是HTTP代理，且请求建立SSL/TLS加密通道 (http/1.1的https和http2) ，则需要建立隧道连接。其它情形不需要建立隧道连接。</p>
<h2 id="非隧道连接的建立"><a href="#非隧道连接的建立" class="headerlink" title="非隧道连接的建立"></a>非隧道连接的建立</h2><p>非隧道连接的建立过程为：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">buildConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></div><div class="line">    ConnectionSpecSelector connectionSpecSelector) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  connectSocket(connectTimeout, readTimeout);</div><div class="line">  establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  Proxy proxy = route.proxy();</div><div class="line">  Address address = route.address();</div><div class="line"></div><div class="line">  rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</div><div class="line">      ? address.socketFactory().createSocket()</div><div class="line">      : <span class="keyword">new</span> Socket(proxy);</div><div class="line"></div><div class="line">  rawSocket.setSoTimeout(readTimeout);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</div><div class="line">  &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConnectException(<span class="string">"Failed to connect to "</span> + route.socketAddress());</div><div class="line">  &#125;</div><div class="line">  source = Okio.buffer(Okio.source(rawSocket));</div><div class="line">  sink = Okio.buffer(Okio.sink(rawSocket));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有 3 种情况需要建立非隧道连接：</p>
<ol>
<li>无代理。</li>
<li>明文的HTTP代理。</li>
<li>SOCKS代理。</li>
</ol>
<p>非隧道连接的建立过程为建立TCP连接，然后在需要时完成SSL/TLS的握手及HTTP/2的握手建立Protocol。建立TCP连接的过程为：</p>
<ol>
<li>创建Socket。非SOCKS代理的情况下，通过SocketFactory创建；在SOCKS代理则传入proxy手动new一个出来。</li>
<li>为Socket设置读超时。</li>
<li>完成特定于平台的连接建立。</li>
<li>创建用语IO的source和sink。</li>
</ol>
<p><strong><code>AndroidPlatform</code></strong> 的 <strong><code>connectSocket()</code></strong> 是这样的：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(Socket socket, InetSocketAddress address,</span></span></div><div class="line">    <span class="keyword">int</span> connectTimeout) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    socket.connect(address, connectTimeout);</div><div class="line">  &#125; <span class="keyword">catch</span> (AssertionError e) &#123;</div><div class="line">    <span class="keyword">if</span> (Util.isAndroidGetsocknameError(e)) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</div><div class="line">    <span class="keyword">throw</span> e;</div><div class="line">  &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</div><div class="line">    <span class="comment">// Before android 4.3, socket.connect could throw a SecurityException</span></div><div class="line">    <span class="comment">// if opening a socket resulted in an EACCES error.</span></div><div class="line">    IOException ioException = <span class="keyword">new</span> IOException(<span class="string">"Exception in connect"</span>);</div><div class="line">    ioException.initCause(e);</div><div class="line">    <span class="keyword">throw</span> ioException;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置了SOCKS代理的情况下，仅有的特别之处在于，是通过传入proxy手动创建的Socket。route的socketAddress包含着目标HTTP服务器的域名。由此可见SOCKS协议的处理，主要是在Java标准库的 <strong><code>java.net.Socket</code></strong> 中处理的。对于外界而言，就好像是于HTTP服务器直接建立连接一样，因为连接时传入的地址都是HTTP服务器的域名。</p>
<p>而对于明文HTTP代理的情况下，这里没有任何特殊的处理。route的socketAddress包含着代理服务器的IP地址。HTTP代理自身会根据请求及响应的实际内容，建立与HTTP服务器的TCP连接，并转发数据。猜测HTTP代理服务器是根据HTTP请求中的”Host”等header内容来确认HTTP服务器地址的。</p>
<p>暂时先略过对建立协议过程的分析。</p>
<h2 id="HTTP代理的隧道连接"><a href="#HTTP代理的隧道连接" class="headerlink" title="HTTP代理的隧道连接"></a>HTTP代理的隧道连接</h2><p>buildTunneledConnection()用于建立隧道连接：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a</div><div class="line"> * proxy server can issue an auth challenge and then close the connection.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> buildTunneledConnection(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</div><div class="line">    ConnectionSpecSelector connectionSpecSelector) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  Request tunnelRequest = createTunnelRequest();</div><div class="line">  HttpUrl url = tunnelRequest.url();</div><div class="line">  <span class="keyword">int</span> attemptedConnections = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> maxAttempts = <span class="number">21</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (++attemptedConnections &gt; maxAttempts) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many tunnel connections attempted: "</span> + maxAttempts);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    connectSocket(connectTimeout, readTimeout);</div><div class="line">    tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (tunnelRequest == <span class="keyword">null</span>) <span class="keyword">break</span>; <span class="comment">// Tunnel successfully created.</span></div><div class="line"></div><div class="line">    <span class="comment">// The proxy decided to close the connection after an auth challenge. We need to create a new</span></div><div class="line">    <span class="comment">// connection, but this time with the auth credentials.</span></div><div class="line">    closeQuietly(rawSocket);</div><div class="line">    rawSocket = <span class="keyword">null</span>;</div><div class="line">    sink = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">source</span> = <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要是两个过程：</p>
<ol>
<li>建立隧道连接。</li>
<li>建立Protocol。</li>
</ol>
<p>建立隧道连接的过程又分为几个步骤：</p>
<ul>
<li>创建隧道请求</li>
<li>建立Socket连接</li>
<li>发送请求建立隧道</li>
</ul>
<p>隧道请求是一个常规的HTTP请求，只是请求的内容有点特殊。最初创建的隧道请求如：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request</div><div class="line"> * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.</div><div class="line"> * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.</div><div class="line"> */</div><div class="line"><span class="selector-tag">private</span> <span class="selector-tag">Request</span> <span class="selector-tag">createTunnelRequest</span>() &#123;</div><div class="line">  <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">Request</span><span class="selector-class">.Builder</span>()</div><div class="line">      <span class="selector-class">.url</span>(route.address().url(<span class="string"></span>))</div><div class="line">      <span class="selector-class">.header</span>(<span class="string">"Host"</span>, Util.hostHeader(route.address().url(<span class="string"></span>), true))</div><div class="line">      <span class="selector-class">.header</span>(<span class="string">"Proxy-Connection"</span>, <span class="string">"Keep-Alive"</span>)</div><div class="line">      <span class="selector-class">.header</span>(<span class="string">"User-Agent"</span>, Version.userAgent()) <span class="comment">// For HTTP/1.0 proxies like Squid.</span></div><div class="line">      <span class="selector-class">.build</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个隧道请求的例子如下：</p>
<p><img src="https://www.wolfcstech.com/images/1315506-f2b7ee35c56c732b.jpg" alt="Tunnel Request"></p>
<p>请求的”Host” header中包含了目标HTTP服务器的域名。建立socket连接的过程这里不再赘述。</p>
<p>创建隧道的过程是这样子的：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create</div><div class="line"> * the proxy connection. This may need to be retried if the proxy requires authorization.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> Request createTunnel(<span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, Request tunnelRequest,</div><div class="line">    HttpUrl url) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="comment">// Make an SSL Tunnel on the first message pair of each SSL + proxy connection.</span></div><div class="line">  String requestLine = <span class="string">"CONNECT "</span> + Util.hostHeader(url, <span class="keyword">true</span>) + <span class="string">" HTTP/1.1"</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    Http1Codec tunnelConnection = <span class="keyword">new</span> Http1Codec(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">source</span>, sink);</div><div class="line">    <span class="keyword">source</span>.timeout().timeout(readTimeout, MILLISECONDS);</div><div class="line">    sink.timeout().timeout(writeTimeout, MILLISECONDS);</div><div class="line">    tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);</div><div class="line">    tunnelConnection.finishRequest();</div><div class="line">    Response response = tunnelConnection.readResponse().request(tunnelRequest).build();</div><div class="line">    <span class="comment">// The response body from a CONNECT should be empty, but if it is not then we should consume</span></div><div class="line">    <span class="comment">// it before proceeding.</span></div><div class="line">    <span class="keyword">long</span> contentLength = HttpHeaders.contentLength(response);</div><div class="line">    <span class="keyword">if</span> (contentLength == -<span class="number">1</span>L) &#123;</div><div class="line">      contentLength = <span class="number">0</span>L;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">Source</span> body = tunnelConnection.newFixedLengthSource(contentLength);</div><div class="line">    Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</div><div class="line">    body.close();</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (response.code()) &#123;</div><div class="line">      <span class="keyword">case</span> HTTP_OK:</div><div class="line">        <span class="comment">// Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If</span></div><div class="line">        <span class="comment">// that happens, then we will have buffered bytes that are needed by the SSLSocket!</span></div><div class="line">        <span class="comment">// This check is imperfect: it doesn't tell us whether a handshake will succeed, just</span></div><div class="line">        <span class="comment">// that it will almost certainly fail because the proxy has sent unexpected data.</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">source</span>.buffer().exhausted() || !sink.buffer().exhausted()) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"TLS tunnel buffered too many bytes!"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> HTTP_PROXY_AUTH:</div><div class="line">        tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);</div><div class="line">        <span class="keyword">if</span> (tunnelRequest == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to authenticate with proxy"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</div><div class="line">          <span class="keyword">return</span> tunnelRequest;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</div><div class="line">            <span class="string">"Unexpected response code for CONNECT: "</span> + response.code());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在前面创建的TCP连接之上，完成与代理服务器的HTTP请求/响应交互。请求的内容类似下面这样：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"<span class="keyword">CONNECT</span> m.taobao.com:443 HTTP/1.1"</span></div></pre></td></tr></table></figure></p>
<p>这里可能会根据HTTP代理是否需要认证而有多次HTTP请求/响应交互。</p>
<p>总结一下OkHttp3中代理相关的处理：</p>
<ol>
<li>没有设置代理的情况下，直接与HTTP服务器建立TCP连接，然后进行HTTP请求/响应的交互。</li>
<li>设置了SOCKS代理的情况下，创建Socket时，为其传入proxy，连接时还是以HTTP服务器为目标地址。在标准库的Socket中完成SOCKS协议相关的处理。此时基本上感知不到代理的存在。</li>
<li>设置了HTTP代理时的HTTP请求，与HTTP代理服务器建立TCP连接。HTTP代理服务器解析HTTP请求/响应的内容，并根据其中的信息来完成数据的转发。也就是说，如果HTTP请求中不包含”Host” header，则有可能在设置了HTTP代理的情况下无法与HTTP服务器建立连接。</li>
<li>设置了HTTP代理时的HTTPS/HTTP2请求，与HTTP服务器建立通过HTTP代理的隧道连接。HTTP代理不再解析传输的数据，仅仅完成数据转发的功能。此时HTTP代理的功能退化为如同SOCKS代理类似。</li>
<li>设置了代理时，HTTP服务器的域名解析会被交给代理服务器执行。其中设置了HTTP代理时，会对HTTP代理的域名做域名解析。</li>
</ol>
<p>关于HTTP代理的更多内容，可以参考<a href="https://imququ.com/post/web-proxy.html" target="_blank" rel="external">HTTP 代理原理及实现（一）</a>。</p>
<p>OkHttp3中代理相关的处理大体如此。</p>
</div><div class="tags"><a href="/tags/网络协议/">网络协议</a><a href="/tags/Android开发/">Android开发</a><a href="/tags/源码分析/">源码分析</a></div><div class="post-nav"><a href="/2016/10/16/Chromium_Android编译指南/" class="pre">Chromium Android编译指南</a><a href="/2016/10/11/Chromium-net-design/" class="next">Chromium net design</a></div><div id="disqus_thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-图形系统/">Android 图形系统</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发/">Android开发</a><span class="category-list-count">29</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-开发/">C/C++开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java开发/">Java开发</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核/">Linux内核</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/live555/">live555</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/业界趣闻/">业界趣闻</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/云计算/">云计算</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台开发/">后台开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络调试/">网络调试</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随想杂谈/">随想杂谈</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频开发/">音视频开发</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/UDT/" style="font-size: 15px;">UDT</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/Android开发/" style="font-size: 15px;">Android开发</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/chromium/" style="font-size: 15px;">chromium</a> <a href="/tags/后台开发/" style="font-size: 15px;">后台开发</a> <a href="/tags/Java开发/" style="font-size: 15px;">Java开发</a> <a href="/tags/QUIC/" style="font-size: 15px;">QUIC</a> <a href="/tags/网络调试/" style="font-size: 15px;">网络调试</a> <a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/HTTP2/" style="font-size: 15px;">HTTP2</a> <a href="/tags/图形图像/" style="font-size: 15px;">图形图像</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/C-C-开发/" style="font-size: 15px;">C/C++开发</a> <a href="/tags/音视频开发/" style="font-size: 15px;">音视频开发</a> <a href="/tags/Linux内核/" style="font-size: 15px;">Linux内核</a> <a href="/tags/live555/" style="font-size: 15px;">live555</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Go-语言/" style="font-size: 15px;">Go 语言</a> <a href="/tags/云计算/" style="font-size: 15px;">云计算</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">二月 2013</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/06/anbox_lxc/">Anbox LXC</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/lxc_c_api_usage/">LXC C API 使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/04/ubuntu_lxc/">Ubuntu LXC</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/01/anbox_container_manager_service/">Anbox 容器管理服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/run_anbox/">运行 Anbox</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/Anbox/">Anbox</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/24/gerrit_codereview/">Gerrit代码审核服务器搭建全过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/20/adb_overview/">关于 ADB 实现的说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/adb-standalone/">adb standalone</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/qcow2_on_linux/">在 Linux 上如何挂载 qcow2 磁盘镜像</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="https://source.android.com/" title="Android Open Source Project" target="_blank">Android Open Source Project</a><ul></ul><a href="http://www.vants.org/" title="蚂蚁网" target="_blank">蚂蚁网</a></div><div class="widget"><div class="widget-title"><i class="fa fa-commt"> 最近评论</i></div><script type="text/javascript" src="//wolfcstech.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.2.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:hanpfei@gmail.com" target="_blank" class="fa fa-email"> </a><a href="undefined" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/hanpfei" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">Han Pengfei</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var disqus_shortname = 'wolfcstech';
var disqus_identifier = '2016/10/14/OkHttp3中的代理与路由/';
var disqus_title = 'OkHttp3中的代理与路由';
var disqus_url = 'https://www.wolfcstech.com/2016/10/14/OkHttp3中的代理与路由/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wolfcstech.disqus.com/count.js" async></script><script type="text/javascript" src="/js/search.json.js?v=1.2.0"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-109419024-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3c736b12c32c019fd9ff6c825b6b9b44";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></body></html>