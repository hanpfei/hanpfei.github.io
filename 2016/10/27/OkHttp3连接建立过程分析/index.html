<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/freesoft.jpg?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/freesoft.jpg?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/freesoft.jpg?v=6.0.3">


  <link rel="mask-icon" href="/images/freesoft.jpg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="网络协议,Android开发,源码分析," />


<meta name="description" content="如我们前面在 OkHttp3 HTTP请求执行流程分析 中的分析，OkHttp3通过Interceptor链来执行HTTP请求，整体的执行过程大体如下：">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp3连接建立过程分析">
<meta property="og:url" content="https://www.wolfcstech.com/2016/10/27/OkHttp3连接建立过程分析/index.html">
<meta property="og:site_name" content="WolfcsTech">
<meta property="og:description" content="如我们前面在 OkHttp3 HTTP请求执行流程分析 中的分析，OkHttp3通过Interceptor链来执行HTTP请求，整体的执行过程大体如下：">
<meta property="og:image" content="https://www.wolfcstech.com/images/1315506-8492fecef4238d86.png">
<meta property="og:image" content="https://www.wolfcstech.com/images/1315506-6a60bf781625e166.png">
<meta property="og:image" content="https://www.wolfcstech.com/images/1315506-338a7a0b0a39a278.png">
<meta property="og:updated_time" content="2017-02-16T06:59:36.173Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OkHttp3连接建立过程分析">
<meta name="twitter:description" content="如我们前面在 OkHttp3 HTTP请求执行流程分析 中的分析，OkHttp3通过Interceptor链来执行HTTP请求，整体的执行过程大体如下：">
<meta name="twitter:image" content="https://www.wolfcstech.com/images/1315506-8492fecef4238d86.png">






  <link rel="canonical" href="https://www.wolfcstech.com/2016/10/27/OkHttp3连接建立过程分析/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>OkHttp3连接建立过程分析 | WolfcsTech</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-109419024-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-109419024-1');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3c736b12c32c019fd9ff6c825b6b9b44";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WolfcsTech</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="http://www.ixirong.com/404.html" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />Commonweal 404</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.wolfcstech.com/2016/10/27/OkHttp3连接建立过程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han Pengfei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/freesoft.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WolfcsTech">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OkHttp3连接建立过程分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-27T11:43:49+08:00">2016-10-27</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/27/OkHttp3连接建立过程分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2016/10/27/OkHttp3连接建立过程分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/10/27/OkHttp3连接建立过程分析/" class="leancloud_visitors" data-flag-title="OkHttp3连接建立过程分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>如我们前面在 <a href="https://www.wolfcstech.com/2016/10/14/OkHttp3-HTTP%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">OkHttp3 HTTP请求执行流程分析</a> 中的分析，OkHttp3通过Interceptor链来执行HTTP请求，整体的执行过程大体如下：</p>
<a id="more"></a>
<p><img src="https://www.wolfcstech.com/images/1315506-8492fecef4238d86.png" alt="OkHttp Flow"></p>
<p>这些Interceptor中每一个的职责，这里不再赘述。</p>
<p>在OkHttp3中，<code>StreamAllocation</code>是用来建立执行HTTP请求所需网络设施的组件，如其名字所显示的那样，分配Stream。但它具体做的事情根据是否设置了代理，以及请求的类型，如HTTP、HTTPS或HTTP/2的不同而有所不同。代理相关的处理，包括TCP连接的建立，在 <a href="https://www.wolfcstech.cn/2016/10/14/OkHttp3%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B7%AF%E7%94%B1/" target="_blank" rel="external">OkHttp3中的代理与路由</a> 一文中有详细的说明。</p>
<p>在整个HTTP请求的执行过程中，<strong><code>StreamAllocation</code></strong> 对象分配的比较早，在RetryAndFollowUpInterceptor.intercept(Chain chain)中就完成了：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override <span class="keyword">public</span> <span class="built_in">Response</span> intercept(Chain chain) throws IOException &#123;</div><div class="line">  <span class="built_in">Request</span> <span class="built_in">request</span> = chain.<span class="built_in">request</span>();</div><div class="line"></div><div class="line">  streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">      client.connectionPool(), createAddress(<span class="built_in">request</span>.url()), callStackTrace);</div></pre></td></tr></table></figure></p>
<p><code>StreamAllocation</code>的对象构造过程没有什么特别的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) &#123;</div><div class="line">  <span class="keyword">this</span>.connectionPool = connectionPool;</div><div class="line">  <span class="keyword">this</span>.address = address;</div><div class="line">  <span class="keyword">this</span>.routeSelector = new RouteSelector(address, routeDatabase());</div><div class="line">  <span class="keyword">this</span>.callStackTrace = callStackTrace;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在OkHttp3中，<code>okhttp3.internal.http.RealInterceptorChain</code>将Interceptor连接成执行链。<code>RetryAndFollowUpInterceptor</code>借助于<code>RealInterceptorChain</code>将创建的<code>StreamAllocation</code>对象传递给后面执行的Interceptor。而在<code>RealInterceptorChain</code>中，<code>StreamAllocation</code>对象并没有被真正用到。紧跟在<code>RetryAndFollowUpInterceptor</code>之后执行的 <code>okhttp3.internal.http.BridgeInterceptor</code> 和 <code>okhttp3.internal.cache.CacheInterceptor</code>，它们的职责分别是补足用户创建的请求中缺少的必须的请求头和处理缓存，也没有真正用到<code>StreamAllocation</code>对象。</p>
<p>在OkHttp3的HTTP请求执行过程中，<code>okhttp3.internal.connection.ConnectInterceptor</code>和<code>okhttp3.internal.http.CallServerInterceptor</code>是与网络交互的关键。</p>
<p><code>CallServerInterceptor</code>负责将HTTP请求写入网络IO流，并从网络IO流中读取服务器返回的数据。而<code>ConnectInterceptor</code>则负责为<code>CallServerInterceptor</code>建立可用的连接。此处 <strong>可用的</strong> 含义主要为，可以直接写入HTTP请求的数据：</p>
<ul>
<li>设置了HTTP代理的HTTP请求，与代理建立好TCP连接；</li>
<li>设置了HTTP代理的HTTPS请求，与HTTP服务器建立通过HTTP代理的隧道连接，并完成TLS握手；</li>
<li>设置了HTTP代理的HTTP/2请求，与HTTP服务器建立通过HTTP代理的隧道连接，并完成与服务器的TLS握手及协议协商；</li>
<li>设置了SOCKS代理的HTTP请求，通过代理与HTTP服务器建立好连接；</li>
<li>设置了SOCKS代理的HTTPS请求，通过代理与HTTP服务器建立好连接，并完成TLS握手；</li>
<li>设置了SOCKS代理的HTTP/2请求，通过代理与HTTP服务器建立好连接，并完成与服务器的TLS握手及协议协商；</li>
<li>无代理的HTTP请求，与服务器建立好TCP连接；</li>
<li>无代理的HTTPS请求，与服务器建立TCP连接，并完成TLS握手；</li>
<li>无代理的HTTP/2请求，与服务器建立好TCP连接，完成TLS握手及协议协商。</li>
</ul>
<p>后面我们更详细地来看一下这个过程。</p>
<p><code>ConnectInterceptor</code>的代码看上去比较简单：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient <span class="keyword">client</span>;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> ConnectInterceptor(OkHttpClient <span class="keyword">client</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">client</span> = <span class="keyword">client</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override <span class="keyword">public</span> Response intercept(Chain chain) throws IOException &#123;</div><div class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">    Request request = realChain.request();</div><div class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line"></div><div class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></div><div class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</div><div class="line">    HttpCodec httpCodec = streamAllocation.newStream(<span class="keyword">client</span>, doExtensiveHealthChecks);</div><div class="line">    RealConnection connection = streamAllocation.connection();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ConnectInterceptor</code>从<code>RealInterceptorChain</code>获取前面的Interceptor传过来的<code>StreamAllocation</code>对象，执行 <code>streamAllocation.newStream()</code> 完成前述所有的连接建立工作，并将这个过程中创建的用于网络IO的RealConnection对象，以及对于与服务器交互最为关键的HttpCodec等对象传递给后面的Interceptor，也就是<code>CallServerInterceptor</code>。</p>
<h1 id="OkHttp3的连接池"><a href="#OkHttp3的连接池" class="headerlink" title="OkHttp3的连接池"></a>OkHttp3的连接池</h1><p>在具体地分析 <code>streamAllocation.newStream()</code> 的执行过程之前，我们先来看一下OkHttp3的连接池的设计实现。</p>
<p>OkHttp3将客户端与服务器之间的连接抽象为Connection/RealConnection，为了管理这些连接的复用而设计了ConnectionPool。共享相同<code>Address</code>的请求可以复用连接，ConnectionPool实现了哪些连接保持打开状态以备后用的策略。</p>
<h2 id="ConnectionPool是什么？"><a href="#ConnectionPool是什么？" class="headerlink" title="ConnectionPool是什么？"></a>ConnectionPool是什么？</h2><p>借助于ConnectionPool的成员变量声明来一窥ConnectionPool究竟是什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Manages reuse of HTTP and HTTP/2 connections for reduced network latency. HTTP requests that</div><div class="line"> * share the same &#123;<span class="doctag">@link</span> Address&#125; may share a &#123;<span class="doctag">@link</span> Connection&#125;. This class implements the policy</div><div class="line"> * of which connections to keep open for future use.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Background threads are used to cleanup expired connections. There will be at most a single</div><div class="line">   * thread running per connection pool. The thread pool executor permits the pool itself to be</div><div class="line">   * garbage collected.</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</div><div class="line">      Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,</div><div class="line">      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp ConnectionPool"</span>, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">  <span class="comment">/** The maximum number of idle connections for each address. */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIdleConnections;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveDurationNs;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</div><div class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</div><div class="line">          waitNanos -= (waitMillis * <span class="number">1000000L</span>);</div><div class="line">          <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">  <span class="keyword">final</span> RouteDatabase routeDatabase = <span class="keyword">new</span> RouteDatabase();</div><div class="line">  <span class="keyword">boolean</span> cleanupRunning;</div></pre></td></tr></table></figure></p>
<p><code>ConnectionPool</code>的核心是<code>RealConnection</code>的容器，且是顺序容器，而不是关联容器。<code>ConnectionPool</code>用双端队列<code>Deque&lt;RealConnection&gt;</code>来保存它所管理的所有<code>RealConnection</code>。</p>
<p><code>ConnectionPool</code>还会对连接池中最大的空闲连接数及连接的保活时间进行控制，<code>maxIdleConnections</code>和<code>keepAliveDurationNs</code>成员分别体现对最大空闲连接数及连接保活时间的控制。这种控制通过匿名的<code>Runnable cleanupRunnable</code>在线程池<code>executor</code>中执行，并在向连接池中添加新的<code>RealConnection</code>触发。</p>
<h2 id="连接池ConnectionPool的创建"><a href="#连接池ConnectionPool的创建" class="headerlink" title="连接池ConnectionPool的创建"></a>连接池ConnectionPool的创建</h2><p>OkHttp3的用户可以自行创建ConnectionPool，对最大空闲连接数及连接的保活时间进行配置，并在OkHttpClient创建期间，将其传给OkHttpClient.Builder，在OkHttpClient中启用它。没有定制连接池的情况下，则在OkHttpClient.Builder构造过程中以默认参数创建：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">Builder() </span>&#123;</div><div class="line">  <span class="keyword">dispatcher </span>= new <span class="keyword">Dispatcher();</span></div><div class="line">  protocols = DEFAULT_PROTOCOLS<span class="comment">;</span></div><div class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS<span class="comment">;</span></div><div class="line">  proxySelector = ProxySelector.getDefault()<span class="comment">;</span></div><div class="line">  cookieJar = CookieJar.NO_COOKIES<span class="comment">;</span></div><div class="line">  socketFactory = SocketFactory.getDefault()<span class="comment">;</span></div><div class="line">  hostnameVerifier = OkHostnameVerifier.<span class="keyword">INSTANCE;</span></div><div class="line">  certificatePinner = CertificatePinner.DEFAULT<span class="comment">;</span></div><div class="line">  proxyAuthenticator = Authenticator.NONE<span class="comment">;</span></div><div class="line">  authenticator = Authenticator.NONE<span class="comment">;</span></div><div class="line">  connectionPool = new ConnectionPool()<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>ConnectionPool的默认构造过程如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Create a new connection pool with tuning parameters appropriate for a single-user application.</div><div class="line"> * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently</div><div class="line"> * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> maxIdleConnections, <span class="keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.maxIdleConnections = maxIdleConnections;</div><div class="line">  <span class="keyword">this</span>.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);</div><div class="line"></div><div class="line">  <span class="comment">// Put a floor on the keep alive duration, otherwise cleanup will spin loop.</span></div><div class="line">  <span class="keyword">if</span> (keepAliveDuration &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"keepAliveDuration &lt;= 0: "</span> + keepAliveDuration);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在默认情况下，<code>ConnectionPool</code> 最多保存 <strong><em>5个</em></strong> 处于空闲状态的连接，且连接的默认保活时间为 <strong><em>5分钟</em></strong>。</p>
<h2 id="RealConnection的存-取"><a href="#RealConnection的存-取" class="headerlink" title="RealConnection的存/取"></a>RealConnection的存/取</h2><p>OkHttp内部的组件可以通过put()方法向<code>ConnectionPool</code>中添加<code>RealConnection</code>：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</div><div class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</div><div class="line">  <span class="keyword">if</span> (!cleanupRunning) &#123;</div><div class="line">    cleanupRunning = <span class="keyword">true</span>;</div><div class="line">    executor.execute(cleanupRunnable);</div><div class="line">  &#125;</div><div class="line">  connections.add(connection);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在向<code>ConnectionPool</code>中添加<code>RealConnection</code>时，若发现cleanupRunnable还没有运行会触发它的运行。</p>
<p>cleanupRunnable的职责本就是清理无效的<code>RealConnection</code>，只要<code>ConnectionPool</code>中存在<code>RealConnection</code>，则这种清理的需求总是存在的，因而这里会去启动cleanupRunnable。</p>
<p>根据需要启动了cleanupRunnable之后，将<code>RealConnection</code>添加进双端队列connections。</p>
<p>这里先启动 <code>cleanupRunnable</code>，后向 <code>connections</code> 中添加<code>RealConnection</code>。有没有可能发生：</p>
<p>启动<code>cleanupRunnable</code>之后，向<code>connections</code>中添加<code>RealConnection</code>之前，执行 put() 的线程被抢占，<code>cleanupRunnable</code>的线程被执行，它发现<code>connections</code>中没有任何<code>RealConnection</code>，于是从容地退出而导致后面添加的<code>RealConnection</code>永远不会得得清理。</p>
<p>这样的情况呢？答案是 不会。为什么呢？<code>put()</code>执行之前总是会用<code>ConnectionPool</code>对象锁来保护，而在<code>ConnectionPool.cleanup()</code>中，遍历<code>connections</code>也总是会先对<code>ConnectionPool</code>对象加锁保护的。即使执行 put() 的线程被抢占，<code>cleanupRunnable</code>的线程也会由于拿不到<code>ConnectionPool</code>对象锁而等待 put() 执行结束。</p>
<p>OkHttp内部的组件可以通过 <code>get()</code> 方法从<code>ConnectionPool</code>中获取<code>RealConnection</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Returns a recycled connection to &#123;<span class="doctag">@code</span> address&#125;, or null if no such connection exists. */</span></div><div class="line">RealConnection <span class="keyword">get</span>(Address address, StreamAllocation streamAllocation) &#123;</div><div class="line">  assert (Thread.holdsLock(<span class="keyword">this</span>));</div><div class="line">  <span class="keyword">for</span> (RealConnection connection : connections) &#123;</div><div class="line">    <span class="keyword">if</span> (connection.allocations.size() &lt; connection.allocationLimit</div><div class="line">        &amp;&amp; address.equals(connection.route().address)</div><div class="line">        &amp;&amp; !connection.noNewStreams) &#123;</div><div class="line">      streamAllocation.acquire(connection);</div><div class="line">      <span class="keyword">return</span> connection;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>get()</code> 方法遍历 <code>connections</code> 中的所有 <code>RealConnection</code> 寻找同时满足如下三个条件的<code>RealConnection</code>：</p>
<ul>
<li><p><code>RealConnection</code>的allocations的数量小于allocationLimit。每个allocation代表在该<code>RealConnection</code>上正在执行的一个请求。这个条件用于控制相同连接上，同一时间执行的并发请求的个数。对于HTTP/2连接而言，allocationLimit限制是在连接建立阶段由双方协商的。对于HTTP或HTTPS连接而言，这个值则总是1。从<code>RealConnection.establishProtocol()</code>可以清晰地看到这一点：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (protocol == Protocol.HTTP_2) &#123;</div><div class="line">  socket.setSoTimeout(<span class="number">0</span>); <span class="comment">// Framed connection timeouts are set per-stream.</span></div><div class="line"></div><div class="line">  Http2Connection http2Connection = new Http2Connection.Builder(<span class="literal">true</span>)</div><div class="line">      .socket(socket, route.address().url().host(), source, sink)</div><div class="line">      .listener(<span class="keyword">this</span>)</div><div class="line">      .build();</div><div class="line">  http2Connection.start();</div><div class="line"></div><div class="line">  <span class="comment">// Only assign the framed connection once the preface has been sent successfully.</span></div><div class="line">  <span class="keyword">this</span>.allocationLimit = http2Connection.maxConcurrentStreams();</div><div class="line">  <span class="keyword">this</span>.http2Connection = http2Connection;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.allocationLimit = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>RealConnection</code> 的 <code>address</code> 与传入的 <code>Address</code> 参数相等。<code>RealConnection</code> 的 <code>address</code> 描述建立连接所需的配置信息，包括对端的信息等，不难理解只有所有相关配置相等时 <code>RealConnection</code> 才是真正能复用的。具体看一下<code>Address</code>相等性比较的依据：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="keyword">public</span> boolean equals(Object other) &#123;</div><div class="line">  <span class="keyword">if</span> (other instanceof Address) &#123;</div><div class="line">    Address that = (Address) other;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.url.equals(that.url)</div><div class="line">        &amp;&amp; <span class="keyword">this</span>.dns.equals(that.dns)</div><div class="line">        &amp;&amp; <span class="keyword">this</span>.proxyAuthenticator.equals(that.proxyAuthenticator)</div><div class="line">        &amp;&amp; <span class="keyword">this</span>.protocols.equals(that.protocols)</div><div class="line">        &amp;&amp; <span class="keyword">this</span>.connectionSpecs.equals(that.connectionSpecs)</div><div class="line">        &amp;&amp; <span class="keyword">this</span>.proxySelector.equals(that.proxySelector)</div><div class="line">        &amp;&amp; equal(<span class="keyword">this</span>.proxy, that.proxy)</div><div class="line">        &amp;&amp; equal(<span class="keyword">this</span>.sslSocketFactory, that.sslSocketFactory)</div><div class="line">        &amp;&amp; equal(<span class="keyword">this</span>.hostnameVerifier, that.hostnameVerifier)</div><div class="line">        &amp;&amp; equal(<span class="keyword">this</span>.certificatePinner, that.certificatePinner);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这种相等性的条件给人感觉还是蛮苛刻的，特别是对url的对比。<br>这难免会让我们有些担心，对 <code>Address</code> 如此苛刻的相等性比较，又有多大的机会能复用连接呢？<br>我们的担心其实是多余的。只有在 <code>StreamAllocation.findConnection()</code> 中，会通过<code>Internal.instance</code> 调用 <code>ConnectionPool.get()</code> 来获取 <code>RealConnection</code> ：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function">RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></div><div class="line">    <span class="keyword">boolean</span> connectionRetryEnabled) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  Route selectedRoute;</div><div class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">    <span class="keyword">if</span> (released) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"released"</span>);</div><div class="line">    <span class="keyword">if</span> (codec != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"codec != null"</span>);</div><div class="line">    <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line"></div><div class="line">    RealConnection allocatedConnection = <span class="keyword">this</span>.connection;</div><div class="line">    <span class="keyword">if</span> (allocatedConnection != <span class="keyword">null</span> &amp;&amp; !allocatedConnection.noNewStreams) &#123;</div><div class="line">      <span class="keyword">return</span> allocatedConnection;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Attempt to get a connection from the pool.</span></div><div class="line">    RealConnection pooledConnection = Internal.instance.get(connectionPool, address, <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (pooledConnection != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.connection = pooledConnection;</div><div class="line">      <span class="keyword">return</span> pooledConnection;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    selectedRoute = route;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</div><div class="line">    selectedRoute = routeSelector.next();</div><div class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">      route = selectedRoute;</div><div class="line">      refusedStreamCount = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  RealConnection newConnection = <span class="keyword">new</span> RealConnection(selectedRoute);</div><div class="line"></div><div class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">    acquire(newConnection);</div><div class="line">    Internal.instance.put(connectionPool, newConnection);</div><div class="line">    <span class="keyword">this</span>.connection = newConnection;</div><div class="line">    <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Internal.instance的实现在OkHttpClient 中：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">  Internal.instance = <span class="keyword">new</span> Internal() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">addLenient</span><span class="params">(Headers.Builder builder, String line)</span> </span>&#123;</div><div class="line">      builder.addLenient(line);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">addLenient</span><span class="params">(Headers.Builder builder, String name, String value)</span> </span>&#123;</div><div class="line">      builder.addLenient(name, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setCache</span><span class="params">(OkHttpClient.Builder builder, InternalCache internalCache)</span> </span>&#123;</div><div class="line">      builder.setInternalCache(internalCache);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">connectionBecameIdle</span><span class="params">(</span></span></div><div class="line">        ConnectionPool pool, RealConnection connection) &#123;</div><div class="line">      <span class="function"><span class="keyword">return</span> pool.<span class="title">connectionBecameIdle</span><span class="params">(connection)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">RealConnection <span class="title">get</span><span class="params">(</span></span></div><div class="line">        ConnectionPool pool, Address address, StreamAllocation streamAllocation) &#123;</div><div class="line">      <span class="function"><span class="keyword">return</span> pool.<span class="title">get</span><span class="params">(address, streamAllocation)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(ConnectionPool pool, RealConnection connection)</span> </span>&#123;</div><div class="line">      pool.put(connection);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">RouteDatabase <span class="title">routeDatabase</span><span class="params">(ConnectionPool connectionPool)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> connectionPool.routeDatabase;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">StreamAllocation <span class="title">callEngineGetStreamAllocation</span><span class="params">(Call call)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> ((RealCall) call).streamAllocation();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可见 <code>ConnectionPool.get()</code> 的 <code>Address</code> 参数来自于<code>StreamAllocation</code>。<code>StreamAllocation</code>的<code>Address</code> 在构造时由外部传入。构造了<code>StreamAllocation</code>对象的<code>RetryAndFollowUpInterceptor</code>，其构造<code>Address</code>的过程是这样的：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Address createAddress(HttpUrl url) &#123;</div><div class="line">  SSLSocketFactory sslSocketFactory = <span class="keyword">null</span>;</div><div class="line">  HostnameVerifier hostnameVerifier = <span class="keyword">null</span>;</div><div class="line">  CertificatePinner certificatePinner = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">if</span> (url.isHttps()) &#123;</div><div class="line">    sslSocketFactory = <span class="keyword">client</span>.sslSocketFactory();</div><div class="line">    hostnameVerifier = <span class="keyword">client</span>.hostnameVerifier();</div><div class="line">    certificatePinner = <span class="keyword">client</span>.certificatePinner();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Address(url.host(), url.port(), <span class="keyword">client</span>.dns(), <span class="keyword">client</span>.socketFactory(),</div><div class="line">      sslSocketFactory, hostnameVerifier, certificatePinner, <span class="keyword">client</span>.proxyAuthenticator(),</div><div class="line">      <span class="keyword">client</span>.proxy(), <span class="keyword">client</span>.protocols(), <span class="keyword">client</span>.connectionSpecs(), <span class="keyword">client</span>.proxySelector());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Address</code> 除了 <code>uriHost</code> 和 <code>uriPort</code> 外的所有构造参数均来自于OkHttpClient，而<code>Address</code>的<code>url</code> 字段正是根据这两个参数构造的：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String uriHost, <span class="keyword">int</span> uriPort, Dns dns, SocketFactory socketFactory,</span></span></div><div class="line">    SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,</div><div class="line">    CertificatePinner certificatePinner, Authenticator proxyAuthenticator, Proxy proxy,</div><div class="line">    List&lt;Protocol&gt; protocols, List&lt;ConnectionSpec&gt; connectionSpecs, ProxySelector proxySelector) &#123;</div><div class="line">  <span class="keyword">this</span>.url = <span class="keyword">new</span> HttpUrl.Builder()</div><div class="line">      .scheme(sslSocketFactory != <span class="keyword">null</span> ? <span class="string">"https"</span> : <span class="string">"http"</span>)</div><div class="line">      .host(uriHost)</div><div class="line">      .port(uriPort)</div><div class="line">      .build();</div></pre></td></tr></table></figure></p>
<p>可见 <code>Address</code> 的 <code>url</code> 字段仅包含HTTP请求url的 schema + host + port 这三部分的信息，而不包含 path 和 query 等信息。<code>ConnectionPool</code>主要是根据服务器的地址来决定复用的。</p>
<ul>
<li><code>RealConnection</code>还有可分配的Stream。对于HTTP或HTTPS而言，不能同时在相同的连接上执行多个请求。即使对于HTTP/2而言，StreamID的空间也是有限的，同一个连接上的StreamID总有分配完的时候，而在StreamID被分配完了之后，该连接就不能再被使用了。</li>
</ul>
<p>OkHttp内部对<code>ConnectionPool</code>的访问总是通过Internal.instance来进行。整个OkHttp中也只有<code>StreamAllocation</code> 存取了 <code>ConnectionPool</code>，也就是我们前面列出的<code>StreamAllocation.findConnection()</code> 方法，相关的组件之间的关系大体如下图：</p>
<p><img src="https://www.wolfcstech.com/images/1315506-6a60bf781625e166.png" alt="OkHttp Connection Pool"></p>
<h2 id="RealConnection的清理"><a href="#RealConnection的清理" class="headerlink" title="RealConnection的清理"></a>RealConnection的清理</h2><p><code>ConnectionPool</code> 中对于 <code>RealConnection</code> 的清理在put()方法中触发，执行 <code>cleanupRunnable</code> 来完成清理动作：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</div><div class="line">      <span class="keyword">if</span> (waitNanos == <span class="number">-1</span>) <span class="keyword">return</span>;</div><div class="line">      <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000</span>L;</div><div class="line">        waitNanos -= (waitMillis * <span class="number">1000000</span>L);</div><div class="line">        <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</div><div class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>cleanupRunnable</code>每执行一次清理动作，都会等待一段时间再次执行，而具体等待的时长由<code>cleanup()</code>方法决定，直到<code>cleanup()</code>方法返回-1退出。<code>cleanup()</code>方法定义如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Performs maintenance on this pool, evicting the connection that has been idle the longest if</div><div class="line"> * either it has exceeded the keep alive limit or the idle connections limit.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Returns the duration in nanos to sleep until the next scheduled call to this method. Returns</div><div class="line"> * -1 if no further cleanups are required.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span>(<span class="params"><span class="keyword">long</span> now</span>) </span>&#123;</div><div class="line">  <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</div><div class="line">  RealConnection longestIdleConnection = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</div><div class="line"></div><div class="line">  <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></div><div class="line">  synchronized (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</div><div class="line">      RealConnection connection = i.next();</div><div class="line"></div><div class="line">      <span class="comment">// If the connection is in use, keep searching.</span></div><div class="line">      <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</div><div class="line">        inUseConnectionCount++;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      idleConnectionCount++;</div><div class="line"></div><div class="line">      <span class="comment">// If the connection is ready to be evicted, we're done.</span></div><div class="line">      <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</div><div class="line">      <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</div><div class="line">        longestIdleDurationNs = idleDurationNs;</div><div class="line">        longestIdleConnection = connection;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</div><div class="line">        || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</div><div class="line">      <span class="comment">// We've found a connection to evict. Remove it from the list, then close it below (outside</span></div><div class="line">      <span class="comment">// of the synchronized block).</span></div><div class="line">      connections.<span class="keyword">remove</span>(longestIdleConnection);</div><div class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">idleConnectionCount &gt; <span class="number">0</span></span>) </span>&#123;</div><div class="line">      <span class="comment">// A connection will be ready to evict soon.</span></div><div class="line">      <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</div><div class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params">inUseConnectionCount &gt; <span class="number">0</span></span>) </span>&#123;</div><div class="line">      <span class="comment">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span></div><div class="line">      <span class="keyword">return</span> keepAliveDurationNs;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// No connections, idle or in use.</span></div><div class="line">      cleanupRunning = <span class="literal">false</span>;</div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  closeQuietly(longestIdleConnection.socket());</div><div class="line"></div><div class="line">  <span class="comment">// Cleanup again immediately.</span></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Prunes any leaked allocations and then returns the number of remaining live allocations on</div><div class="line"> * &#123;@code connection&#125;. Allocations are leaked if the connection is tracking them but the</div><div class="line"> * application code has abandoned them. Leak detection is imprecise and relies on garbage</div><div class="line"> * collection.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span>(<span class="params">RealConnection connection, <span class="keyword">long</span> now</span>) </span>&#123;</div><div class="line">  List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; references.size(); ) &#123;</div><div class="line">    Reference&lt;StreamAllocation&gt; reference = references.<span class="keyword">get</span>(i);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (reference.<span class="keyword">get</span>() != <span class="literal">null</span>) &#123;</div><div class="line">      i++;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// We've discovered a leaked allocation. This is an application bug.</span></div><div class="line">    StreamAllocation.StreamAllocationReference streamAllocRef =</div><div class="line">        (StreamAllocation.StreamAllocationReference) reference;</div><div class="line">    String message = <span class="string">"A connection to "</span> + connection.route().address().url()</div><div class="line">        + <span class="string">" was leaked. Did you forget to close a response body?"</span>;</div><div class="line">    Platform.<span class="keyword">get</span>().logCloseableLeak(message, streamAllocRef.callStackTrace);</div><div class="line"></div><div class="line">    references.<span class="keyword">remove</span>(i);</div><div class="line">    connection.noNewStreams = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span></div><div class="line">    <span class="keyword">if</span> (references.isEmpty()) &#123;</div><div class="line">      connection.idleAtNanos = now - keepAliveDurationNs;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> references.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>cleanup()</code>方法遍历<code>connections</code>，并从中找到处于空闲状态时间最长的一个<code>RealConnection</code>，然后根据查找结果的不同，分为以下几种情况处理：</p>
<ul>
<li>找到一个处于空闲状态的<code>RealConnection</code>，且该<code>RealConnection</code>处于空闲状态的时间超出了设置的保活时间，或者当前<code>ConnectionPool</code>中处于空闲状态的连接数超出了设置的最大空闲连接数，将该<code>RealConnection</code>从<code>connections</code>中移除，并关闭该<code>RealConnection</code>关联的底层socket，然后返回0，以此请求<code>cleanupRunnable</code>立即再次检查所有的连接。</li>
<li>找到一个处于空闲状态的<code>RealConnection</code>，但该<code>RealConnection</code>处于空闲状态的时间尚未超出设置的保活时间，且当前<code>ConnectionPool</code>中处于空闲状态的连接数尚未超出设置的最大空闲连接数，则返回保活时间与该<code>RealConnection</code>处于空闲状态的时间之间的差值，请求<code>cleanupRunnable</code>等待这么长一段时间之后再次检查所有的连接。</li>
<li>没有找到处于空闲状态的连接，但找到了使用中的连接，则返回保活时间，请求<code>cleanupRunnable</code>等待这么长一段时间之后再次检查所有的连接。</li>
<li>没有找到处于空闲状态的连接，也没有找到使用中的连接，也就意味着连接池中尚没有任何连接，则将 <code>cleanupRunning</code> 置为false，并返回 -1，请求 <code>cleanupRunnable</code> 退出。</li>
</ul>
<p><code>cleanup()</code> 通过 <code>pruneAndGetAllocationCount()</code> 检查正在使用一个特定连接的请求个数，并以此来判断一个连接是否处于空闲状态。后者通遍历 <code>connection.allocations</code> 并检查每个元素的<code>StreamAllocation</code> 的状态，若<code>StreamAllocation</code> 为空，则认为是发现了一个leak，它会更新连接的空闲时间为当前时间减去保活时间并返回0，以此请求 <code>cleanup()</code> 立即关闭、清理掉该 leak 的连接。</p>
<h2 id="ConnectionPool的用户接口"><a href="#ConnectionPool的用户接口" class="headerlink" title="ConnectionPool的用户接口"></a>ConnectionPool的用户接口</h2><p>OkHttp的用户可以自己创建 <code>ConnectionPool</code> 对象，这个类也提供了一些用户接口以方便用户获取空闲状态的连接数、总的连接数，以及手动清除空闲状态的连接：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/** Returns the number of idle connections in the pool. */</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">int</span> <span class="title">idleConnectionCount</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</div><div class="line">      <span class="keyword">if</span> (connection.allocations.isEmpty()) total++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> total;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included</div><div class="line">   * only idle connections and HTTP/2 connections. Since OkHttp 2.7 this includes all connections,</div><div class="line">   * both active and inactive. Use &#123;<span class="doctag">@link</span> #idleConnectionCount()&#125; to count connections not currently</div><div class="line">   * in use.</div><div class="line">   */</div><div class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">int</span> <span class="title">connectionCount</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> connections.<span class="title">size</span><span class="params">()</span></span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">  <span class="comment">/** Close and remove all idle connections in the pool. */</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">evictAll</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;RealConnection&gt; evictedConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</div><div class="line">        RealConnection connection = i.next();</div><div class="line">        <span class="keyword">if</span> (connection.allocations.isEmpty()) &#123;</div><div class="line">          connection.noNewStreams = <span class="keyword">true</span>;</div><div class="line">          evictedConnections.add(connection);</div><div class="line">          i.remove();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (RealConnection connection : evictedConnections) &#123;</div><div class="line">      closeQuietly(connection.socket());</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1 id="新建流"><a href="#新建流" class="headerlink" title="新建流"></a>新建流</h1><p>回到新建流的过程，连接建立的各种细节处理都在这里。 <code>StreamAllocation.newStream()</code> 完成新建流的动作：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> HttpCodec newStream(OkHttpClient <span class="keyword">client</span>, <span class="keyword">boolean</span> doExtensiveHealthChecks) &#123;</div><div class="line">  <span class="keyword">int</span> connectTimeout = <span class="keyword">client</span>.connectTimeoutMillis();</div><div class="line">  <span class="keyword">int</span> readTimeout = <span class="keyword">client</span>.readTimeoutMillis();</div><div class="line">  <span class="keyword">int</span> writeTimeout = <span class="keyword">client</span>.writeTimeoutMillis();</div><div class="line">  <span class="keyword">boolean</span> connectionRetryEnabled = <span class="keyword">client</span>.retryOnConnectionFailure();</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</div><div class="line">        writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</div><div class="line"></div><div class="line">    HttpCodec resultCodec;</div><div class="line">    <span class="keyword">if</span> (resultConnection.http2Connection != <span class="keyword">null</span>) &#123;</div><div class="line">      resultCodec = <span class="keyword">new</span> Http2Codec(<span class="keyword">client</span>, <span class="keyword">this</span>, resultConnection.http2Connection);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      resultConnection.socket().setSoTimeout(readTimeout);</div><div class="line">      resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);</div><div class="line">      resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);</div><div class="line">      resultCodec = <span class="keyword">new</span> Http1Codec(</div><div class="line">          <span class="keyword">client</span>, <span class="keyword">this</span>, resultConnection.source, resultConnection.sink);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    synchronized (connectionPool) &#123;</div><div class="line">      codec = resultCodec;</div><div class="line">      <span class="keyword">return</span> resultCodec;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所谓的流，是封装了底层的IO，可以直接用来收发数据的组件，它会将请求的数据序列化之后发送到网络，并将接收的数据反序列化为应用程序方便操作的格式。在 OkHttp3 中，这样的组件被抽象为<code>HttpCodec</code>。<code>HttpCodec</code>的定义如下 (okhttp/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java)：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Encodes HTTP requests and decodes HTTP responses. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">HttpCodec</span> &#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The timeout to use while discarding a stream of input data. Since this is used for connection</div><div class="line">   * reuse, this timeout should be significantly less than the time it takes to establish a new</div><div class="line">   * connection.</div><div class="line">   */</div><div class="line">  <span class="keyword">int</span> DISCARD_STREAM_TIMEOUT_MILLIS = <span class="number">100</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns an output stream where the request body can be streamed. */</span></div><div class="line">  <span class="function">Sink <span class="title">createRequestBody</span>(<span class="params">Request request, <span class="keyword">long</span> contentLength</span>)</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** This should update the HTTP engine's sentRequestMillis field. */</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">writeRequestHeaders</span>(<span class="params">Request request</span>) throws IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Flush the request to the underlying socket. */</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">finishRequest</span>(<span class="params"></span>) throws IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Read and return response headers. */</span></div><div class="line">  Response.<span class="function">Builder <span class="title">readResponseHeaders</span>(<span class="params"></span>) throws IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Returns a stream that reads the response body. */</span></div><div class="line">  <span class="function">ResponseBody <span class="title">openResponseBody</span>(<span class="params">Response response</span>) throws IOException</span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.</div><div class="line">   * That may happen later by the connection pool thread.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span>(<span class="params"></span>)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>HttpCodec</code>提供了这样的一些操作：</p>
<ul>
<li>为发送请求而提供的，写入请求头部。</li>
<li>为发送请求而提供的，创建请求体，以用于发送请求体数据。</li>
<li>为发送请求而提供的，结束请求发送。</li>
<li>为获得响应而提供的，读取响应头部。</li>
<li>为获得响应而提供的，打开请求体，以用于后续获取请求体数据。</li>
<li>取消请求执行。</li>
</ul>
<p><code>StreamAllocation.newStream()</code> 主要做的事情正是创建<code>HttpCodec</code>。<code>StreamAllocation.newStream()</code> 根据 <code>OkHttpClient</code>中的设置，连接超时、读超时、写超时及连接失败是否重试，调用 <code>findHealthyConnection()</code> 完成 连接，即<code>RealConnection</code> 的创建。然后根据HTTP协议的版本创建Http1Codec或Http2Codec。</p>
<p><code>findHealthyConnection()</code> 根据目标服务器地址查找一个连接，如果它是可用的就直接返回，如果不可用则会重复查找直到找到一个可用的为止。在连接已被破坏而不可用时，还会释放连接：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated</div><div class="line"> * until a healthy connection is found.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="function">RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></div><div class="line">    <span class="keyword">int</span> writeTimeout, <span class="keyword">boolean</span> connectionRetryEnabled, <span class="keyword">boolean</span> doExtensiveHealthChecks)</div><div class="line">    <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</div><div class="line">        connectionRetryEnabled);</div><div class="line"></div><div class="line">    <span class="comment">// If this is a brand new connection, we can skip the extensive health checks.</span></div><div class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">      <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> candidate;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></div><div class="line">    <span class="comment">// isn't, take it out of the pool and start again.</span></div><div class="line">    <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</div><div class="line">      noNewStreams();</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> candidate;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>连接是否可用的标准如下 (okhttp/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java)：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Returns true if this connection is ready to host new streams. */</span></div><div class="line"><span class="keyword">public</span> boolean isHealthy(boolean doExtensiveChecks) &#123;</div><div class="line">  <span class="keyword">if</span> (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// <span class="doctag">TODO:</span> check framedConnection.shutdown.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (doExtensiveChecks) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      int readTimeout = socket.getSoTimeout();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        socket.setSoTimeout(<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (source.exhausted()) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Stream is exhausted; socket is closed.</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        socket.setSoTimeout(readTimeout);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (SocketTimeoutException ignored) &#123;</div><div class="line">      <span class="comment">// Read timed out; socket is good.</span></div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Couldn't read; socket is closed.</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先要可以进行IO，此外对于HTTP/2，只要<code>http2Connection</code>存在即可。如我们前面在<code>ConnectInterceptor</code> 中看到的，如果HTTP请求的method不是 “GET” ，<code>doExtensiveChecks</code>为true时，需要做额外的检查。</p>
<p><code>findHealthyConnection()</code> 通过 <code>findConnection()</code>查找一个连接：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a connection to host a new stream. This prefers the existing connection if it exists,</div><div class="line"> * then the pool, finally building a new connection.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> RealConnection findConnection(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</div><div class="line">    <span class="keyword">boolean</span> connectionRetryEnabled) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  Route selectedRoute;</div><div class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">    <span class="keyword">if</span> (released) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"released"</span>);</div><div class="line">    <span class="keyword">if</span> (codec != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"codec != null"</span>);</div><div class="line">    <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line"></div><div class="line">    RealConnection allocatedConnection = <span class="keyword">this</span>.connection;</div><div class="line">    <span class="keyword">if</span> (allocatedConnection != <span class="keyword">null</span> &amp;&amp; !allocatedConnection.noNewStreams) &#123;</div><div class="line">      <span class="keyword">return</span> allocatedConnection;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Attempt to get a connection from the pool.</span></div><div class="line">    RealConnection pooledConnection = Internal.instance.get(connectionPool, address, <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (pooledConnection != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.connection = pooledConnection;</div><div class="line">      <span class="keyword">return</span> pooledConnection;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    selectedRoute = route;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</div><div class="line">    selectedRoute = routeSelector.<span class="keyword">next</span>();</div><div class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">      route = selectedRoute;</div><div class="line">      refusedStreamCount = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  RealConnection newConnection = <span class="keyword">new</span> RealConnection(selectedRoute);</div><div class="line"></div><div class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">    acquire(newConnection);</div><div class="line">    Internal.instance.put(connectionPool, newConnection);</div><div class="line">    <span class="keyword">this</span>.connection = newConnection;</div><div class="line">    <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),</div><div class="line">      connectionRetryEnabled);</div><div class="line">  routeDatabase().connected(newConnection.route());</div><div class="line"></div><div class="line">  <span class="keyword">return</span> newConnection;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>findConnection()</code> 返回一个用于流执行底层IO的连接。这个方法优先复用已经创建的连接；在没有可复用连接的情况下新建一个。</p>
<p>在同一次 <code>newStream()</code> 的执行过程中，有没有可能两次执行 <code>findConnection()</code> ，第一次<code>connection</code> 字段为空，第二次不为空？这个地方对<code>connection</code>字段的检查，看起来有点多余。执行 <code>findConnection()</code> 时，<code>connection</code> 不为空的话，意味着 <code>codec</code> 不为空，而在方法的开始处已经有对<code>codec</code>字段的状态做过检查。真的是这样的吗？</p>
<p>答案当然是否定的。同一次 <code>newStream()</code> 的执行过程中，没有可能两次执行<code>findConnection()</code>，第一次<code>connection</code>字段为空，第二次不为空，然而一个HTTP请求的执行过程，又不是一定只调用一次<code>newStream()</code>。</p>
<p><code>newStream()</code>的直接调用者是<code>ConnectInterceptor</code>，所有的Interceptor用<code>RealInterceptorChain</code>链起来，在Interceptor链中，<code>ConnectInterceptor</code> 和<code>RetryAndFollowUpInterceptor</code> 隔着 <code>CacheInterceptor</code> 和 <code>BridgeInterceptor</code> 。然而<code>newStream()</code> 如果出错的话，则是会通过抛出<code>Exception</code>返回到<code>RetryAndFollowUpInterceptor</code> 来处理错误的。</p>
<p><code>RetryAndFollowUpInterceptor</code> 中会尝试基于相同的 <code>StreamAllocation</code> 对象来恢复对HTTP请求的处理。<code>RetryAndFollowUpInterceptor</code> 通过 <code>hasMoreRoutes()</code> 等方法，来检查<code>StreamAllocation</code> 对象的状态，通过 <code>streamFailed(IOException e)</code>、<code>release()</code>、<code>streamFinished(boolean noNewStreams, HttpCodec codec)</code>等方法来reset <code>StreamAllocation</code>对象的一些状态。</p>
<p>回到<code>StreamAllocation</code>的 <code>findConnection()</code>方法。没有连接存在，且连接池中也没有找到所需的连接时，它会新建一个连接。通过如下的步骤新建连接：</p>
<ul>
<li>为连接选择一个<code>Route</code>。</li>
<li><p>新建一个<code>RealConnection</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RealConnection</span><span class="params">(Route route)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.route = route;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>将当前<code>StreamAllocation</code>对象的引用保存进<code>RealConnection</code>的allocations。如我们前面在分析ConnectionPool时所见的那样，这主要是为了追踪<code>RealConnection</code>。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Use this allocation to hold &#123;<span class="doctag">@code</span> connection&#125;. Each call to this must be paired with a call to</div><div class="line"> * &#123;<span class="doctag">@link</span> #release&#125; on the same connection.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(RealConnection connection)</span> </span>&#123;</div><div class="line">  <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</div><div class="line">  connection.allocations.add(<span class="keyword">new</span> StreamAllocationReference(<span class="keyword">this</span>, callStackTrace));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>将<code>RealConnection</code>保存进连接池。</p>
</li>
<li>保存对<code>RealConnection</code>的引用。</li>
<li>检查请求是否被取消，若取消，则抛出异常。</li>
<li>建立连接。</li>
<li>更新RouteDatabase中<code>Route</code>的状态。</li>
</ul>
<h1 id="ConnectionSpec"><a href="#ConnectionSpec" class="headerlink" title="ConnectionSpec"></a>ConnectionSpec</h1><p>在OkHttp中，ConnectionSpec用于描述传输HTTP流量的socket连接的配置。对于https请求，这些配置主要包括协商安全连接时要使用的TLS版本号和密码套件，是否支持TLS扩展等；对于http请求则几乎不包含什么信息。</p>
<p>OkHttp有预定义几组ConnectionSpec (okhttp/okhttp/src/main/java/okhttp3/ConnectionSpec.java)：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** A modern TLS connection with extensions like SNI and ALPN available. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConnectionSpec MODERN_TLS = <span class="keyword">new</span> Builder(<span class="keyword">true</span>)</div><div class="line">    .cipherSuites(APPROVED_CIPHER_SUITES)</div><div class="line">    .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)</div><div class="line">    .supportsTlsExtensions(<span class="keyword">true</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line"><span class="comment">/** A backwards-compatible fallback connection for interop with obsolete servers. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConnectionSpec COMPATIBLE_TLS = <span class="keyword">new</span> Builder(MODERN_TLS)</div><div class="line">    .tlsVersions(TlsVersion.TLS_1_0)</div><div class="line">    .supportsTlsExtensions(<span class="keyword">true</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line"><span class="comment">/** Unencrypted, unauthenticated connections for &#123;<span class="doctag">@code</span> http:&#125; URLs. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConnectionSpec CLEARTEXT = <span class="keyword">new</span> Builder(<span class="keyword">false</span>).build();</div></pre></td></tr></table></figure></p>
<p>预定义的这些<code>ConnectionSpec</code>被组织为默认<code>ConnectionSpec</code>集合 (okhttp/okhttp/src/main/java/okhttp3/OkHttpClient.java)：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Call</span>.<span class="title">Factory</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">List</span>&lt;Protocol&gt; DEFAULT_PROTOCOLS = Util.immutableList(</div><div class="line">      Protocol.HTTP_2, Protocol.HTTP_1_1);</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">List</span>&lt;ConnectionSpec&gt; DEFAULT_CONNECTION_SPECS = Util.immutableList(</div><div class="line">      ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);</div></pre></td></tr></table></figure></p>
<p>OkHttp中由OkHttpClient管理<code>ConnectionSpec</code>集合 。OkHttp的用户可以在构造<code>OkHttpClient</code>的过程中提供自己的<code>ConnectionSpec</code>集合。默认情况下<code>OkHttpClient</code>会使用前面看到的默认<code>ConnectionSpec</code>集合。</p>
<p>在<code>RetryAndFollowUpInterceptor</code>中创建<code>Address</code>时，<code>ConnectionSpec</code>集合被从<code>OkHttpClient</code>获取，并由<code>Address</code>引用。</p>
<p>OkHttp还提供了<code>ConnectionSpecSelector</code>，用以从<code>ConnectionSpec</code>集合中选择与SSLSocket匹配的<code>ConnectionSpec</code>，并对SSLSocket做配置的操作。</p>
<p>在<code>StreamAllocation</code>的findConnection()中，<code>ConnectionSpec</code>集合被从<code>Address</code>中取出来，以用于连接建立过程。</p>
<h1 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h1><p>回到连接建立的过程。<code>RealConnection.connect()</code>执行连接建立的过程(okhttp/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java)：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> connect(<span class="built_in">int</span> connectTimeout, <span class="built_in">int</span> readTimeout, <span class="built_in">int</span> writeTimeout,</div><div class="line">    List&lt;ConnectionSpec&gt; connectionSpecs, <span class="built_in">boolean</span> connectionRetryEnabled) &#123;</div><div class="line">  <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"already connected"</span>);</div><div class="line"></div><div class="line">  RouteException routeException = <span class="keyword">null</span>;</div><div class="line">  ConnectionSpecSelector connectionSpecSelector = <span class="keyword">new</span> ConnectionSpecSelector(connectionSpecs);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</div><div class="line">          <span class="string">"CLEARTEXT communication not enabled for client"</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">String</span> host = route.address().url().host();</div><div class="line">    <span class="keyword">if</span> (!Platform.<span class="built_in">get</span>().isCleartextTrafficPermitted(host)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</div><div class="line">          <span class="string">"CLEARTEXT communication to "</span> + host + <span class="string">" not permitted by network security policy"</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (protocol == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> (route.requiresTunnel()) &#123;</div><div class="line">        buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,</div><div class="line">            connectionSpecSelector);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      closeQuietly(socket);</div><div class="line">      closeQuietly(rawSocket);</div><div class="line">      socket = <span class="keyword">null</span>;</div><div class="line">      rawSocket = <span class="keyword">null</span>;</div><div class="line">      source = <span class="keyword">null</span>;</div><div class="line">      sink = <span class="keyword">null</span>;</div><div class="line">      handshake = <span class="keyword">null</span>;</div><div class="line">      protocol = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (routeException == <span class="keyword">null</span>) &#123;</div><div class="line">        routeException = <span class="keyword">new</span> RouteException(e);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        routeException.addConnectException(e);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</div><div class="line">        <span class="keyword">throw</span> routeException;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的执行过程大体如下：</p>
<ul>
<li>检查连接是否已经建立，若已经建立，则抛出异常，否则继续执行。连接是否建立由<code>protocol</code> 标识，它表示在整个连接建立，及可能的协议协商过程中选择的所要使用的协议。</li>
<li>根据<code>ConnectionSpec</code>集合<code>connectionSpecs</code>构造<code>ConnectionSpecSelector</code>。</li>
<li>若请求不是安全的请求，会对请求再执行一些额外的限制。这些限制包括：<ul>
<li><code>ConnectionSpec</code>集合中必须要包含<code>ConnectionSpec.CLEARTEXT</code>。这也就是说，OkHttp的用户可以通过为<code>OkHttpClient</code>设置不包含<code>ConnectionSpec.CLEARTEXT</code>的<code>ConnectionSpec</code>集合来禁用所有的明文请求。</li>
<li>平台本身的安全策略允许向相应的主机发送明文请求。对于Android平台而言，这种安全策略主要由系统的组件<code>android.security.NetworkSecurityPolicy</code>执行 (okhttp/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java)：<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isCleartextTrafficPermitted</span><span class="params">(String hostname)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Class&lt;?&gt; networkPolicyClass = Class.forName(<span class="string">"android.security.NetworkSecurityPolicy"</span>);</div><div class="line">    Method getInstanceMethod = networkPolicyClass.getMethod(<span class="string">"getInstance"</span>);</div><div class="line">    Object networkSecurityPolicy = getInstanceMethod.invoke(<span class="keyword">null</span>);</div><div class="line">    Method isCleartextTrafficPermittedMethod = networkPolicyClass</div><div class="line">        .getMethod(<span class="string">"isCleartextTrafficPermitted"</span>, String.class);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">boolean</span>) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);</div><div class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException | NoSuchMethodException e) &#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">isCleartextTrafficPermitted</span><span class="params">(hostname)</span></span>;</div><div class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>平台的这种安全策略并不是每个Android版本都有的。Android 6.0之后存在这种控制。</p>
<ul>
<li>根据请求是否需要建立隧道连接，而分别执行<code>buildTunneledConnection()</code> 和 <code>buildConnection()</code>。是否需要建立隧道连接的依据为 (okhttp/okhttp/src/main/java/okhttp3/Route.java)：<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns true if this route tunnels HTTPS through an HTTP proxy. See &lt;a</div><div class="line"> * href="http://www.ietf.org/rfc/rfc2817.txt"&gt;RFC 2817, Section 5.2&lt;/a&gt;.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> requiresTunnel() &#123;</div><div class="line">  <span class="keyword">return</span> address.sslSocketFactory != <span class="built_in">null</span> &amp;&amp; proxy.<span class="keyword">type</span>() == Proxy.<span class="keyword">Type</span>.HTTP;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>即对于设置了HTTP代理，且安全的连接 (SSL) 需要请求代理服务器建立一个到目标HTTP服务器的隧道连接，客户端与HTTP代理建立TCP连接，以此请求HTTP代理服务在客户端与HTTP服务器之间进行数据的盲转发。</p>
<h2 id="建立隧道连接"><a href="#建立隧道连接" class="headerlink" title="建立隧道连接"></a>建立隧道连接</h2><p>建立隧道连接的过程如下：</p>
<ol>
<li>构造一个 建立隧道连接 请求。</li>
<li>与HTTP代理服务器建立TCP连接。</li>
<li>创建隧道。这主要是将 建立隧道连接 请求发送给HTTP代理服务器，并处理它的响应。</li>
<li>重复上面的第2和第3步，知道建立好了隧道连接。至于为什么要重复多次，及关于代理认证的内容，可以参考代理协议相关的内容。</li>
<li>建立协议。</li>
</ol>
<p>关于建立隧道连接更详细的过程可参考 <a href="https://www.wolfcstech.cn/2016/10/14/OkHttp3%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B7%AF%E7%94%B1/" target="_blank" rel="external">OkHttp3中的代理与路由</a> 的相关部分。</p>
<h2 id="建立普通连接"><a href="#建立普通连接" class="headerlink" title="建立普通连接"></a>建立普通连接</h2><p>建立普通连接的过程比较直接：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></div><div class="line">    ConnectionSpecSelector connectionSpecSelector) throws IOException &#123;</div><div class="line">  connectSocket(connectTimeout, readTimeout);</div><div class="line">  establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>建立一个TCP连接。</li>
<li>建立协议。</li>
</ol>
<p>更详细的过程可参考 <a href="https://www.wolfcstech.cn/2016/10/14/OkHttp3%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B7%AF%E7%94%B1/" target="_blank" rel="external">OkHttp3中的代理与路由</a> 的相关部分。</p>
<h2 id="建立协议"><a href="#建立协议" class="headerlink" title="建立协议"></a>建立协议</h2><p>不管是建立隧道连接，还是建立普通连接，都少不了 建立协议 这一步。这一步是在建立好了TCP连接之后，而在该TCP能被拿来收发数据之前执行的。它主要为数据的加密传输做一些初始化，比如TLS握手，HTTP/2的协议协商等。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">establishProtocol</span><span class="params">(<span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></div><div class="line">    ConnectionSpecSelector connectionSpecSelector) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">if</span> (route.address().sslSocketFactory() != <span class="keyword">null</span>) &#123;</div><div class="line">    connectTls(readTimeout, writeTimeout, connectionSpecSelector);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    protocol = Protocol.HTTP_1_1;</div><div class="line">    socket = rawSocket;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (protocol == Protocol.HTTP_2) &#123;</div><div class="line">    socket.setSoTimeout(<span class="number">0</span>); <span class="comment">// Framed connection timeouts are set per-stream.</span></div><div class="line"></div><div class="line">    Http2Connection http2Connection = <span class="keyword">new</span> Http2Connection.Builder(<span class="keyword">true</span>)</div><div class="line">        .socket(socket, route.address().url().host(), source, sink)</div><div class="line">        .listener(<span class="keyword">this</span>)</div><div class="line">        .build();</div><div class="line">    http2Connection.start();</div><div class="line"></div><div class="line">    <span class="comment">// Only assign the framed connection once the preface has been sent successfully.</span></div><div class="line">    <span class="keyword">this</span>.allocationLimit = http2Connection.maxConcurrentStreams();</div><div class="line">    <span class="keyword">this</span>.http2Connection = http2Connection;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.allocationLimit = <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>对于加密的数据传输，创建TLS连接。对于明文传输，则设置<code>protocol</code>和<code>socket</code>。<br><code>socket</code>指向直接与应用层，如HTTP或HTTP/2，交互的Socket：<br>对于明文传输没有设置HTTP代理的HTTP请求，它是与HTTP服务器之间的TCP socket；<br>对于明文传输设置了HTTP代理或SOCKS代理的HTTP请求，它是与代理服务器之间的TCP socket；<br>对于加密传输没有设置HTTP代理服务器的HTTP或HTTP2请求，它是与HTTP服务器之间的SSLScoket；<br>对于加密传输设置了HTTP代理服务器的HTTP或HTTP2请求，它是与HTTP服务器之间经过了代理服务器的SSLSocket，一个隧道连接；<br>对于加密传输设置了SOCKS代理的HTTP或HTTP2请求，它是一条经过了代理服务器的SSLSocket连接。</p>
</li>
<li><p>对于HTTP/2，会建立HTTP/2连接，并进一步协商连接参数，如连接上可同时执行的并发请求数等。而对于非HTTP/2，则将连接上可同时执行的并发请求数设置为1。</p>
</li>
</ol>
<h2 id="建立TLS连接"><a href="#建立TLS连接" class="headerlink" title="建立TLS连接"></a>建立TLS连接</h2><p>进一步来看建立协议过程中，为安全请求所做的建立TLS连接的过程：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> connectTls(<span class="built_in">int</span> readTimeout, <span class="built_in">int</span> writeTimeout,</div><div class="line">    ConnectionSpecSelector connectionSpecSelector) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  Address address = route.address();</div><div class="line">  SSLSocketFactory sslSocketFactory = address.sslSocketFactory();</div><div class="line">  <span class="built_in">boolean</span> success = <span class="keyword">false</span>;</div><div class="line">  SSLSocket sslSocket = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// Create the wrapper over the connected socket.</span></div><div class="line">    sslSocket = (SSLSocket) sslSocketFactory.createSocket(</div><div class="line">        rawSocket, address.url().host(), address.url().port(), <span class="keyword">true</span> <span class="comment">/* autoClose */</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Configure the socket's ciphers, TLS versions, and extensions.</span></div><div class="line">    ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);</div><div class="line">    <span class="keyword">if</span> (connectionSpec.supportsTlsExtensions()) &#123;</div><div class="line">      Platform.<span class="built_in">get</span>().configureTlsExtensions(</div><div class="line">          sslSocket, address.url().host(), address.protocols());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Force handshake. This can throw!</span></div><div class="line">    sslSocket.startHandshake();</div><div class="line">    Handshake unverifiedHandshake = Handshake.<span class="built_in">get</span>(sslSocket.getSession());</div><div class="line"></div><div class="line">    <span class="comment">// Verify that the socket's certificates are acceptable for the target host.</span></div><div class="line">    <span class="keyword">if</span> (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) &#123;</div><div class="line">      X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().<span class="built_in">get</span>(<span class="number">0</span>);</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SSLPeerUnverifiedException(<span class="string">"Hostname "</span> + address.url().host() + <span class="string">" not verified:"</span></div><div class="line">          + <span class="string">"\n    certificate: "</span> + CertificatePinner.pin(cert)</div><div class="line">          + <span class="string">"\n    DN: "</span> + cert.getSubjectDN().getName()</div><div class="line">          + <span class="string">"\n    subjectAltNames: "</span> + OkHostnameVerifier.allSubjectAltNames(cert));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Check that the certificate pinner is satisfied by the certificates presented.</span></div><div class="line">    address.certificatePinner().check(address.url().host(),</div><div class="line">        unverifiedHandshake.peerCertificates());</div><div class="line"></div><div class="line">    <span class="comment">// Success! Save the handshake and the ALPN protocol.</span></div><div class="line">    <span class="keyword">String</span> maybeProtocol = connectionSpec.supportsTlsExtensions()</div><div class="line">        ? Platform.<span class="built_in">get</span>().getSelectedProtocol(sslSocket)</div><div class="line">        : <span class="keyword">null</span>;</div><div class="line">    socket = sslSocket;</div><div class="line">    source = Okio.buffer(Okio.source(socket));</div><div class="line">    sink = Okio.buffer(Okio.sink(socket));</div><div class="line">    handshake = unverifiedHandshake;</div><div class="line">    protocol = maybeProtocol != <span class="keyword">null</span></div><div class="line">        ? Protocol.<span class="built_in">get</span>(maybeProtocol)</div><div class="line">        : Protocol.HTTP_1_1;</div><div class="line">    success = <span class="keyword">true</span>;</div><div class="line">  &#125; <span class="keyword">catch</span> (AssertionError e) &#123;</div><div class="line">    <span class="keyword">if</span> (Util.isAndroidGetsocknameError(e)) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</div><div class="line">    <span class="keyword">throw</span> e;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (sslSocket != <span class="keyword">null</span>) &#123;</div><div class="line">      Platform.<span class="built_in">get</span>().afterHandshake(sslSocket);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!success) &#123;</div><div class="line">      closeQuietly(sslSocket);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TLS连接是对原始的TCP连接的一个封装，以提供TLS握手，及数据收发过程中的加密解密等功能。在Java中，用SSLSocket来描述。上面建立TLS连接的过程大体为：</p>
<ol>
<li>用SSLSocketFactory基于原始的TCP Socket，创建一个SSLSocket。</li>
<li>配置SSLSocket。</li>
<li>在前面选择的ConnectionSpec支持TLS扩展参数时，配置TLS扩展参数。</li>
<li>启动TLS握手。</li>
<li>TLS握手完成之后，获取握手信息。</li>
<li>对TLS握手过程中传回来的证书进行验证。</li>
<li>检查证书钉扎。</li>
<li>在前面选择的ConnectionSpec支持TLS扩展参数时，获取TLS握手过程中顺便完成的协议协商过程所选择的协议。这个过程主要用于HTTP/2的ALPN扩展。</li>
<li>OkHttp主要使用Okio来做IO操作，这里会基于前面获取的SSLSocket创建用于执行IO的BufferedSource和BufferedSink等，并保存握手信息及所选择的协议。</li>
</ol>
<p>具体来看<code>ConnectionSpecSelector</code>中配置SSLSocket的过程：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Configures the supplied &#123;<span class="doctag">@link</span> SSLSocket&#125; to connect to the specified host using an appropriate</div><div class="line"> * &#123;<span class="doctag">@link</span> ConnectionSpec&#125;. Returns the chosen &#123;<span class="doctag">@link</span> ConnectionSpec&#125;, never &#123;<span class="doctag">@code</span> null&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@throws</span> IOException if the socket does not support any of the TLS modes available</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="function">ConnectionSpec <span class="title">configureSecureSocket</span><span class="params">(SSLSocket sslSocket)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  ConnectionSpec tlsConfiguration = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = nextModeIndex, size = connectionSpecs.size(); i &lt; size; i++) &#123;</div><div class="line">    ConnectionSpec connectionSpec = connectionSpecs.get(i);</div><div class="line">    <span class="keyword">if</span> (connectionSpec.isCompatible(sslSocket)) &#123;</div><div class="line">      tlsConfiguration = connectionSpec;</div><div class="line">      nextModeIndex = i + <span class="number">1</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (tlsConfiguration == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// This may be the first time a connection has been attempted and the socket does not support</span></div><div class="line">    <span class="comment">// any the required protocols, or it may be a retry (but this socket supports fewer</span></div><div class="line">    <span class="comment">// protocols than was suggested by a prior socket).</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnknownServiceException(</div><div class="line">        <span class="string">"Unable to find acceptable protocols. isFallback="</span> + isFallback</div><div class="line">            + <span class="string">", modes="</span> + connectionSpecs</div><div class="line">            + <span class="string">", supported protocols="</span> + Arrays.toString(sslSocket.getEnabledProtocols()));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  isFallbackPossible = isFallbackPossible(sslSocket);</div><div class="line"></div><div class="line">  Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> tlsConfiguration;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个过程分为如下的两个步骤：</p>
<ol>
<li>从为OkHttp配置的ConnectionSpec集合中选择一个与SSLSocket兼容的一个。SSLSocket与ConnectionSpec兼容的标准如下：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> boolean isCompatible(SSLSocket socket) &#123;</div><div class="line">  <span class="keyword">if</span> (!tls) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (tlsVersions != <span class="literal">null</span></div><div class="line">      &amp;&amp; !nonEmptyIntersection(tlsVersions, socket.getEnabledProtocols())) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (cipherSuites != <span class="literal">null</span></div><div class="line">      &amp;&amp; !nonEmptyIntersection(cipherSuites, socket.getEnabledCipherSuites())) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * An N*M intersection that terminates if any intersection is found. The sizes of both arguments</div><div class="line"> * are assumed to be so small, and the likelihood of an intersection so great, that it is not</div><div class="line"> * worth the CPU cost of sorting or the memory cost of hashing.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> static boolean nonEmptyIntersection(String[] a, String[] b) &#123;</div><div class="line">  <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> || a.length == <span class="number">0</span> || b.length == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (String toFind : a) &#123;</div><div class="line">    <span class="keyword">if</span> (indexOf(b, toFind) != <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>即ConnectionSpec启用的TLS版本及密码套件，与SSLSocket启用的有交集。<br> 2 将选择的ConnectionSpec应用在SSLSocket上。OkHttpClient中ConnectionSpec的应用：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, <span class="keyword">boolean</span> isFallback)</span> </span>&#123;</div><div class="line">  tlsConfiguration.apply(sslSocket, isFallback);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而在ConnectionSpec中：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Applies this spec to &#123;@code sslSocket&#125;. */</span></div><div class="line"><span class="keyword">void</span> apply(SSLSocket sslSocket, <span class="built_in">boolean</span> isFallback) &#123;</div><div class="line">  ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (specToApply.tlsVersions != <span class="keyword">null</span>) &#123;</div><div class="line">    sslSocket.setEnabledProtocols(specToApply.tlsVersions);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (specToApply.cipherSuites != <span class="keyword">null</span>) &#123;</div><div class="line">    sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a copy of this that omits cipher suites and TLS versions not enabled by &#123;@code</div><div class="line"> * sslSocket&#125;.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> ConnectionSpec supportedSpec(SSLSocket sslSocket, <span class="built_in">boolean</span> isFallback) &#123;</div><div class="line">  <span class="keyword">String</span>[] cipherSuitesIntersection = cipherSuites != <span class="keyword">null</span></div><div class="line">      ? intersect(<span class="keyword">String</span>.class, cipherSuites, sslSocket.getEnabledCipherSuites())</div><div class="line">      : sslSocket.getEnabledCipherSuites();</div><div class="line">  <span class="keyword">String</span>[] tlsVersionsIntersection = tlsVersions != <span class="keyword">null</span></div><div class="line">      ? intersect(<span class="keyword">String</span>.class, tlsVersions, sslSocket.getEnabledProtocols())</div><div class="line">      : sslSocket.getEnabledProtocols();</div><div class="line"></div><div class="line">  <span class="comment">// In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00</span></div><div class="line">  <span class="comment">// the SCSV cipher is added to signal that a protocol fallback has taken place.</span></div><div class="line">  <span class="keyword">if</span> (isFallback &amp;&amp; indexOf(sslSocket.getSupportedCipherSuites(), <span class="string">"TLS_FALLBACK_SCSV"</span>) != <span class="number">-1</span>) &#123;</div><div class="line">    cipherSuitesIntersection = <span class="built_in">concat</span>(cipherSuitesIntersection, <span class="string">"TLS_FALLBACK_SCSV"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Builder(<span class="keyword">this</span>)</div><div class="line">      .cipherSuites(cipherSuitesIntersection)</div><div class="line">      .tlsVersions(tlsVersionsIntersection)</div><div class="line">      .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要是：</p>
<ul>
<li>求得ConnectionSpec启用的TLS版本及密码套件与SSLSocket启用的TLS版本及密码套件之间的交集，构造新的ConnectionSpec。</li>
<li>重新为SSLSocket设置启用的TLS版本及密码套件为上一步求得的交集。</li>
</ul>
<p>我们知道HTTP/2的协议协商主要是利用了TLS的ALPN扩展来完成的。这里再来详细的看一下配置TLS扩展的过程。对于Android平台而言，这部分逻辑在AndroidPlatform：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> public <span class="keyword">void</span> configureTlsExtensions(</div><div class="line">    SSLSocket sslSocket, <span class="built_in">String</span> hostname, <span class="built_in">List</span>&lt;Protocol&gt; protocols) &#123;</div><div class="line">  <span class="comment">// Enable SNI and session tickets.</span></div><div class="line">  <span class="keyword">if</span> (hostname != <span class="keyword">null</span>) &#123;</div><div class="line">    setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, <span class="keyword">true</span>);</div><div class="line">    setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Enable ALPN.</span></div><div class="line">  <span class="keyword">if</span> (setAlpnProtocols != <span class="keyword">null</span> &amp;&amp; setAlpnProtocols.isSupported(sslSocket)) &#123;</div><div class="line">    <span class="built_in">Object</span>[] parameters = &#123;concatLengthPrefixed(protocols)&#125;;</div><div class="line">    setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TLS扩展相关的方法不是SSLSocket接口的标准方法，不同的SSL/TLS实现库对这些接口的支持程度不一样，因而这里通过反射机制调用TLS扩展相关的方法。</p>
<p>这里主要配置了3个TLS扩展，分别是session tickets，SNI和ALPN。session tickets用于会话回复，SNI用于支持单个主机配置了多个域名的情况，ALPN则用于HTTP/2的协议协商。可以看到为SNI设置的hostname最终来源于Url，也就意味着使用HttpDns时，如果直接将IP地址替换原来Url中的域名来发起HTTPS请求的话，SNI将是IP地址，这有可能使服务器下发不恰当的证书。</p>
<p>TLS扩展相关方法的OptionalMethod创建过程也在AndroidPlatform中：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">public</span> AndroidPlatform(<span class="keyword">Class</span>&lt;?&gt; sslParametersClass, OptionalMethod&lt;Socket&gt; setUseSessionTickets,</div><div class="line">      OptionalMethod&lt;Socket&gt; setHostname, OptionalMethod&lt;Socket&gt; getAlpnSelectedProtocol,</div><div class="line">      OptionalMethod&lt;Socket&gt; setAlpnProtocols) &#123;</div><div class="line">    <span class="keyword">this</span>.sslParametersClass = sslParametersClass;</div><div class="line">    <span class="keyword">this</span>.setUseSessionTickets = setUseSessionTickets;</div><div class="line">    <span class="keyword">this</span>.setHostname = setHostname;</div><div class="line">    <span class="keyword">this</span>.getAlpnSelectedProtocol = getAlpnSelectedProtocol;</div><div class="line">    <span class="keyword">this</span>.setAlpnProtocols = setAlpnProtocols;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Platform buildIfSupported() &#123;</div><div class="line">    <span class="comment">// Attempt to find Android 2.3+ APIs.</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">Class</span>&lt;?&gt; sslParametersClass;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        sslParametersClass = <span class="keyword">Class</span>.forName(<span class="string">"com.android.org.conscrypt.SSLParametersImpl"</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">        <span class="comment">// Older platform before being unbundled.</span></div><div class="line">        sslParametersClass = <span class="keyword">Class</span>.forName(</div><div class="line">            <span class="string">"org.apache.harmony.xnet.provider.jsse.SSLParametersImpl"</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      OptionalMethod&lt;Socket&gt; setUseSessionTickets = <span class="keyword">new</span> OptionalMethod&lt;&gt;(</div><div class="line">          <span class="keyword">null</span>, <span class="string">"setUseSessionTickets"</span>, <span class="keyword">boolean</span>.<span class="keyword">class</span>);</div><div class="line">      OptionalMethod&lt;Socket&gt; setHostname = <span class="keyword">new</span> OptionalMethod&lt;&gt;(</div><div class="line">          <span class="keyword">null</span>, <span class="string">"setHostname"</span>, String.<span class="keyword">class</span>);</div><div class="line">      OptionalMethod&lt;Socket&gt; getAlpnSelectedProtocol = <span class="keyword">null</span>;</div><div class="line">      OptionalMethod&lt;Socket&gt; setAlpnProtocols = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">      <span class="comment">// Attempt to find Android 5.0+ APIs.</span></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">Class</span>.forName(<span class="string">"android.net.Network"</span>); <span class="comment">// Arbitrary class added in Android 5.0.</span></div><div class="line">        getAlpnSelectedProtocol = <span class="keyword">new</span> OptionalMethod&lt;&gt;(<span class="keyword">byte</span>[].<span class="keyword">class</span>, <span class="string">"getAlpnSelectedProtocol"</span>);</div><div class="line">        setAlpnProtocols = <span class="keyword">new</span> OptionalMethod&lt;&gt;(<span class="keyword">null</span>, <span class="string">"setAlpnProtocols"</span>, <span class="keyword">byte</span>[].<span class="keyword">class</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,</div><div class="line">          getAlpnSelectedProtocol, setAlpnProtocols);</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</div><div class="line">      <span class="comment">// This isn't an Android runtime.</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>建立TLS连接的第7步，获取协议的过程与配置TLS的过程类似，同样利用反射调用SSLSocket的方法，在AndroidPlatform中：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">String <span class="title">getSelectedProtocol</span><span class="params">(SSLSocket socket)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (getAlpnSelectedProtocol == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">if</span> (!getAlpnSelectedProtocol.isSupported(socket)) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">  <span class="keyword">byte</span>[] alpnResult = (<span class="keyword">byte</span>[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);</div><div class="line">  <span class="keyword">return</span> alpnResult != <span class="keyword">null</span> ? <span class="keyword">new</span> String(alpnResult, Util.UTF_8) : <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此我们分析了OkHttp3中，所有HTTP请求，包括设置了代理的明文HTTP请求，设置了代理的HTTPS请求，设置了代理的HTTP/2请求，无代理的明文HTTP请求，无代理的HTTPS请求，无代理的HTTP/2请求的连接建立过程，其中包括TLS的握手，HTTP/2的协议协商等。</p>
<p>总结一下，OkHttp中，IO相关的组件的其关系大体如下图所示：</p>
<p><img src="https://www.wolfcstech.com/images/1315506-338a7a0b0a39a278.png" alt="Connection Component"></p>
<p>Done。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wxpay.png" alt="Han Pengfei WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Han Pengfei Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/网络协议/" rel="tag"># 网络协议</a>
          
            <a href="/tags/Android开发/" rel="tag"># Android开发</a>
          
            <a href="/tags/源码分析/" rel="tag"># 源码分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/10/18/chromium-net-android-porting/" rel="next" title="chromium net到android平台的移植">
                <i class="fa fa-chevron-left"></i> chromium net到android平台的移植
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/10/29/1-zh-cn/" rel="prev" title="HTTP/2规范：1. 简介">
                HTTP/2规范：1. 简介 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/freesoft.jpg"
                alt="Han Pengfei" />
            
              <p class="site-author-name" itemprop="name">Han Pengfei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">163</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hanpfei" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.douban.com/people/3681478/" target="_blank" title="豆瓣"><i class="fa fa-fw fa-globe"></i>豆瓣</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/han-peng-fei-49" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hanpfei@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://source.android.com/" title="Android Open Source Project" target="_blank">Android Open Source Project</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.vants.org/" title="蚂蚁网" target="_blank">蚂蚁网</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OkHttp3的连接池"><span class="nav-number">1.</span> <span class="nav-text">OkHttp3的连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ConnectionPool是什么？"><span class="nav-number">1.1.</span> <span class="nav-text">ConnectionPool是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接池ConnectionPool的创建"><span class="nav-number">1.2.</span> <span class="nav-text">连接池ConnectionPool的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RealConnection的存-取"><span class="nav-number">1.3.</span> <span class="nav-text">RealConnection的存/取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RealConnection的清理"><span class="nav-number">1.4.</span> <span class="nav-text">RealConnection的清理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConnectionPool的用户接口"><span class="nav-number">1.5.</span> <span class="nav-text">ConnectionPool的用户接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#新建流"><span class="nav-number">2.</span> <span class="nav-text">新建流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ConnectionSpec"><span class="nav-number">3.</span> <span class="nav-text">ConnectionSpec</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#建立连接"><span class="nav-number">4.</span> <span class="nav-text">建立连接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#建立隧道连接"><span class="nav-number">4.1.</span> <span class="nav-text">建立隧道连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建立普通连接"><span class="nav-number">4.2.</span> <span class="nav-text">建立普通连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建立协议"><span class="nav-number">4.3.</span> <span class="nav-text">建立协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建立TLS连接"><span class="nav-number">4.4.</span> <span class="nav-text">建立TLS连接</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016.09.16 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Han Pengfei</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname,
            owner: 'hanpfei',
            repo: 'blog_comment',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '2e5e06c86dfee4177d58dd4660d1ed4bce4f155d',
            
                client_id: '0ec580f0a999fbe77a63'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("KUAjB88PxNQR5DOgg6jhgdp7-gzGzoHsz", "3c3yzt2EN31aXwYgVdmzDUUk");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  

  

  

</body>
</html>
