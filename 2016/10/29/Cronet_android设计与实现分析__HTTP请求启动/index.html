<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Cronet android设计与实现分析--HTTP请求启动 | WolfcsTech</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.2.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.2.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Cronet android设计与实现分析--HTTP请求启动</h1><a id="logo" href="/.">WolfcsTech</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Cronet android设计与实现分析--HTTP请求启动</h1><div class="post-meta">Oct 29, 2016<span> | </span><span class="category"><a href="/categories/网络协议/">网络协议</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/10/29/Cronet_android设计与实现分析__HTTP请求启动/" href="/2016/10/29/Cronet_android设计与实现分析__HTTP请求启动/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>在简单地分析了cronet的初始化过程之后，我们来看HTTP请求的提交和执行。</p>
<a id="more"></a>
<h1 id="UrlRequest的创建"><a href="#UrlRequest的创建" class="headerlink" title="UrlRequest的创建"></a>UrlRequest的创建</h1><p>如我们在前面的<a href="https://my.oschina.net/wolfcs/blog/752882" target="_blank" rel="external">Cronet android 设计与实现分析——库的初始化</a>中看到的那样，Cronet的客户端，需要通过UrlRequest.Builder创建Request，然后提交给CronetEngine执行。这里我们从UrlRequest的创建开始我们的分析。</p>
<p>与CronetEngine类似，UrlRequest也需要通过Builder来创建。首先需要创建UrlRequest.Builder对象，url，callback，executor和CronetEngine是该创建过程所必须的：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Builder(</div><div class="line">        String url, Callback <span class="keyword">callback</span>, Executor executor, CronetEngine cronetEngine) &#123;</div><div class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"URL is required."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">callback</span> == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Callback is required."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Executor is required."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (cronetEngine == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"CronetEngine is required."</span>);</div><div class="line">    &#125;</div><div class="line">    mUrl = url;</div><div class="line">    mCallback = <span class="keyword">callback</span>;</div><div class="line">    mExecutor = executor;</div><div class="line">    mCronetEngine = cronetEngine;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为我们前面创建的Builder设置了所有我们希望定制的属性之后，我们通过调用UrlRequest.Builder.build()创建UrlRequest对象：<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">    /**</div><div class="line">     * Creates <span class="keyword">a</span> &#123;@<span class="literal">link</span> UrlRequest&#125; <span class="keyword">using</span> <span class="keyword">configuration</span> <span class="keyword">within</span> <span class="keyword">this</span></div><div class="line">     * &#123;@link Builder&#125;. The <span class="keyword">returned</span> &#123;@code UrlRequest&#125; <span class="keyword">can</span> <span class="keyword">then</span> <span class="keyword">be</span> <span class="keyword">started</span></div><div class="line">     * by <span class="keyword">calling</span> &#123;@<span class="literal">link</span> UrlRequest<span class="comment">#start&#125;.</span></div><div class="line">     *</div><div class="line">     * @return constructed &#123;@<span class="literal">link</span> UrlRequest&#125; <span class="keyword">using</span> <span class="keyword">configuration</span> <span class="keyword">within</span></div><div class="line">     *         <span class="keyword">this</span> &#123;@<span class="literal">link</span> Builder&#125;.</div><div class="line">     */</div><div class="line">    public UrlRequest build() &#123;</div><div class="line">        final UrlRequest request = mCronetEngine.createRequest(mUrl, mCallback, mExecutor,</div><div class="line">                mPriority, mRequestAnnotations, mDisableCache, mDisableConnectionMigration);</div><div class="line">        if (mMethod != null) &#123;</div><div class="line">            request.setHttpMethod(mMethod);</div><div class="line">        &#125;</div><div class="line">        for (Pair&lt;String, String&gt; header : mRequestHeaders) &#123;</div><div class="line">            request.addHeader(header.first, header.second);</div><div class="line">        &#125;</div><div class="line">        if (mUploadDataProvider != null) &#123;</div><div class="line">            request.setUploadDataProvider(mUploadDataProvider, mUploadDataProviderExecutor);</div><div class="line">        &#125;</div><div class="line">        return request;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里用了一种类似于 原型模式 的方法，先由CronetEngine创建一个UrlRequest对象；然后将Builder中为UrlRequest定制的一些选项，如Http method，request的header等，设置给UrlRequest；最后将UrlRequest对象返回。</p>
<p>我们追一下org.chromium.net.impl.CronetUrlRequestContext的createRequest()来看看实际的UrlRequest创建过程是什么：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function">UrlRequest <span class="title">createRequest</span><span class="params">(String url, UrlRequest.Callback callback, Executor executor,</span></span></div><div class="line">            <span class="keyword">int</span> priority, Collection&lt;Object&gt; requestAnnotations, <span class="keyword">boolean</span> disableCache,</div><div class="line">            <span class="keyword">boolean</span> disableConnectionMigration) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</div><div class="line">            checkHaveAdapter();</div><div class="line">            <span class="keyword">boolean</span> metricsCollectionEnabled = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">synchronized</span> (mFinishedListenerLock) &#123;</div><div class="line">                metricsCollectionEnabled = !mFinishedListenerList.isEmpty();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CronetUrlRequest(<span class="keyword">this</span>, url, priority, callback, executor, requestAnnotations,</div><div class="line">                    metricsCollectionEnabled, disableCache, disableConnectionMigration);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">checkHaveAdapter</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!haveRequestContextAdapter()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Engine is shut down."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">haveRequestContextAdapter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mUrlRequestContextAdapter != <span class="number">0</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Chromium net提供了强大的debug的能力，可以帮我们抓到许多网络请求执行过程中的信息。但要抓取这些信息，总是要更耗费资源一些。这里会检查是否存在FinishedListener，只有当FinishedListener存在时，抓取的信息才是有意义的，因而，在FinishedListener不存在时，这里会关闭对信息的抓取。</p>
<p>随后，这个方法创建CronetUrlRequest对象，也就是实际的UrlRequest类型，而它的构造过程如下：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">CronetUrlRequest(CronetUrlRequestContext requestContext, String url, int priority,</div><div class="line">        UrlRequest.Callback callback, Executor executor, Collection&lt;Object&gt; requestAnnotations,</div><div class="line">        boolean metricsCollectionEnabled, boolean disableCache,</div><div class="line">        boolean disableConnectionMigration) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="attr">url</span> == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="built_in">throw</span> new NullPointerException(<span class="string">"URL is required"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="attr">callback</span> == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="built_in">throw</span> new NullPointerException(<span class="string">"Listener is required"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="attr">executor</span> == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="built_in">throw</span> new NullPointerException(<span class="string">"Executor is required"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="attr">requestAnnotations</span> == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="built_in">throw</span> new NullPointerException(<span class="string">"requestAnnotations is required"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="attr">mRequestContext</span> = requestContext;</div><div class="line">    <span class="attr">mInitialUrl</span> = url;</div><div class="line">    mUrlChain.add(url);</div><div class="line">    <span class="attr">mPriority</span> = convertRequestPriority(priority);</div><div class="line">    <span class="attr">mCallback</span> = callback;</div><div class="line">    <span class="attr">mExecutor</span> = executor;</div><div class="line">    <span class="attr">mRequestAnnotations</span> = requestAnnotations;</div><div class="line">    <span class="attr">mRequestMetricsAccumulator</span> =</div><div class="line">            metricsCollectionEnabled ? new UrlRequestMetricsAccumulator() : <span class="literal">null</span>;</div><div class="line">    <span class="attr">mDisableCache</span> = disableCache;</div><div class="line">    <span class="attr">mDisableConnectionMigration</span> = disableConnectionMigration;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要就是根据传入的参数，设置了一些字段的值。</p>
<h1 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h1><p>我们创建UrlRequest的时候，总是要传入一个Executor。在CronetUrlRequest中，只有postTaskToExecutor()一个方法访问了Executor：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Posts task to application Executor. Used for Listener callbacks</div><div class="line"> * and other tasks that should not be executed on network thread.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> postTaskToExecutor(Runnable <span class="keyword">task</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        mExecutor.execute(<span class="keyword">task</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException failException) &#123;</div><div class="line">        Log.e(CronetUrlRequestContext.LOG_TAG, <span class="string">"Exception posting task to executor"</span>,</div><div class="line">                failException);</div><div class="line">        <span class="comment">// If posting a task throws an exception, then there is no choice</span></div><div class="line">        <span class="comment">// but to destroy the request without invoking the callback.</span></div><div class="line">        destroyRequestAdapter(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而CronetUrlRequest中有访问到postTaskToExecutor()的方法则有如下这些：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CronetUrlRequest</div><div class="line">    failWithException(UrlRequestException)</div><div class="line">    getStatus(StatusListener)</div><div class="line">    onCanceled()</div><div class="line">    onReadCompleted(ByteBuffer, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">long</span>)</div><div class="line">    onRedirectReceived(<span class="keyword">String</span>, <span class="keyword">int</span>, <span class="keyword">String</span>, <span class="keyword">String</span>[], <span class="keyword">boolean</span>, <span class="keyword">String</span>, <span class="keyword">String</span>, <span class="keyword">long</span>)</div><div class="line">    onResponseStarted(<span class="keyword">int</span>, <span class="keyword">String</span>, <span class="keyword">String</span>[], <span class="keyword">boolean</span>, <span class="keyword">String</span>, <span class="keyword">String</span>)</div><div class="line">    onStatus(StatusListener, <span class="keyword">int</span>)</div><div class="line">    onSucceeded(<span class="keyword">long</span>)</div></pre></td></tr></table></figure></p>
<p>如在onSucceeded()和onCanceled()中：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Called when request is completed successfully, no callbacks will be</div><div class="line"> * called afterwards.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> receivedBytesCount number of bytes received.</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line"><span class="meta">@CalledByNative</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">onSucceeded</span><span class="params">(<span class="keyword">long</span> receivedBytesCount)</span> </span>&#123;</div><div class="line">    mResponseInfo.setReceivedBytesCount(mReceivedBytesCountFromRedirects + receivedBytesCount);</div><div class="line">    Runnable task = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (mUrlRequestAdapterLock) &#123;</div><div class="line">                <span class="keyword">if</span> (isDoneLocked()) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// Destroy adapter first, so request context could be shut</span></div><div class="line">                <span class="comment">// down from the listener.</span></div><div class="line">                destroyRequestAdapter(<span class="keyword">false</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                mCallback.onSucceeded(CronetUrlRequest.<span class="keyword">this</span>, mResponseInfo);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                Log.e(CronetUrlRequestContext.LOG_TAG, <span class="string">"Exception in onComplete method"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    postTaskToExecutor(task);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Called when request is canceled, no callbacks will be called afterwards.</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line"><span class="meta">@CalledByNative</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">onCanceled</span><span class="params">()</span> </span>&#123;</div><div class="line">    Runnable task = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                mCallback.onCanceled(CronetUrlRequest.<span class="keyword">this</span>, mResponseInfo);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                Log.e(CronetUrlRequestContext.LOG_TAG, <span class="string">"Exception in onCanceled method"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    postTaskToExecutor(task);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见，网络请求被丢给chromium之后，在发生某个事件时，native层会通过JNI机制反call java层的CronetUrlRequest的回调函数，在CronetUrlRequest的回调函数中则向Executor中抛出Task，通过客户端传入的UrlRequest.Callback，在Executor的线程中将事件抛给客户端。</p>
<p>可见传给UrlRequest的Executor主要是用于做事件通知的。</p>
<h1 id="Chromium-net-URLRequest的创建"><a href="#Chromium-net-URLRequest的创建" class="headerlink" title="Chromium net URLRequest的创建"></a>Chromium net URLRequest的创建</h1><p>语义上而言，客户端通过调用UrlRequest的start()方法启动HTTP请求的执行。CronetUrlRequest的start()方法的实现如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (mUrlRequestAdapterLock) &#123;</div><div class="line">            checkNotStarted();</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                mUrlRequestAdapter =</div><div class="line">                        nativeCreateRequestAdapter(mRequestContext.getUrlRequestContextAdapter(),</div><div class="line">                                mInitialUrl, mPriority, mDisableCache, mDisableConnectionMigration);</div><div class="line">                mRequestContext.onRequestStarted();</div><div class="line">                <span class="keyword">if</span> (mInitialMethod != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (!nativeSetHttpMethod(mUrlRequestAdapter, mInitialMethod)) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid http method "</span> + mInitialMethod);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">boolean</span> hasContentType = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; header : mRequestHeaders) &#123;</div><div class="line">                    <span class="keyword">if</span> (header.getKey().equalsIgnoreCase(<span class="string">"Content-Type"</span>)</div><div class="line">                            &amp;&amp; !header.getValue().isEmpty()) &#123;</div><div class="line">                        hasContentType = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!nativeAddRequestHeader(</div><div class="line">                                mUrlRequestAdapter, header.getKey(), header.getValue())) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                                <span class="string">"Invalid header "</span> + header.getKey() + <span class="string">"="</span> + header.getValue());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (mUploadDataStream != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (!hasContentType) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                                <span class="string">"Requests with upload data must have a Content-Type."</span>);</div><div class="line">                    &#125;</div><div class="line">                    mStarted = <span class="keyword">true</span>;</div><div class="line">                    mUploadDataStream.postTaskToExecutor(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            mUploadDataStream.initializeWithRequest(CronetUrlRequest.<span class="keyword">this</span>);</div><div class="line">                            <span class="keyword">synchronized</span> (mUrlRequestAdapterLock) &#123;</div><div class="line">                                <span class="keyword">if</span> (isDoneLocked()) &#123;</div><div class="line">                                    <span class="keyword">return</span>;</div><div class="line">                                &#125;</div><div class="line">                                mUploadDataStream.attachNativeAdapterToRequest(mUrlRequestAdapter);</div><div class="line">                                startInternalLocked();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">                <span class="comment">// If there's an exception, cleanup and then throw the</span></div><div class="line">                <span class="comment">// exception to the caller.</span></div><div class="line">                destroyRequestAdapter(<span class="keyword">false</span>);</div><div class="line">                <span class="keyword">throw</span> e;</div><div class="line">            &#125;</div><div class="line">            mStarted = <span class="keyword">true</span>;</div><div class="line">            startInternalLocked();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Starts fully configured request. Could execute on UploadDataProvider executor.</div><div class="line">     * Caller is expected to ensure that request isn't canceled and mUrlRequestAdapter is valid.</div><div class="line">     */</div><div class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"mUrlRequestAdapterLock"</span>)</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">startInternalLocked</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mRequestMetricsAccumulator != <span class="keyword">null</span>) &#123;</div><div class="line">            mRequestMetricsAccumulator.onRequestStarted();</div><div class="line">        &#125;</div><div class="line">        nativeStart(mUrlRequestAdapter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">checkNotStarted</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (mUrlRequestAdapterLock) &#123;</div><div class="line">            <span class="keyword">if</span> (mStarted || isDoneLocked()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Request is already started."</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在这个方法中会做如下这些事情：</p>
<ol>
<li>检查这个Request是否已经被启动了，若已经被启动了的话，会抛出异常。</li>
<li>调用nativeCreateRequestAdapter()创建native层的UrlRequestAdapter。Cronet的大部分逻辑都在native层，因而需要通过UrlRequestAdapter来将Java层和native联系起来。UrlRequestAdapter将Java层的UrlRequest与native层的URLRequest对应起来。</li>
<li>回调RequestContext的onRequestStarted()。</li>
<li>调用nativeSetHttpMethod()来设置HTTP method。</li>
<li>调用nativeAddRequestHeader()来将HTTP header一个个传到native层。</li>
<li>设置mStarted标志，以表明Request已经被启动了。</li>
<li>调用startInternalLocked()，来启动Request。这个方法会调用nativeStart()来启动Request。</li>
</ol>
<p>不难看出Java层的CronetUrlRequest只是native的Url Request的一个简单的包装。UrlRequestAdapter连接Java层的CronetUrlRequest和native层中实际表示Url Request的结构，就像CronetURLRequestContextAdapter将Java层的CronetEngine和native层chromium net的URLRequestContext连接起来一样。</p>
<p>UrlRequestAdapter和native层中实际表示Url Request的结构，没有在CronetUrlRequest创建的时候创建，而是在用户实际要启动请求的时候才开始创建。</p>
<p>nativeCreateRequestAdapter()的实现在chromium_android/src/out/Default/gen/components/cronet/android/cronet_jni_headers/cronet/jni/CronetUrlRequest_jni.h中，由构建系统自动产生。它将职责完全委托给CreateRequestAdapter()方法：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> jlong CreateRequestAdapter(JNIEnv* env,</div><div class="line">                                  <span class="keyword">const</span> JavaParamRef&lt;jobject&gt;&amp; jcaller,</div><div class="line">                                  jlong jurl_request_context_adapter,</div><div class="line">                                  <span class="keyword">const</span> JavaParamRef&lt;jstring&gt;&amp; jurl,</div><div class="line">                                  jint jrequest_priority) &#123;</div><div class="line">  URLRequestContextAdapter* context_adapter =</div><div class="line">      <span class="keyword">reinterpret_cast</span>&lt;URLRequestContextAdapter*&gt;(jurl_request_context_adapter);</div><div class="line">  DCHECK(context_adapter);</div><div class="line"></div><div class="line">  GURL url(ConvertJavaStringToUTF8(env, jurl));</div><div class="line"></div><div class="line">  VLOG(<span class="number">1</span>) &lt;&lt; <span class="string">"New chromium network request: "</span> &lt;&lt; url.possibly_invalid_spec();</div><div class="line"></div><div class="line">  URLRequestAdapter* adapter = <span class="keyword">new</span> URLRequestAdapter(</div><div class="line">      context_adapter, <span class="keyword">new</span> JniURLRequestAdapterDelegate(env, jcaller), url,</div><div class="line">      ConvertRequestPriority(jrequest_priority));</div><div class="line"></div><div class="line">  <span class="built_in">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(adapter);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里主要是创建了一个URLRequestAdapter对象，并将对象的地址返回给Java层保存，像CronetURLRequestContextAdapter的创建那样。</p>
<p>语义上而言，nativeStart()被CronetUrlRequest用于启动请求的执行，其定义同样在chromium_android/src/out/Default/gen/components/cronet/android/cronet_jni_headers/cronet/jni/CronetUrlRequest_jni中。它将职责委托给CronetURLRequestAdapter的Start()方法：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void CronetURLRequestAdapter::Start(JNIEnv* env,</div><div class="line">                                    <span class="keyword">const</span> JavaParamRef&lt;jobject&gt;&amp; jcaller) &#123;</div><div class="line">  DCHECK(!context_-&gt;IsOnNetworkThread());</div><div class="line">  context_-&gt;PostTaskToNetworkThread(</div><div class="line">      FROM_HERE, base::Bind(&amp;CronetURLRequestAdapter::StartOnNetworkThread,</div><div class="line">                            base::Unretained(this)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数向CronetURLRequestContextAdapter的network thread抛了一个task，也就是CronetURLRequestAdapter::StartOnNetworkThread：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void CronetURLRequestAdapter::StartOnNetworkThread() &#123;</div><div class="line">  DCHECK(context_-&gt;IsOnNetworkThread());</div><div class="line">  VLOG(<span class="number">1</span>) &lt;&lt; <span class="string">"Starting chromium request: "</span></div><div class="line">          &lt;&lt; initial_url_.possibly_invalid_spec().c_str()</div><div class="line">          &lt;&lt; <span class="string">" priority: "</span> &lt;&lt; RequestPriorityToString(initial_priority_);</div><div class="line">  url_request_ = context_-&gt;GetURLRequestContext()-&gt;CreateRequest(</div><div class="line">      initial_url_, net::DEFAULT_PRIORITY, this);</div><div class="line">  url_request_-&gt;SetLoadFlags(load_flags_);</div><div class="line">  url_request_-&gt;set_method(initial_method_);</div><div class="line">  url_request_-&gt;SetExtraRequestHeaders(initial_request_headers_);</div><div class="line">  url_request_-&gt;SetPriority(initial_priority_);</div><div class="line">  <span class="keyword">if</span> (upload_)</div><div class="line">    url_request_-&gt;set_upload(std::<span class="keyword">move</span>(upload_));</div><div class="line">  url_request_-&gt;Start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里才会真正的通过URLRequestContext的CreateRequest()创建chromium net的URLRequest。</p>
<p>可见我们调用Java层的CornetUrlRequest的start()及其内部调用的nativeStart()，只是Url Request相关结构的创建过程的延续而已，Url Request相关结构主要是指用于连接Java层的CronetUrlRequest和chromium net的URLRequest的CronetURLRequestAdapter和chromium net的URLRequest。chromium net的URLRequest的创建及启动，都是在CronetURLRequestAdapter::Start()，也就是Java层的CornetUrlRequest的nativeStart()方法的最后，抛向另外的一个线程中的task中完成的。</p>
<p>继续来看URLRequestContext的CreateRequest()创建URLRequest的过程，这个过程倒是蛮直接的(chromium_android/src/net/url_request/url_request_context.cc)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;URLRequest&gt; URLRequestContext::CreateRequest(</div><div class="line">    <span class="keyword">const</span> GURL&amp; url,</div><div class="line">    RequestPriority priority,</div><div class="line">    URLRequest::Delegate* delegate) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> base::WrapUnique(</div><div class="line">      <span class="keyword">new</span> URLRequest(url, priority, delegate, <span class="keyword">this</span>, network_delegate_));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里创建chromium net的URLRequest时，传入的URLRequest::Delegate是CronetURLRequestAdapter::StartOnNetworkThread传进来的，也就是CronetURLRequestAdapter对象本身，而NetworkDelegate则是来自于URLRequestContext的network<em>delegate</em>。可见，CronetURLRequestAdapter不仅用于Java层向chromium net的URLRequest传递信息，也会被chromium net的URLRequest用于向Java层通知事件。</p>
<p>net::URLRequest::Delegate的定义如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">NET_EXPORT</span> <span class="title">Delegate</span> &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Called upon receiving a redirect.  The delegate may call the request's</span></div><div class="line">  <span class="comment">// Cancel method to prevent the redirect from being followed.  Since there</span></div><div class="line">  <span class="comment">// may be multiple chained redirects, there may also be more than one</span></div><div class="line">  <span class="comment">// redirect call.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// When this function is called, the request will still contain the</span></div><div class="line">  <span class="comment">// original URL, the destination of the redirect is provided in</span></div><div class="line">  <span class="comment">// |redirect_info.new_url|.  If the delegate does not cancel the request</span></div><div class="line">  <span class="comment">// and |*defer_redirect| is false, then the redirect will be followed, and</span></div><div class="line">  <span class="comment">// the request's URL will be changed to the new URL.  Otherwise if the</span></div><div class="line">  <span class="comment">// delegate does not cancel the request and |*defer_redirect| is true, then</span></div><div class="line">  <span class="comment">// the redirect will be followed once FollowDeferredRedirect is called</span></div><div class="line">  <span class="comment">// on the URLRequest.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// The caller must set |*defer_redirect| to false, so that delegates do not</span></div><div class="line">  <span class="comment">// need to set it if they are happy with the default behavior of not</span></div><div class="line">  <span class="comment">// deferring redirect.</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnReceivedRedirect</span>(<span class="params">URLRequest* request,</span></span></div><div class="line">                                  <span class="keyword">const</span> RedirectInfo&amp; redirect_info,</div><div class="line">                                  <span class="keyword">bool</span>* defer_redirect);</div><div class="line"></div><div class="line">  <span class="comment">// Called when we receive an authentication failure.  The delegate should</span></div><div class="line">  <span class="comment">// call request-&gt;SetAuth() with the user's credentials once it obtains them,</span></div><div class="line">  <span class="comment">// or request-&gt;CancelAuth() to cancel the login and display the error page.</span></div><div class="line">  <span class="comment">// When it does so, the request will be reissued, restarting the sequence</span></div><div class="line">  <span class="comment">// of On* callbacks.</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnAuthRequired</span>(<span class="params">URLRequest* request,</span></span></div><div class="line">                              AuthChallengeInfo* auth_info);</div><div class="line"></div><div class="line">  <span class="comment">// Called when we receive an SSL CertificateRequest message for client</span></div><div class="line">  <span class="comment">// authentication.  The delegate should call</span></div><div class="line">  <span class="comment">// request-&gt;ContinueWithCertificate() with the client certificate the user</span></div><div class="line">  <span class="comment">// selected and its private key, or request-&gt;ContinueWithCertificate(NULL,</span></div><div class="line">  <span class="comment">// NULL)</span></div><div class="line">  <span class="comment">// to continue the SSL handshake without a client certificate.</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCertificateRequested</span>(<span class="params"></span></span></div><div class="line">      URLRequest* request,</div><div class="line">      SSLCertRequestInfo* cert_request_info);</div><div class="line"></div><div class="line">  <span class="comment">// Called when using SSL and the server responds with a certificate with</span></div><div class="line">  <span class="comment">// an error, for example, whose common name does not match the common name</span></div><div class="line">  <span class="comment">// we were expecting for that host.  The delegate should either do the</span></div><div class="line">  <span class="comment">// safe thing and Cancel() the request or decide to proceed by calling</span></div><div class="line">  <span class="comment">// ContinueDespiteLastError().  cert_error is a ERR_* error code</span></div><div class="line">  <span class="comment">// indicating what's wrong with the certificate.</span></div><div class="line">  <span class="comment">// If |fatal| is true then the host in question demands a higher level</span></div><div class="line">  <span class="comment">// of security (due e.g. to HTTP Strict Transport Security, user</span></div><div class="line">  <span class="comment">// preference, or built-in policy). In this case, errors must not be</span></div><div class="line">  <span class="comment">// bypassable by the user.</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnSSLCertificateError</span>(<span class="params">URLRequest* request,</span></span></div><div class="line">                                     <span class="keyword">const</span> SSLInfo&amp; ssl_info,</div><div class="line">                                     <span class="keyword">bool</span> fatal);</div><div class="line"></div><div class="line">  <span class="comment">// After calling Start(), the delegate will receive an OnResponseStarted</span></div><div class="line">  <span class="comment">// callback when the request has completed.  If an error occurred, the</span></div><div class="line">  <span class="comment">// request-&gt;status() will be set.  On success, all redirects have been</span></div><div class="line">  <span class="comment">// followed and the final response is beginning to arrive.  At this point,</span></div><div class="line">  <span class="comment">// meta data about the response is available, including for example HTTP</span></div><div class="line">  <span class="comment">// response headers if this is a request for a HTTP resource.</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnResponseStarted</span>(<span class="params">URLRequest* request</span>) </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Called when the a Read of the response body is completed after an</span></div><div class="line">  <span class="comment">// IO_PENDING status from a Read() call.</span></div><div class="line">  <span class="comment">// The data read is filled into the buffer which the caller passed</span></div><div class="line">  <span class="comment">// to Read() previously.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// If an error occurred, request-&gt;status() will contain the error,</span></div><div class="line">  <span class="comment">// and bytes read will be -1.</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnReadCompleted</span>(<span class="params">URLRequest* request, <span class="keyword">int</span> bytes_read</span>) </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Delegate() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>而CronetURLRequestAdapter对这些回调函数的实现则为：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CronetURLRequestAdapter::OnReceivedRedirect(</div><div class="line">    net::URLRequest* request,</div><div class="line">    <span class="keyword">const</span> net::RedirectInfo&amp; redirect_info,</div><div class="line">    bool* defer_redirect) &#123;</div><div class="line">  DCHECK(context_-&gt;IsOnNetworkThread());</div><div class="line">  DCHECK(request-&gt;status().is_success());</div><div class="line">  JNIEnv* env = base::android::AttachCurrentThread();</div><div class="line">  cronet::Java_CronetUrlRequest_onRedirectReceived(</div><div class="line">      env, owner_.obj(),</div><div class="line">      ConvertUTF8ToJavaString(env, redirect_info.new_url.spec()).obj(),</div><div class="line">      redirect_info.status_code,</div><div class="line">      ConvertUTF8ToJavaString(env, request-&gt;response_headers()-&gt;GetStatusText())</div><div class="line">          .obj(),</div><div class="line">      GetResponseHeaders(env).obj(),</div><div class="line">      request-&gt;response_info().was_cached ? JNI_TRUE : JNI_FALSE,</div><div class="line">      ConvertUTF8ToJavaString(env,</div><div class="line">                              request-&gt;response_info().npn_negotiated_protocol)</div><div class="line">          .obj(),</div><div class="line">      ConvertUTF8ToJavaString(env,</div><div class="line">                              request-&gt;response_info().proxy_server.ToString())</div><div class="line">          .obj(),</div><div class="line">      request-&gt;GetTotalReceivedBytes());</div><div class="line">  *defer_redirect = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> CronetURLRequestAdapter::OnCertificateRequested(</div><div class="line">    net::URLRequest* request,</div><div class="line">    net::SSLCertRequestInfo* cert_request_info) &#123;</div><div class="line">  DCHECK(context_-&gt;IsOnNetworkThread());</div><div class="line">  <span class="comment">// Cronet does not support client certificates.</span></div><div class="line">  request-&gt;ContinueWithCertificate(nullptr, nullptr);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> CronetURLRequestAdapter::OnSSLCertificateError(</div><div class="line">    net::URLRequest* request,</div><div class="line">    <span class="keyword">const</span> net::SSLInfo&amp; ssl_info,</div><div class="line">    bool fatal) &#123;</div><div class="line">  DCHECK(context_-&gt;IsOnNetworkThread());</div><div class="line">  request-&gt;Cancel();</div><div class="line">  <span class="keyword">int</span> net_error = net::MapCertStatusToNetError(ssl_info.cert_status);</div><div class="line">  JNIEnv* env = base::android::AttachCurrentThread();</div><div class="line">  cronet::Java_CronetUrlRequest_onError(</div><div class="line">      env, owner_.obj(), NetErrorToUrlRequestError(net_error), net_error,</div><div class="line">      net::QUIC_NO_ERROR,</div><div class="line">      ConvertUTF8ToJavaString(env, net::ErrorToString(net_error)).obj(),</div><div class="line">      request-&gt;GetTotalReceivedBytes());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> CronetURLRequestAdapter::OnResponseStarted(net::URLRequest* request) &#123;</div><div class="line">  DCHECK(context_-&gt;IsOnNetworkThread());</div><div class="line">  <span class="keyword">if</span> (MaybeReportError(request))</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  JNIEnv* env = base::android::AttachCurrentThread();</div><div class="line">  cronet::Java_CronetUrlRequest_onResponseStarted(</div><div class="line">      env, owner_.obj(), request-&gt;GetResponseCode(),</div><div class="line">      ConvertUTF8ToJavaString(env, request-&gt;response_headers()-&gt;GetStatusText())</div><div class="line">          .obj(),</div><div class="line">      GetResponseHeaders(env).obj(),</div><div class="line">      request-&gt;response_info().was_cached ? JNI_TRUE : JNI_FALSE,</div><div class="line">      ConvertUTF8ToJavaString(env,</div><div class="line">                              request-&gt;response_info().npn_negotiated_protocol)</div><div class="line">          .obj(),</div><div class="line">      ConvertUTF8ToJavaString(env,</div><div class="line">                              request-&gt;response_info().proxy_server.ToString())</div><div class="line">          .obj());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> CronetURLRequestAdapter::OnReadCompleted(net::URLRequest* request,</div><div class="line">                                              <span class="keyword">int</span> bytes_read) &#123;</div><div class="line">  DCHECK(context_-&gt;IsOnNetworkThread());</div><div class="line">  <span class="keyword">if</span> (MaybeReportError(request))</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  <span class="keyword">if</span> (bytes_read != <span class="number">0</span>) &#123;</div><div class="line">    JNIEnv* env = base::android::AttachCurrentThread();</div><div class="line">    cronet::Java_CronetUrlRequest_onReadCompleted(</div><div class="line">        env, owner_.obj(), read_buffer_-&gt;byte_buffer(), bytes_read,</div><div class="line">        read_buffer_-&gt;initial_position(), read_buffer_-&gt;initial_limit(),</div><div class="line">        request-&gt;GetTotalReceivedBytes());</div><div class="line">    <span class="comment">// Free the read buffer. This lets the Java ByteBuffer be freed, if the</span></div><div class="line">    <span class="comment">// embedder releases it, too.</span></div><div class="line">    read_buffer_ = nullptr;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    JNIEnv* env = base::android::AttachCurrentThread();</div><div class="line">    cronet::Java_CronetUrlRequest_onSucceeded(</div><div class="line">        env, owner_.obj(), url_request_-&gt;GetTotalReceivedBytes());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些函数都通过JNI机制反call到Java层的回调。</p>
<p>CronetURLRequestAdapter::StartOnNetworkThread中创建了chromium net的URLRequest之后会为它设置HTTP请求的各种参数。在CronetUrlRequest.start()中，通过nativeSetHttpMethod()、nativeAddRequestHeader()等方法向native层设置的Http method和Http headers等参数都是暂存在CronetURLRequestAdapter中的，而这里会将那些参数真正的设置给chromium net的URLRequest。</p>
<h1 id="HTTP请求执行"><a href="#HTTP请求执行" class="headerlink" title="HTTP请求执行"></a>HTTP请求执行</h1><p>创建了Chromium net的URLRequest之后，就是请求的执行了。这通过URLRequest::Start()来完成：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> URLRequest::Start() &#123;</div><div class="line">  DCHECK(delegate_);</div><div class="line"></div><div class="line">  <span class="comment">// TODO(pkasting): Remove ScopedTracker below once crbug.com/456327 is fixed.</span></div><div class="line">  tracked_objects::ScopedTracker tracking_profile(</div><div class="line">      FROM_HERE_WITH_EXPLICIT_FUNCTION(<span class="string">"456327 URLRequest::Start"</span>));</div><div class="line"></div><div class="line">  <span class="comment">// Some values can be NULL, but the job factory must not be.</span></div><div class="line">  DCHECK(context_-&gt;job_factory());</div><div class="line"></div><div class="line">  <span class="comment">// Anything that sets |blocked_by_| before start should have cleaned up after</span></div><div class="line">  <span class="comment">// itself.</span></div><div class="line">  DCHECK(blocked_by_.empty());</div><div class="line"></div><div class="line">  g_url_requests_started = <span class="keyword">true</span>;</div><div class="line">  response_info_.request_time = base::Time::Now();</div><div class="line"></div><div class="line">  load_timing_info_ = LoadTimingInfo();</div><div class="line">  load_timing_info_.request_start_time = response_info_.request_time;</div><div class="line">  load_timing_info_.request_start = base::TimeTicks::Now();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (network_delegate_) &#123;</div><div class="line">    <span class="comment">// TODO(mmenke): Remove ScopedTracker below once crbug.com/456327 is fixed.</span></div><div class="line">    tracked_objects::ScopedTracker tracking_profile25(</div><div class="line">        FROM_HERE_WITH_EXPLICIT_FUNCTION(<span class="string">"456327 URLRequest::Start 2.5"</span>));</div><div class="line"></div><div class="line">    OnCallToDelegate();</div><div class="line">    <span class="keyword">int</span> <span class="keyword">error</span> = network_delegate_-&gt;NotifyBeforeURLRequest(</div><div class="line">        <span class="keyword">this</span>, before_request_callback_, &amp;delegate_redirect_url_);</div><div class="line">    <span class="comment">// If ERR_IO_PENDING is returned, the delegate will invoke</span></div><div class="line">    <span class="comment">// |before_request_callback_| later.</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">error</span> != ERR_IO_PENDING)</div><div class="line">      BeforeRequestComplete(<span class="keyword">error</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// TODO(mmenke): Remove ScopedTracker below once crbug.com/456327 is fixed.</span></div><div class="line">  tracked_objects::ScopedTracker tracking_profile2(</div><div class="line">      FROM_HERE_WITH_EXPLICIT_FUNCTION(<span class="string">"456327 URLRequest::Start 2"</span>));</div><div class="line"></div><div class="line">  StartJob(URLRequestJobManager::GetInstance()-&gt;CreateJob(</div><div class="line">      <span class="keyword">this</span>, network_delegate_));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></div><div class="line"></div><div class="line">URLRequest::URLRequest(<span class="keyword">const</span> GURL&amp; url,</div><div class="line">                       RequestPriority priority,</div><div class="line">                       Delegate* delegate,</div><div class="line">                       <span class="keyword">const</span> URLRequestContext* context,</div><div class="line">                       NetworkDelegate* network_delegate)</div><div class="line">    : context_(context),</div><div class="line">      network_delegate_(network_delegate ? network_delegate</div><div class="line">                                         : context-&gt;network_delegate()),</div><div class="line">      net_log_(</div><div class="line">          BoundNetLog::Make(context-&gt;net_log(), NetLog::SOURCE_URL_REQUEST)),</div><div class="line">      url_chain_(1, url),</div><div class="line">      method_(<span class="string">"GET"</span>),</div><div class="line">      referrer_policy_(CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE),</div><div class="line">      first_party_url_policy_(NEVER_CHANGE_FIRST_PARTY_URL),</div><div class="line">      load_flags_(LOAD_NORMAL),</div><div class="line">      delegate_(delegate),</div><div class="line">      is_pending_(<span class="keyword">false</span>),</div><div class="line">      is_redirecting_(<span class="keyword">false</span>),</div><div class="line">      redirect_limit_(kMaxRedirects),</div><div class="line">      priority_(priority),</div><div class="line">      identifier_(GenerateURLRequestIdentifier()),</div><div class="line">      calling_delegate_(<span class="keyword">false</span>),</div><div class="line">      use_blocked_by_as_load_param_(<span class="keyword">false</span>),</div><div class="line">      before_request_callback_(base::Bind(&amp;URLRequest::BeforeRequestComplete,</div><div class="line">                                          base::Unretained(<span class="keyword">this</span>))),</div><div class="line">      has_notified_completion_(<span class="keyword">false</span>),</div><div class="line">      received_response_content_length_(0),</div><div class="line">      creation_time_(base::TimeTicks::Now()) &#123;</div><div class="line">  <span class="comment">// Sanity check out environment.</span></div><div class="line">  DCHECK(base::MessageLoop::current())</div><div class="line">      &lt;&lt; <span class="string">"The current base::MessageLoop must exist"</span>;</div><div class="line"></div><div class="line">  context-&gt;url_requests()-&gt;insert(<span class="keyword">this</span>);</div><div class="line">  net_log_.BeginEvent(NetLog::TYPE_REQUEST_ALIVE);</div><div class="line">&#125;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line"><span class="keyword">void</span> URLRequest::StartJob(URLRequestJob* job) &#123;</div><div class="line">  <span class="comment">// TODO(mmenke): Remove ScopedTracker below once crbug.com/456327 is fixed.</span></div><div class="line">  tracked_objects::ScopedTracker tracking_profile(</div><div class="line">      FROM_HERE_WITH_EXPLICIT_FUNCTION(<span class="string">"456327 URLRequest::StartJob"</span>));</div><div class="line"></div><div class="line">  DCHECK(!is_pending_);</div><div class="line">  DCHECK(!job_.get());</div><div class="line"></div><div class="line">  net_log_.BeginEvent(</div><div class="line">      NetLog::TYPE_URL_REQUEST_START_JOB,</div><div class="line">      base::Bind(&amp;NetLogURLRequestStartCallback,</div><div class="line">                 &amp;url(), &amp;method_, load_flags_, priority_,</div><div class="line">                 upload_data_stream_ ? upload_data_stream_-&gt;identifier() : -1));</div><div class="line"></div><div class="line">  job_.reset(job);</div><div class="line">  job_-&gt;SetExtraRequestHeaders(extra_request_headers_);</div><div class="line">  job_-&gt;SetPriority(priority_);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (upload_data_stream_.get())</div><div class="line">    job_-&gt;SetUpload(upload_data_stream_.get());</div><div class="line"></div><div class="line">  is_pending_ = <span class="keyword">true</span>;</div><div class="line">  is_redirecting_ = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  response_info_.was_cached = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (GURL(referrer_) != URLRequestJob::ComputeReferrerForRedirect(</div><div class="line">                             referrer_policy_, referrer_, url())) &#123;</div><div class="line">    <span class="keyword">if</span> (!network_delegate_ ||</div><div class="line">        !network_delegate_-&gt;CancelURLRequestWithPolicyViolatingReferrerHeader(</div><div class="line">            *<span class="keyword">this</span>, url(), GURL(referrer_))) &#123;</div><div class="line">      referrer_.clear();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// We need to clear the referrer anyway to avoid an infinite recursion</span></div><div class="line">      <span class="comment">// when starting the error job.</span></div><div class="line">      referrer_.clear();</div><div class="line">      std::string source(<span class="string">"delegate"</span>);</div><div class="line">      net_log_.AddEvent(NetLog::TYPE_CANCELLED,</div><div class="line">                        NetLog::StringCallback(<span class="string">"source"</span>, &amp;source));</div><div class="line">      RestartWithJob(<span class="keyword">new</span> URLRequestErrorJob(</div><div class="line">          <span class="keyword">this</span>, network_delegate_, ERR_BLOCKED_BY_CLIENT));</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Start() always completes asynchronously.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Status is generally set by URLRequestJob itself, but Start() calls</span></div><div class="line">  <span class="comment">// directly into the URLRequestJob subclass, so URLRequestJob can't set it</span></div><div class="line">  <span class="comment">// here.</span></div><div class="line">  <span class="comment">// TODO(mmenke):  Make the URLRequest manage its own status.</span></div><div class="line">  status_ = URLRequestStatus::FromError(ERR_IO_PENDING);</div><div class="line">  job_-&gt;Start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>URLRequest::Start()首先会初始化LoadTimingInfo结构load_timing<em>info</em>，这个结构用于记录请求执行的一些时间信息；其次，如果network<em>delegate</em>存在的话，则会调用network<em>delegate</em>的回调方法NotifyBeforeURLRequest()等；然后，通过URLRequestJobManager创建创建一个URLRequestJob对象；最后，调用URLRequest::StartJob()启动URLRequestJob。</p>
<h2 id="URLRequestJob的创建"><a href="#URLRequestJob的创建" class="headerlink" title="URLRequestJob的创建"></a>URLRequestJob的创建</h2><p>如我们在前面看到的，URLRequest::Start()通过URLRequestJobManager创建URLRequestJob对象。URLRequestJobManager被设计为单例的类，其构造函数和析构函数被声明为private，而其对象的创建、获取和销毁则是借助于模板base::Singleton来完成的，为了方便模板中访问private构造函数和析构函数，这里(chromium_android/src/net/url_request/url_request_job_manager.h)声明了friend struct：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>:</div><div class="line"> <span class="keyword">friend</span> <span class="keyword">struct</span> base::DefaultSingletonTraits&lt;URLRequestJobManager&gt;;</div><div class="line"></div><div class="line"> URLRequestJobManager();</div><div class="line"> ~URLRequestJobManager();</div></pre></td></tr></table></figure></p>
<p>URLRequestJobManager的GetInstance()方法定义(chromium_android/src/net/url_request/url_request_job_manager.cc)如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// static</span></div><div class="line">URLRequestJobManager* URLRequestJobManager::GetInstance() &#123;</div><div class="line">  <span class="keyword">return</span> base::Singleton&lt;URLRequestJobManager&gt;::<span class="keyword">get</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Singleton模板类在chromium的base模块中(chromium_android/src/base/memory/singleton.h)定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Default traits for Singleton&lt;Type&gt;. Calls operator new and operator delete on</span></div><div class="line"><span class="comment">// the object. Registers automatic deletion at process exit.</span></div><div class="line"><span class="comment">// Overload if you need arguments or another memory allocation function.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</div><div class="line"><span class="keyword">struct</span> DefaultSingletonTraits &#123;</div><div class="line">  <span class="comment">// Allocates the object.</span></div><div class="line">  <span class="function"><span class="keyword">static</span> Type* <span class="title">New</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// The parenthesis is very important here; it forces POD type</span></div><div class="line">    <span class="comment">// initialization.</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Type();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Destroys the object.</span></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(Type* x)</span> </span>&#123;</div><div class="line">    <span class="keyword">delete</span> x;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Set to true to automatically register deletion of the object on process</span></div><div class="line">  <span class="comment">// exit. See below for the required call that makes this happen.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> kRegisterAtExit = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DCHECK_IS_ON()</span></div><div class="line">  <span class="comment">// Set to false to disallow access on a non-joinable thread.  This is</span></div><div class="line">  <span class="comment">// different from kRegisterAtExit because StaticMemorySingletonTraits allows</span></div><div class="line">  <span class="comment">// access on non-joinable threads, and gracefully handles this.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> kAllowedToAccessOnNonjoinableThread = <span class="literal">false</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type,</div><div class="line">          <span class="keyword">typename</span> Traits = DefaultSingletonTraits&lt;Type&gt;,</div><div class="line">          <span class="keyword">typename</span> DifferentiatingType = Type&gt;</div><div class="line"><span class="keyword">class</span> Singleton &#123;</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Classes using the Singleton&lt;T&gt; pattern should declare a GetInstance()</span></div><div class="line">  <span class="comment">// method and call Singleton::get() from within that.</span></div><div class="line">  <span class="keyword">friend</span> Type* Type::GetInstance();</div><div class="line"></div><div class="line">  <span class="comment">// Allow TraceLog tests to test tracing after OnExit.</span></div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> internal::DeleteTraceLogForTesting;</div><div class="line"></div><div class="line">  <span class="comment">// This class is safe to be constructed and copy-constructed since it has no</span></div><div class="line">  <span class="comment">// member.</span></div><div class="line"></div><div class="line">  <span class="comment">// Return a pointer to the one true instance of the class.</span></div><div class="line">  <span class="function"><span class="keyword">static</span> Type* <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DCHECK_IS_ON()</span></div><div class="line">    <span class="comment">// Avoid making TLS lookup on release builds.</span></div><div class="line">    <span class="keyword">if</span> (!Traits::kAllowedToAccessOnNonjoinableThread)</div><div class="line">      ThreadRestrictions::AssertSingletonAllowed();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="comment">// The load has acquire memory ordering as the thread which reads the</span></div><div class="line">    <span class="comment">// instance_ pointer must acquire visibility over the singleton data.</span></div><div class="line">    subtle::AtomicWord value = subtle::Acquire_Load(&amp;instance_);</div><div class="line">    <span class="keyword">if</span> (value != <span class="number">0</span> &amp;&amp; value != internal::kBeingCreatedMarker) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Type*&gt;(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Object isn't created yet, maybe we will get to create it, let's try...</span></div><div class="line">    <span class="keyword">if</span> (subtle::Acquire_CompareAndSwap(&amp;instance_, <span class="number">0</span>,</div><div class="line">                                       internal::kBeingCreatedMarker) == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// instance_ was NULL and is now kBeingCreatedMarker.  Only one thread</span></div><div class="line">      <span class="comment">// will ever get here.  Threads might be spinning on us, and they will</span></div><div class="line">      <span class="comment">// stop right after we do this store.</span></div><div class="line">      Type* newval = Traits::New();</div><div class="line"></div><div class="line">      <span class="comment">// Releases the visibility over instance_ to the readers.</span></div><div class="line">      subtle::Release_Store(&amp;instance_,</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;subtle::AtomicWord&gt;(newval));</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (newval != <span class="literal">NULL</span> &amp;&amp; Traits::kRegisterAtExit)</div><div class="line">        AtExitManager::RegisterCallback(OnExit, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> newval;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// We hit a race. Wait for the other thread to complete it.</span></div><div class="line">    value = internal::WaitForInstance(&amp;instance_);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Type*&gt;(value);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Adapter function for use with AtExit().  This should be called single</span></div><div class="line">  <span class="comment">// threaded, so don't use atomic operations.</span></div><div class="line">  <span class="comment">// Calling OnExit while singleton is in use by other threads is a mistake.</span></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnExit</span><span class="params">(<span class="keyword">void</span>* <span class="comment">/*unused*/</span>)</span> </span>&#123;</div><div class="line">    <span class="comment">// AtExit should only ever be register after the singleton instance was</span></div><div class="line">    <span class="comment">// created.  We should only ever get here with a valid instance_ pointer.</span></div><div class="line">    Traits::Delete(<span class="keyword">reinterpret_cast</span>&lt;Type*&gt;(subtle::NoBarrier_Load(&amp;instance_)));</div><div class="line">    instance_ = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> subtle::AtomicWord instance_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type, <span class="keyword">typename</span> Traits, <span class="keyword">typename</span> DifferentiatingType&gt;</div><div class="line">subtle::AtomicWord Singleton&lt;Type, Traits, DifferentiatingType&gt;::instance_ = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>URLRequestJobManager的CreateJob创建URLRequestJob (chromium_android/src/net/url_request/url_request_job_manager.cc)：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">URLRequestJob* URLRequestJobManager::CreateJob(</div><div class="line">    URLRequest* request, NetworkDelegate* network_delegate) <span class="keyword">const</span> &#123;</div><div class="line">  DCHECK(IsAllowedThread());</div><div class="line"></div><div class="line">  <span class="comment">// If we are given an invalid URL, then don't even try to inspect the scheme.</span></div><div class="line">  <span class="keyword">if</span> (!request-&gt;url().is_valid())</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> URLRequestErrorJob(request, network_delegate, ERR_INVALID_URL);</div><div class="line"></div><div class="line">  <span class="comment">// We do this here to avoid asking interceptors about unsupported schemes.</span></div><div class="line">  <span class="keyword">const</span> URLRequestJobFactory* job_factory =</div><div class="line">      request-&gt;context()-&gt;job_factory();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string&amp; scheme = request-&gt;url().scheme();  <span class="comment">// already lowercase</span></div><div class="line">  <span class="keyword">if</span> (!job_factory-&gt;IsHandledProtocol(scheme)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> URLRequestErrorJob(</div><div class="line">        request, network_delegate, ERR_UNKNOWN_URL_SCHEME);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// THREAD-SAFETY NOTICE:</span></div><div class="line">  <span class="comment">//   We do not need to acquire the lock here since we are only reading our</span></div><div class="line">  <span class="comment">//   data structures.  They should only be modified on the current thread.</span></div><div class="line"></div><div class="line">  <span class="comment">// See if the request should be intercepted.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  URLRequestJob* job = job_factory-&gt;MaybeCreateJobWithProtocolHandler(</div><div class="line">      scheme, request, network_delegate);</div><div class="line">  <span class="keyword">if</span> (job)</div><div class="line">    <span class="keyword">return</span> job;</div><div class="line"></div><div class="line">  <span class="comment">// See if the request should be handled by a built-in protocol factory.</span></div><div class="line">  <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; arraysize(kBuiltinFactories); ++i) &#123;</div><div class="line">    <span class="keyword">if</span> (scheme == kBuiltinFactories[i].scheme) &#123;</div><div class="line">      URLRequestJob* new_job =</div><div class="line">          (kBuiltinFactories[i].factory)(request, network_delegate, scheme);</div><div class="line">      DCHECK(new_job);  <span class="comment">// The built-in factories are not expected to fail!</span></div><div class="line">      <span class="keyword">return</span> new_job;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we reached here, then it means that a registered protocol factory</span></div><div class="line">  <span class="comment">// wasn't interested in handling the URL.  That is fairly unexpected, and we</span></div><div class="line">  <span class="comment">// don't have a specific error to report here :-(</span></div><div class="line">  LOG(WARNING) &lt;&lt; <span class="string">"Failed to map: "</span> &lt;&lt; request-&gt;url().spec();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> URLRequestErrorJob(request, network_delegate, ERR_FAILED);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>URLRequestJob是通过factory创建的。根据URL的scheme的不同，也就是协议的不同，而使用不同的factory创建URLRequestJob对象。在这里会首先判断URL的协议是能被处理。chromium net能处理的协议主要有两类，一类是只要在编译期enable了，就always处理的，如http、https、ws和wss；另一类协议，则不仅要在编译期enable对相关协议的支持，在运行期创建CronetEngine/URLRequestContext时，还可以动态的打开或关闭对相关协议的处理，如data、file、ftp等。</p>
<p>前一类协议的相关信息主要由URLRequestJobManager维护，而后一类协议的信息则由URLRequestContext的URLRequestJobFactory维护。URLRequestJobFactory的实际类型是在URLRequestContextBuilder::Build()中(chromium_android/src/net/url_request/url_request_context_builder.cc)确定的，实际类型为URLRequestJobFactoryImpl：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  URLRequestJobFactoryImpl* job_factory = <span class="keyword">new</span> URLRequestJobFactoryImpl;</div><div class="line">  <span class="comment">// Adds caller-provided protocol handlers first so that these handlers are</span></div><div class="line">  <span class="comment">// used over data/file/ftp handlers below.</span></div><div class="line">  <span class="built_in">for</span> (<span class="keyword">auto</span>&amp; scheme_handler : protocol_handlers_) &#123;</div><div class="line">    job_factory-&gt;SetProtocolHandler(scheme_handler.first,</div><div class="line">                                    std::<span class="built_in">move</span>(scheme_handler.second));</div><div class="line">  &#125;</div><div class="line">  protocol_handlers_.<span class="built_in">clear</span>();</div><div class="line"></div><div class="line">  <span class="built_in">if</span> (data_enabled_)</div><div class="line">    job_factory-&gt;SetProtocolHandler(<span class="string">"data"</span>,</div><div class="line">                                    base::WrapUnique(<span class="keyword">new</span> DataProtocolHandler));</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(DISABLE_FILE_SUPPORT)</span></div><div class="line">  <span class="built_in">if</span> (file_enabled_) &#123;</div><div class="line">    job_factory-&gt;SetProtocolHandler(</div><div class="line">        <span class="string">"file"</span>, base::WrapUnique(</div><div class="line">                    <span class="keyword">new</span> FileProtocolHandler(context-&gt;GetFileTaskRunner())));</div><div class="line">  &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// !defined(DISABLE_FILE_SUPPORT)</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(DISABLE_FTP_SUPPORT)</span></div><div class="line">  <span class="built_in">if</span> (ftp_enabled_) &#123;</div><div class="line">    ftp_transaction_factory_.reset(</div><div class="line">        <span class="keyword">new</span> FtpNetworkLayer(context-&gt;host_resolver()));</div><div class="line">    job_factory-&gt;SetProtocolHandler(</div><div class="line">        <span class="string">"ftp"</span>, base::WrapUnique(</div><div class="line">                   <span class="keyword">new</span> FtpProtocolHandler(ftp_transaction_factory_.<span class="built_in">get</span>())));</div><div class="line">  &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// !defined(DISABLE_FTP_SUPPORT)</span></span></div></pre></td></tr></table></figure></p>
<p>判断协议是否支持，也是通过LRequestContext的URLRequestJobFactory，也就是URLRequestJobFactoryImpl来完成的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> URLRequestJobFactoryImpl::SetProtocolHandler(</div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; scheme,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ProtocolHandler&gt; protocol_handler) &#123;</div><div class="line">  DCHECK(CalledOnValidThread());</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!protocol_handler) &#123;</div><div class="line">    ProtocolHandlerMap::iterator it = protocol_handler_map_.find(scheme);</div><div class="line">    <span class="keyword">if</span> (it == protocol_handler_map_.end())</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    protocol_handler_map_.erase(it);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (ContainsKey(protocol_handler_map_, scheme))</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  protocol_handler_map_[scheme] = <span class="built_in">std</span>::move(protocol_handler);</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line"><span class="keyword">bool</span> URLRequestJobFactoryImpl::IsHandledProtocol(</div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; scheme) <span class="keyword">const</span> &#123;</div><div class="line">  DCHECK(CalledOnValidThread());</div><div class="line">  <span class="keyword">return</span> ContainsKey(protocol_handler_map_, scheme) ||</div><div class="line">      URLRequestJobManager::GetInstance()-&gt;SupportsScheme(scheme);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里判断可以处理的两种类型的协议的列表中是否包含了请求的协议。</p>
<p>URLRequestJobManager维护的，只要编译期enable就always处理的协议的信息通过一个表kBuiltinFactories来维护(chromium_android/src/net/url_request/url_request_job_manager.cc)：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> SchemeToFactory kBuiltinFactories[] = &#123;</div><div class="line">    &#123;<span class="string">"http"</span>, URLRequestHttpJob::Factory&#125;,</div><div class="line">    &#123;<span class="string">"https"</span>, URLRequestHttpJob::Factory&#125;,</div><div class="line"></div><div class="line">#<span class="keyword">if</span> defined(ENABLE_WEBSOCKETS)</div><div class="line">    &#123;<span class="string">"ws"</span>, URLRequestHttpJob::Factory&#125;,</div><div class="line">    &#123;<span class="string">"wss"</span>, URLRequestHttpJob::Factory&#125;,</div><div class="line">#endif  <span class="comment">// defined(ENABLE_WEBSOCKETS)</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line"><span class="comment">// static</span></div><div class="line"><span class="keyword">bool</span> URLRequestJobManager::SupportsScheme(<span class="keyword">const</span> std::string&amp; scheme) &#123;</div><div class="line">  <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; arraysize(kBuiltinFactories); ++i) &#123;</div><div class="line">    <span class="keyword">if</span> (base::LowerCaseEqualsASCII(scheme, kBuiltinFactories[i].scheme))</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>URLRequestJobManager的CreateJob()，在确定URL的协议是支持的之后，会首先尝试使用URLRequestContext的URLRequestJobFactory来创建URLRequestJob，如果失败，则会使用builtin的URLRequestJob的factory。</p>
<p>这里可以看到chromium对URL请求的处理的灵活性。URLRequestJobManager builtin的URLRequestJob的factory，定义了一个http和https协议处理的实现，但通过这里的这套机制，chromium net也可以插入自己定义的http协议处理的实现。</p>
<p>对于http协议和https协议，默认情况下，其URLRequestJob由URLRequestHttpJob::Factory()工厂方法创建。这里我们来看一下它的定义(chromium_android/src/net/url_request/url_request_http_job.cc)：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// static</span></div><div class="line">URLRequestJob* URLRequestHttpJob::Factory(URLRequest* request,</div><div class="line">                                          NetworkDelegate* network_delegate,</div><div class="line">                                          <span class="keyword">const</span> std::string&amp; scheme) &#123;</div><div class="line">  DCHECK(scheme == <span class="string">"http"</span> || scheme == <span class="string">"https"</span> || scheme == <span class="string">"ws"</span> ||</div><div class="line">         scheme == <span class="string">"wss"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!request-&gt;context()-&gt;http_transaction_factory()) &#123;</div><div class="line">    NOTREACHED() &lt;&lt; <span class="string">"requires a valid context"</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> URLRequestErrorJob(</div><div class="line">        request, network_delegate, ERR_INVALID_ARGUMENT);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  URLRequestRedirectJob* redirect =</div><div class="line">      MaybeInternallyRedirect(request, network_delegate);</div><div class="line">  <span class="keyword">if</span> (redirect)</div><div class="line">    <span class="keyword">return</span> redirect;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> URLRequestHttpJob(request,</div><div class="line">                               network_delegate,</div><div class="line">                               request-&gt;context()-&gt;http_user_agent_settings());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>URLRequestHttpJob::Factory()</code>工厂方法会首先判断<code>URLRequestContext</code>的<code>http_transaction_factory</code>是否存在，不存在时创建<code>URLRequestErrorJob</code>并返回。</p>
<p>否则，尝试通过<code>MaybeInternallyRedirect()</code>创建<code>URLRequestRedirectJob</code>，若成功则返回给调用者。</p>
<p><code>URLRequestRedirectJob</code>创建失败时，则会创建<code>URLRequestHttpJob</code>。<code>MaybeInternallyRedirect</code>中创建URLRequestRedirectJob的过程如下(chromium_android/src/net/url_request/url_request_http_job.cc)：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">net::URLRequestRedirectJob* MaybeInternallyRedirect(</div><div class="line">    net::URLRequest* request,</div><div class="line">    net::NetworkDelegate* network_delegate) &#123;</div><div class="line">  <span class="keyword">const</span> GURL&amp; url = request-&gt;url();</div><div class="line">  <span class="keyword">if</span> (url.SchemeIsCryptographic())</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line"></div><div class="line">  net::TransportSecurityState* hsts =</div><div class="line">      request-&gt;context()-&gt;transport_security_state();</div><div class="line">  <span class="keyword">if</span> (!hsts || !hsts-&gt;ShouldUpgradeToSSL(url.host()))</div><div class="line">    <span class="keyword">return</span> nullptr;</div><div class="line"></div><div class="line">  GURL::Replacements replacements;</div><div class="line">  replacements.SetSchemeStr(url.SchemeIs(url::kHttpScheme) ? url::kHttpsScheme</div><div class="line">                                                           : url::kWssScheme);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> net::URLRequestRedirectJob(</div><div class="line">      request, network_delegate, url.ReplaceComponents(replacements),</div><div class="line">      <span class="comment">// Use status code 307 to preserve the method, so POST requests work.</span></div><div class="line">      net::URLRequestRedirectJob::REDIRECT_307_TEMPORARY_REDIRECT, <span class="string">"HSTS"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>URLRequestRedirectJob</code>主要用于将非安全的访问方式转换为安全的访问方式。这里首先会判断URL的scheme是否已经是Security的https或wss，若是，则无需再做其它的而直接返回。</p>
<p>其次，会借助于<code>URLRequestContext</code>的<code>TransportSecurityState</code>判断要访问的主机是否强制将访问方式确定为security的，若不是，则用非安全的方式访问就可以，而直接返回。</p>
<p>最后，要访问的主机强制要求访问方式为security的，而URL的scheme不是https或wss的情况，则先修改URL的scheme为security的，如https或wss，然后创建URLRequestRedirectJob。</p>
<h2 id="URLRequestRedirectJob的执行"><a href="#URLRequestRedirectJob的执行" class="headerlink" title="URLRequestRedirectJob的执行"></a>URLRequestRedirectJob的执行</h2><p>URLRequestRedirectJob的构造过程(chromium_android/src/net/url_request/url_request_redirect_job.cc)如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">URLRequestRedirectJob::URLRequestRedirectJob(URLRequest* request,</div><div class="line">                                             NetworkDelegate* network_delegate,</div><div class="line">                                             <span class="keyword">const</span> GURL&amp; redirect_destination,</div><div class="line">                                             ResponseCode response_code,</div><div class="line">                                             <span class="keyword">const</span> std::string&amp; redirect_reason)</div><div class="line">    : URLRequestJob(request, network_delegate),</div><div class="line">      redirect_destination_(redirect_destination),</div><div class="line">      response_code_(response_code),</div><div class="line">      redirect_reason_(redirect_reason),</div><div class="line">      weak_factory_(<span class="keyword">this</span>) &#123;</div><div class="line">  DCHECK(!redirect_reason_.empty());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在URLRequest::Start()中我们看到，会通过调用URLRequestJob::Start()来启动执行。这里我们看一下URLRequestRedirectJob的Start()实现：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">URLRequestRedirectJob</span><span class="selector-pseudo">::Start()</span> &#123;</div><div class="line">  <span class="selector-tag">request</span>()<span class="selector-tag">-</span>&gt;<span class="selector-tag">net_log</span>()<span class="selector-class">.AddEvent</span>(</div><div class="line">      <span class="attribute">NetLog</span>::TYPE_URL_REQUEST_REDIRECT_JOB,</div><div class="line">      <span class="attribute">NetLog</span>::StringCallback(<span class="string">"reason"</span>, &amp;redirect_reason_));</div><div class="line">  <span class="selector-tag">base</span><span class="selector-pseudo">::ThreadTaskRunnerHandle</span><span class="selector-pseudo">::Get()-</span>&gt;<span class="selector-tag">PostTask</span>(</div><div class="line">      FROM_HERE, <span class="attribute">base</span>::Bind(&amp;<span class="attribute">URLRequestRedirectJob</span>::StartAsync,</div><div class="line">                            weak_factory_.GetWeakPtr()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要是抛了一个task，也就是URLRequestRedirectJob::StartAsync()，给TaskRunner执行：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">void URLRequestRedirectJob::StartAsync() &#123;</div><div class="line">  DCHECK(request_);</div><div class="line">  DCHECK(request_-&gt;status().is_success());</div><div class="line"></div><div class="line">  receive_headers_end_ = base::TimeTicks::Now();</div><div class="line">  response_time_ = base::Time::Now();</div><div class="line"></div><div class="line">  std::string header_string =</div><div class="line">      base::StringPrintf(<span class="string">"HTTP/1.1 %i Internal Redirect\n"</span></div><div class="line">                             <span class="string">"Location: %s\n"</span></div><div class="line">                             <span class="string">"Non-Authoritative-Reason: %s"</span>,</div><div class="line">                         response_code_,</div><div class="line">                         redirect_destination_.spec().c_str(),</div><div class="line">                         redirect_reason_.c_str());</div><div class="line"></div><div class="line">  std::string http_origin;</div><div class="line">  <span class="keyword">const</span> HttpRequestHeaders&amp; request_headers = request_-&gt;extra_request_headers();</div><div class="line">  <span class="keyword">if</span> (request_headers.GetHeader(<span class="string">"Origin"</span>, &amp;http_origin)) &#123;</div><div class="line">    <span class="comment">// If this redirect is used in a cross-origin request, add CORS headers to</span></div><div class="line">    <span class="comment">// make sure that the redirect gets through. Note that the destination URL</span></div><div class="line">    <span class="comment">// is still subject to the usual CORS policy, i.e. the resource will only</span></div><div class="line">    <span class="comment">// be available to web pages if the server serves the response with the</span></div><div class="line">    <span class="comment">// required CORS response headers.</span></div><div class="line">    header_string += base::StringPrintf(</div><div class="line">        <span class="string">"\n"</span></div><div class="line">        <span class="string">"Access-Control-Allow-Origin: %s\n"</span></div><div class="line">        <span class="string">"Access-Control-Allow-Credentials: true"</span>,</div><div class="line">        http_origin.c_str());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  fake_headers_ = <span class="keyword">new</span> HttpResponseHeaders(</div><div class="line">      HttpUtil::AssembleRawHeaders(header_string.c_str(),</div><div class="line">                                   header_string.length()));</div><div class="line">  DCHECK(fake_headers_-&gt;IsRedirect(<span class="keyword">NULL</span>));</div><div class="line"></div><div class="line">  request()-&gt;net_log().AddEvent(</div><div class="line">      NetLog::TYPE_URL_REQUEST_FAKE_RESPONSE_HEADERS_CREATED,</div><div class="line">      base::Bind(</div><div class="line">          &amp;HttpResponseHeaders::NetLogCallback,</div><div class="line">          base::Unretained(fake_headers_.get())));</div><div class="line"></div><div class="line">  <span class="comment">// TODO(mmenke):  Consider calling the NetworkDelegate with the headers here.</span></div><div class="line">  <span class="comment">// There's some weirdness about how to handle the case in which the delegate</span></div><div class="line">  <span class="comment">// tries to modify the redirect location, in terms of how IsSafeRedirect</span></div><div class="line">  <span class="comment">// should behave, and whether the fragment should be copied.</span></div><div class="line">  URLRequestJob::NotifyHeadersComplete();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要是构造了一个<code>HttpResponseHeaders</code>，继而调用了<code>URLRequestJob::NotifyHeadersComplete()</code>。在<code>URLRequestJob::NotifyHeadersComplete()</code>中会对redirect的响应作出适当的处理：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">void URLRequestJob::NotifyHeadersComplete() &#123;</div><div class="line">  <span class="keyword">if</span> (has_handled_response_)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="comment">// The URLRequest status should still be IO_PENDING, which it was set to</span></div><div class="line">  <span class="comment">// before the URLRequestJob was started.  On error or cancellation, this</span></div><div class="line">  <span class="comment">// method should not be called.</span></div><div class="line">  DCHECK(request_-&gt;status().is_io_pending());</div><div class="line">  SetStatus(URLRequestStatus());</div><div class="line"></div><div class="line">  <span class="comment">// Initialize to the current time, and let the subclass optionally override</span></div><div class="line">  <span class="comment">// the time stamps if it has that information.  The default request_time is</span></div><div class="line">  <span class="comment">// set by URLRequest before it calls our Start method.</span></div><div class="line">  request_-&gt;response_info_.response_time = base::Time::Now();</div><div class="line">  GetResponseInfo(&amp;request_-&gt;response_info_);</div><div class="line"></div><div class="line">  MaybeNotifyNetworkBytes();</div><div class="line">  request_-&gt;OnHeadersComplete();</div><div class="line"></div><div class="line">  GURL new_location;</div><div class="line">  <span class="keyword">int</span> http_status_code;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (IsRedirectResponse(&amp;new_location, &amp;http_status_code)) &#123;</div><div class="line">    <span class="comment">// Redirect response bodies are not read. Notify the transaction</span></div><div class="line">    <span class="comment">// so it does not treat being stopped as an error.</span></div><div class="line">    DoneReadingRedirectResponse();</div><div class="line"></div><div class="line">    <span class="comment">// When notifying the URLRequest::Delegate, it can destroy the request,</span></div><div class="line">    <span class="comment">// which will destroy |this|.  After calling to the URLRequest::Delegate,</span></div><div class="line">    <span class="comment">// pointer must be checked to see if |this| still exists, and if not, the</span></div><div class="line">    <span class="comment">// code must return immediately.</span></div><div class="line">    base::WeakPtr&lt;URLRequestJob&gt; weak_this(weak_factory_.GetWeakPtr());</div><div class="line"></div><div class="line">    RedirectInfo redirect_info =</div><div class="line">        ComputeRedirectInfo(new_location, http_status_code);</div><div class="line">    <span class="keyword">bool</span> defer_redirect = <span class="keyword">false</span>;</div><div class="line">    request_-&gt;NotifyReceivedRedirect(redirect_info, &amp;defer_redirect);</div><div class="line"></div><div class="line">    <span class="comment">// Ensure that the request wasn't detached, destroyed, or canceled in</span></div><div class="line">    <span class="comment">// NotifyReceivedRedirect.</span></div><div class="line">    <span class="keyword">if</span> (!weak_this || !request_-&gt;status().is_success())</div><div class="line">      <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (defer_redirect) &#123;</div><div class="line">      deferred_redirect_info_ = redirect_info;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      FollowRedirect(redirect_info);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (NeedsAuth()) &#123;</div><div class="line">    scoped_refptr&lt;AuthChallengeInfo&gt; auth_info;</div><div class="line">    GetAuthChallengeInfo(&amp;auth_info);</div><div class="line"></div><div class="line">    <span class="comment">// Need to check for a NULL auth_info because the server may have failed</span></div><div class="line">    <span class="comment">// to send a challenge with the 401 response.</span></div><div class="line">    <span class="keyword">if</span> (auth_info.get()) &#123;</div><div class="line">      request_-&gt;NotifyAuthRequired(auth_info.get());</div><div class="line">      <span class="comment">// Wait for SetAuth or CancelAuth to be called.</span></div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  has_handled_response_ = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">if</span> (request_-&gt;status().is_success())</div><div class="line">    filter_ = SetupFilter();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!filter_.get()) &#123;</div><div class="line">    std::string content_length;</div><div class="line">    request_-&gt;GetResponseHeaderByName(<span class="string">"content-length"</span>, &amp;content_length);</div><div class="line">    <span class="keyword">if</span> (!content_length.<span class="keyword">empty</span>())</div><div class="line">      base::StringToInt64(content_length, &amp;expected_content_size_);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    request_-&gt;net_log().AddEvent(</div><div class="line">        NetLog::TYPE_URL_REQUEST_FILTERS_SET,</div><div class="line">        base::Bind(&amp;FiltersSetCallback, base::Unretained(filter_.get())));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  request_-&gt;NotifyResponseStarted();</div><div class="line"></div><div class="line">  <span class="comment">// |this| may be destroyed at this point.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里先通过GetResponseInfo()函数读取URL请求的响应信息，包括headers等；然后检查响应是否是重定向的响应，若是，则从响应的headers中抓取重定向信息，然后将这一事件通知给客户端；若客户端不follow重定向，则保存重定向信息并退出；若客户端要follow重定向，则通过<code>FollowRedirect()</code>来follow重定向：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void URLRequestJob::FollowRedirect(<span class="keyword">const</span> RedirectInfo&amp; redirect_info) &#123;</div><div class="line">  <span class="keyword">int</span> rv = request_-&gt;Redirect(redirect_info);</div><div class="line">  <span class="keyword">if</span> (rv != OK)</div><div class="line">    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重定向的任务被委托给了URLRequest来完成：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> URLRequest::Redirect(<span class="keyword">const</span> RedirectInfo&amp; redirect_info) &#123;</div><div class="line">  <span class="comment">// Matches call in NotifyReceivedRedirect.</span></div><div class="line">  OnCallToDelegateComplete();</div><div class="line">  <span class="keyword">if</span> (net_log_.IsCapturing()) &#123;</div><div class="line">    net_log_.AddEvent(</div><div class="line">        NetLog::TYPE_URL_REQUEST_REDIRECTED,</div><div class="line">        NetLog::StringCallback(<span class="string">"location"</span>,</div><div class="line">                               &amp;redirect_info.new_url.possibly_invalid_spec()));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// TODO(davidben): Pass the full RedirectInfo to the NetworkDelegate.</span></div><div class="line">  <span class="keyword">if</span> (network_delegate_)</div><div class="line">    network_delegate_-&gt;NotifyBeforeRedirect(this, redirect_info.new_url);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (redirect_limit_ &lt;= <span class="number">0</span>) &#123;</div><div class="line">    DVLOG(<span class="number">1</span>) &lt;&lt; <span class="string">"disallowing redirect: exceeds limit"</span>;</div><div class="line">    <span class="keyword">return</span> ERR_TOO_MANY_REDIRECTS;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!redirect_info.new_url.is_valid())</div><div class="line">    <span class="keyword">return</span> ERR_INVALID_URL;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!job_-&gt;IsSafeRedirect(redirect_info.new_url)) &#123;</div><div class="line">    DVLOG(<span class="number">1</span>) &lt;&lt; <span class="string">"disallowing redirect: unsafe protocol"</span>;</div><div class="line">    <span class="keyword">return</span> ERR_UNSAFE_REDIRECT;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!final_upload_progress_.position())</div><div class="line">    final_upload_progress_ = job_-&gt;GetUploadProgress();</div><div class="line">  PrepareToRestart();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (redirect_info.new_method != method_) &#123;</div><div class="line">    <span class="comment">// TODO(davidben): This logic still needs to be replicated at the consumers.</span></div><div class="line">    <span class="keyword">if</span> (method_ == <span class="string">"POST"</span>) &#123;</div><div class="line">      <span class="comment">// If being switched from POST, must remove Origin header.</span></div><div class="line">      <span class="comment">// TODO(jww): This is Origin header removal is probably layering violation</span></div><div class="line">      <span class="comment">// and</span></div><div class="line">      <span class="comment">// should be refactored into //content. See https://crbug.com/471397.</span></div><div class="line">      extra_request_headers_.RemoveHeader(HttpRequestHeaders::kOrigin);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// The inclusion of a multipart Content-Type header can cause problems with</span></div><div class="line">    <span class="comment">// some</span></div><div class="line">    <span class="comment">// servers:</span></div><div class="line">    <span class="comment">// http://code.google.com/p/chromium/issues/detail?id=843</span></div><div class="line">    extra_request_headers_.RemoveHeader(HttpRequestHeaders::kContentLength);</div><div class="line">    extra_request_headers_.RemoveHeader(HttpRequestHeaders::kContentType);</div><div class="line">    upload_data_stream_.reset();</div><div class="line">    method_ = redirect_info.new_method;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Cross-origin redirects should not result in an Origin header value that is</span></div><div class="line">  <span class="comment">// equal to the original request's Origin header. This is necessary to prevent</span></div><div class="line">  <span class="comment">// a reflection of POST requests to bypass CSRF protections. If the header was</span></div><div class="line">  <span class="comment">// not set to "null", a POST request from origin A to a malicious origin M</span></div><div class="line">  <span class="comment">// could be redirected by M back to A.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// This behavior is specified in step 1 of step 10 of the 301, 302, 303, 307,</span></div><div class="line">  <span class="comment">// 308 block of step 5 of Section 4.2 of Fetch[1] (which supercedes the</span></div><div class="line">  <span class="comment">// behavior outlined in RFC 6454[2].</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// [1]: https://fetch.spec.whatwg.org/#concept-http-fetch</span></div><div class="line">  <span class="comment">// [2]: https://tools.ietf.org/html/rfc6454#section-7</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// TODO(jww): This is a layering violation and should be refactored somewhere</span></div><div class="line">  <span class="comment">// up into //net's embedder. https://crbug.com/471397</span></div><div class="line">  <span class="keyword">if</span> (!url::Origin(redirect_info.new_url)</div><div class="line">           .IsSameOriginWith(url::Origin(url())) &amp;&amp;</div><div class="line">      extra_request_headers_.HasHeader(HttpRequestHeaders::kOrigin)) &#123;</div><div class="line">    extra_request_headers_.SetHeader(HttpRequestHeaders::kOrigin,</div><div class="line">                                     url::Origin().Serialize());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  referrer_ = redirect_info.new_referrer;</div><div class="line">  referrer_policy_ = redirect_info.new_referrer_policy;</div><div class="line">  first_party_for_cookies_ = redirect_info.new_first_party_for_cookies;</div><div class="line">  token_binding_referrer_ = redirect_info.referred_token_binding_host;</div><div class="line"></div><div class="line">  url_chain_.push_back(redirect_info.new_url);</div><div class="line">  --redirect_limit_;</div><div class="line"></div><div class="line">  Start();</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在URLRequest的Redirect()中，是做了一些准备工作之后，再次调用URLRequest的Start()。</p>
<h2 id="URLRequestHttpJob的执行"><a href="#URLRequestHttpJob的执行" class="headerlink" title="URLRequestHttpJob的执行"></a>URLRequestHttpJob的执行</h2><p>在URLRequestHttpJob::Factory()中，不需要重定向时会直接创建URLRequestHttpJob用以处理URLRequest。这里来看URLRequestHttpJob的执行(chromium_android/src/net/url_request/url_request_http_job.cc)：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">void URLRequestHttpJob::Start() &#123;</div><div class="line">  <span class="comment">// TODO(mmenke): Remove ScopedTracker below once crbug.com/456327 is fixed.</span></div><div class="line">  tracked_objects::ScopedTracker tracking_profile(</div><div class="line">      FROM_HERE_WITH_EXPLICIT_FUNCTION(<span class="string">"456327 URLRequestHttpJob::Start"</span>));</div><div class="line"></div><div class="line">  DCHECK(!transaction_.get());</div><div class="line"></div><div class="line">  <span class="comment">// URLRequest::SetReferrer ensures that we do not send username and password</span></div><div class="line">  <span class="comment">// fields in the referrer.</span></div><div class="line">  GURL referrer(request_-&gt;referrer());</div><div class="line"></div><div class="line">  request_info_.url = request_-&gt;url();</div><div class="line">  request_info_.method = request_-&gt;method();</div><div class="line">  request_info_.load_flags = request_-&gt;load_flags();</div><div class="line">  <span class="comment">// Enable privacy mode if cookie settings or flags tell us not send or</span></div><div class="line">  <span class="comment">// save cookies.</span></div><div class="line">  <span class="keyword">bool</span> enable_privacy_mode =</div><div class="line">      (request_info_.load_flags &amp; LOAD_DO_NOT_SEND_COOKIES) ||</div><div class="line">      (request_info_.load_flags &amp; LOAD_DO_NOT_SAVE_COOKIES) ||</div><div class="line">      CanEnablePrivacyMode();</div><div class="line">  <span class="comment">// Privacy mode could still be disabled in SetCookieHeaderAndStart if we are</span></div><div class="line">  <span class="comment">// going to send previously saved cookies.</span></div><div class="line">  request_info_.privacy_mode = enable_privacy_mode ?</div><div class="line">      PRIVACY_MODE_ENABLED : PRIVACY_MODE_DISABLED;</div><div class="line"></div><div class="line">  <span class="comment">// Strip Referer from request_info_.extra_headers to prevent, e.g., plugins</span></div><div class="line">  <span class="comment">// from overriding headers that are controlled using other means. Otherwise a</span></div><div class="line">  <span class="comment">// plugin could set a referrer although sending the referrer is inhibited.</span></div><div class="line">  request_info_.extra_headers.RemoveHeader(HttpRequestHeaders::kReferer);</div><div class="line"></div><div class="line">  <span class="comment">// Our consumer should have made sure that this is a safe referrer. See for</span></div><div class="line">  <span class="comment">// instance WebCore::FrameLoader::HideReferrer.</span></div><div class="line">  <span class="keyword">if</span> (referrer.is_valid()) &#123;</div><div class="line">    request_info_.extra_headers.SetHeader(HttpRequestHeaders::kReferer,</div><div class="line">                                          referrer.spec());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  request_info_.token_binding_referrer = request_-&gt;token_binding_referrer();</div><div class="line"></div><div class="line">  request_info_.extra_headers.SetHeaderIfMissing(</div><div class="line">      HttpRequestHeaders::kUserAgent,</div><div class="line">      http_user_agent_settings_ ?</div><div class="line">          http_user_agent_settings_-&gt;GetUserAgent() : std::string());</div><div class="line"></div><div class="line">  AddExtraHeaders();</div><div class="line">  AddCookieHeaderAndStart();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要做了三件事：</p>
<ol>
<li>将URLRequest里的一些关于URL请求的信息拷贝出来放进request<em>info</em>结构里。</li>
<li>添加一些用户没有显式地设置的HTTP header，如UserAgent等，及其它一些headers。</li>
<li>添加Cookie header并启动执行。当然是在Cookie enable的情况下，否则就是直接启动执行。</li>
</ol>
<p>由AddExtraHeaders()的定义可以看到，其它的headers主要是指AcceptEncoding和AcceptLanguage这两个。</p>
<p>添加Cookie header并启动的过程则大体为：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">void URLRequestHttpJob::AddCookieHeaderAndStart() &#123;</div><div class="line">  <span class="comment">// If the request was destroyed, then there is no more work to do.</span></div><div class="line">  <span class="keyword">if</span> (!request_)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  CookieStore* cookie_store = request_-&gt;context()-&gt;cookie_store();</div><div class="line">  <span class="keyword">if</span> (cookie_store &amp;&amp; !(request_info_.load_flags &amp; LOAD_DO_NOT_SEND_COOKIES)) &#123;</div><div class="line">    CookieOptions options;</div><div class="line">    options.set_include_httponly();</div><div class="line"></div><div class="line">    <span class="comment">// Set SameSiteCookieMode according to the rules laid out in</span></div><div class="line">    <span class="comment">// https://tools.ietf.org/html/draft-west-first-party-cookies:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// * Include both "strict" and "lax" same-site cookies if the request's</span></div><div class="line">    <span class="comment">//   |url|, |initiator|, and |first_party_for_cookies| all have the same</span></div><div class="line">    <span class="comment">//   registrable domain.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// * Include only "lax" same-site cookies if the request's |URL| and</span></div><div class="line">    <span class="comment">//   |first_party_for_cookies| have the same registrable domain, _and_ the</span></div><div class="line">    <span class="comment">//   request's |method| is "safe" ("GET" or "HEAD").</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//   Note that this will generally be the case only for cross-site requests</span></div><div class="line">    <span class="comment">//   which target a top-level browsing context.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// * Otherwise, do not include same-site cookies.</span></div><div class="line">    url::Origin requested_origin(request_-&gt;url());</div><div class="line">    url::Origin site_for_cookies(request_-&gt;first_party_for_cookies());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (registry_controlled_domains::SameDomainOrHost(</div><div class="line">            requested_origin, site_for_cookies,</div><div class="line">            registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) &#123;</div><div class="line">      <span class="keyword">if</span> (registry_controlled_domains::SameDomainOrHost(</div><div class="line">              requested_origin, request_-&gt;initiator(),</div><div class="line">              registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) &#123;</div><div class="line">        options.set_same_site_cookie_mode(</div><div class="line">            CookieOptions::SameSiteCookieMode::INCLUDE_STRICT_AND_LAX);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IsMethodSafe(request_-&gt;method())) &#123;</div><div class="line">        options.set_same_site_cookie_mode(</div><div class="line">            CookieOptions::SameSiteCookieMode::INCLUDE_LAX);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    cookie_store-&gt;GetCookieListWithOptionsAsync(</div><div class="line">        request_-&gt;url(), options,</div><div class="line">        base::Bind(&amp;URLRequestHttpJob::SetCookieHeaderAndStart,</div><div class="line">                   weak_factory_.GetWeakPtr()));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    DoStartTransaction();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void URLRequestHttpJob::SetCookieHeaderAndStart(<span class="keyword">const</span> CookieList&amp; cookie_list) &#123;</div><div class="line">  <span class="keyword">if</span> (cookie_list.size() &amp;&amp; CanGetCookies(cookie_list)) &#123;</div><div class="line">    request_info_.extra_headers.SetHeader(</div><div class="line">        HttpRequestHeaders::kCookie, CookieStore::BuildCookieLine(cookie_list));</div><div class="line">    <span class="comment">// Disable privacy mode as we are sending cookies anyway.</span></div><div class="line">    request_info_.privacy_mode = PRIVACY_MODE_DISABLED;</div><div class="line">  &#125;</div><div class="line">  DoStartTransaction();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果不需要设置Cookies，则会直接调用DoStartTransaction()启动HTTP请求执行；否则，通过cookie_store异步地获取CookieCookieList，并设置给URLRequestHttpJob，然后调用DoStartTransaction()。</p>
<p>DoStartTransaction()：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="literal">void</span> URLRequestHttpJob<span class="type">::StartTransaction</span>() &#123;</div><div class="line">  <span class="comment">// TODO(mmenke): Remove ScopedTracker below once crbug.com/456327 is fixed.</span></div><div class="line">  tracked_objects<span class="type">::ScopedTracker</span> tracking_profile(</div><div class="line">      FROM_HERE_WITH_EXPLICIT_FUNCTION(</div><div class="line">          <span class="string">"456327 URLRequestHttpJob::StartTransaction"</span>));</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (network_delegate()) &#123;</div><div class="line">    OnCallToDelegate();</div><div class="line">    int rv = network_delegate()-&gt;NotifyBeforeStartTransaction(</div><div class="line">        request_, notify_before_headers_sent_callback_,</div><div class="line">        &amp;request_info_.extra_headers);</div><div class="line">    <span class="comment">// If an extension blocks the request, we rely on the callback to</span></div><div class="line">    <span class="comment">// MaybeStartTransactionInternal().</span></div><div class="line">    <span class="keyword">if</span> (rv == ERR_IO_PENDING)</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    MaybeStartTransactionInternal(rv);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  StartTransactionInternal();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="params">...</span><span class="params">...</span></div><div class="line"></div><div class="line"><span class="literal">void</span> URLRequestHttpJob<span class="type">::MaybeStartTransactionInternal</span>(int result) &#123;</div><div class="line">  <span class="comment">// TODO(mmenke): Remove ScopedTracker below once crbug.com/456327 is fixed.</span></div><div class="line">  tracked_objects<span class="type">::ScopedTracker</span> tracking_profile(</div><div class="line">      FROM_HERE_WITH_EXPLICIT_FUNCTION(</div><div class="line">          <span class="string">"456327 URLRequestHttpJob::MaybeStartTransactionInternal"</span>));</div><div class="line"></div><div class="line">  OnCallToDelegateComplete();</div><div class="line">  <span class="keyword">if</span> (result == OK) &#123;</div><div class="line">    StartTransactionInternal();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    std<span class="type">::string</span> source(<span class="string">"delegate"</span>);</div><div class="line">    request_-&gt;net_log().AddEvent(NetLog<span class="type">::TYPE_CANCELLED</span>,</div><div class="line">                                 NetLog<span class="type">::StringCallback</span>(<span class="string">"source"</span>, &amp;source));</div><div class="line">    NotifyStartError(URLRequestStatus(URLRequestStatus<span class="type">::FAILED</span>, result));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="params">...</span><span class="params">...</span></div><div class="line"></div><div class="line"><span class="literal">void</span> URLRequestHttpJob<span class="type">::DoStartTransaction</span>() &#123;</div><div class="line">  <span class="comment">// We may have been canceled while retrieving cookies.</span></div><div class="line">  <span class="keyword">if</span> (GetStatus().is_success()) &#123;</div><div class="line">    StartTransaction();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    NotifyCanceled();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DoStartTransaction()首先检查一下请求是否被取消，如果已经取消了，会调用NotifyCanceled()来通知取消事件。</p>
<p>否则会调用StartTransaction()启动Transaction。这里会根据是否设置了回调，而有着不同的执行路径。如果没有设置回调，会直接调用StartTransactionInternal()启动Transaction。</p>
<p>而如果设置了回调，则先调用回调，并记录一些trace信息，然后调用StartTransactionInternal()。</p>
<p>来看StartTransactionInternal()：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">void URLRequestHttpJob::StartTransactionInternal() &#123;</div><div class="line">  <span class="comment">// This should only be called while the request's status is IO_PENDING.</span></div><div class="line">  DCHECK_EQ(URLR<span class="function"><span class="title">equestStatus</span>::IO_PENDING, request_-&gt;</span>status().status());</div><div class="line"></div><div class="line">  <span class="comment">// <span class="doctag">NOTE:</span> This method assumes that request_info_ is already setup properly.</span></div><div class="line"></div><div class="line">  <span class="comment">// If we already have a transaction, then we should restart the transaction</span></div><div class="line">  <span class="comment">// with auth provided by auth_credentials_.</span></div><div class="line"></div><div class="line">  int rv;</div><div class="line"></div><div class="line">  <span class="comment">// Notify NetworkQualityEstimator.</span></div><div class="line">  NetworkQualityEstimator* network_quality_estimator =</div><div class="line">      <span class="function"><span class="title">request</span>()-&gt;</span><span class="function"><span class="title">context</span>()-&gt;</span>network_quality_estimator();</div><div class="line">  <span class="keyword">if</span> (network_quality_estimator)</div><div class="line">    <span class="function"><span class="title">network_quality_estimator</span>-&gt;</span>NotifyStartTransaction(*request_);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (network_delegate()) &#123;</div><div class="line">    <span class="function"><span class="title">network_delegate</span>()-&gt;</span>NotifyStartTransaction(request_,</div><div class="line">                                               request_info_.extra_headers);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (transaction_.get()) &#123;</div><div class="line">    <span class="function"><span class="title">rv</span> = transaction_-&gt;</span>RestartWithAuth(auth_credentials_, start_callback_);</div><div class="line">    auth_credentials_ = AuthCredentials();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    DCHECK(<span class="function"><span class="title">request_</span>-&gt;</span><span class="function"><span class="title">context</span>()-&gt;</span>http_transaction_factory());</div><div class="line"></div><div class="line">    <span class="function"><span class="title">rv</span> = request_-&gt;</span><span class="function"><span class="title">context</span>()-&gt;</span><span class="function"><span class="title">http_transaction_factory</span>()-&gt;</span>CreateTransaction(</div><div class="line">        priority_, &amp;transaction_);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rv == OK &amp;&amp; request_info_.url.SchemeIsWSOrWSS()) &#123;</div><div class="line">      <span class="function"><span class="title">base</span>::SupportsUserData::Data* <span class="keyword">data</span> = request_-&gt;</span>GetUserData(</div><div class="line">          WebSocketHandshakeStreamBase::CreateHelper::DataKey());</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">data</span>) &#123;</div><div class="line">        <span class="function"><span class="title">transaction_</span>-&gt;</span>SetWebSocketHandshakeStreamCreateHelper(</div><div class="line">            static_cast&lt;WebSocketHandshakeStreamBase::CreateHelper*&gt;(<span class="keyword">data</span>));</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        rv = ERR_DISALLOWED_URL_SCHEME;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rv == OK) &#123;</div><div class="line">      <span class="function"><span class="title">transaction_</span>-&gt;</span>SetBeforeNetworkStartCallback(</div><div class="line">          base::Bind(&amp;URLRequestHttpJob::NotifyBeforeNetworkStart,</div><div class="line">                     base::Unretained(this)));</div><div class="line">      <span class="function"><span class="title">transaction_</span>-&gt;</span>SetBeforeHeadersSentCallback(</div><div class="line">          base::Bind(&amp;URLRequestHttpJob::NotifyBeforeSendHeadersCallback,</div><div class="line">                     base::Unretained(this)));</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!throttling_entry_.get() ||</div><div class="line">          !<span class="function"><span class="title">throttling_entry_</span>-&gt;</span>ShouldRejectRequest(*request_)) &#123;</div><div class="line">        <span class="function"><span class="title">rv</span> = transaction_-&gt;</span>Start(</div><div class="line">            &amp;<span class="function"><span class="title">request_info_</span>, start_callback_, request_-&gt;</span>net_log());</div><div class="line">        start_time_ = base::TimeTicks::Now();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Special error code for the exponential back-off module.</span></div><div class="line">        rv = ERR_TEMPORARILY_THROTTLED;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (rv == ERR_IO_PENDING)</div><div class="line">    return;</div><div class="line"></div><div class="line">  <span class="comment">// The transaction started synchronously, but we need to notify the</span></div><div class="line">  <span class="comment">// URLRequest delegate via the message loop.</span></div><div class="line">  <span class="function"><span class="title">base</span>::ThreadTaskRunnerHandle::Get()-&gt;</span>PostTask(</div><div class="line">      FROM_HERE, base::Bind(&amp;URLRequestHttpJob::OnStartCompleted,</div><div class="line">                            weak_factory_.GetWeakPtr(), rv));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个函数中，做了这样一些事情：</p>
<ol>
<li>获取URLRequestContext的NetworkQualityEstimator，以向其通知Transaction启动事件。</li>
<li>向network_delegate通知Transaction启动事件。</li>
<li>如果已经创建了HttpTransaction，则restart。</li>
<li>还没有创建HttpTransaction的情况，先通过URLRequestContext的HttpTransactionFactory创建HttpTransaction。</li>
<li>处理WS和WSS的情况。</li>
<li>为HttpTransaction设置BeforeNetworkStartCallback和BeforeHeadersSentCallback回调。</li>
<li>执行HttpTransaction的Start()。</li>
<li>Post一个Task URLRequestHttpJob::OnStartCompleted()。</li>
</ol>
<h2 id="HttpTransaction的创建"><a href="#HttpTransaction的创建" class="headerlink" title="HttpTransaction的创建"></a>HttpTransaction的创建</h2><p>HttpTransaction由URLRequestContext的HttpTransactionFactory创建的。回顾URLRequestContextBuilder::Build()的如下这段代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">storage-&gt;set_http_network_session(</div><div class="line">    base::WrapUnique(<span class="keyword">new</span> HttpNetworkSession(network_session_params)));</div><div class="line"></div><div class="line">std::unique_ptr&lt;HttpTransactionFactory&gt; http_transaction_factory;</div><div class="line"><span class="keyword">if</span> (http_cache_enabled_) &#123;</div><div class="line">  std::unique_ptr&lt;HttpCache::BackendFactory&gt; http_cache_backend;</div><div class="line">  <span class="keyword">if</span> (http_cache_params_.type != HttpCacheParams::IN_MEMORY) &#123;</div><div class="line">    BackendType backend_type =</div><div class="line">        http_cache_params_.type == HttpCacheParams::DISK</div><div class="line">            ? CACHE_BACKEND_DEFAULT</div><div class="line">            : CACHE_BACKEND_SIMPLE;</div><div class="line">    http_cache_backend.reset(<span class="keyword">new</span> HttpCache::DefaultBackend(</div><div class="line">        DISK_CACHE, backend_type, http_cache_params_.path,</div><div class="line">        http_cache_params_.max_size, context-&gt;GetFileTaskRunner()));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    http_cache_backend =</div><div class="line">        HttpCache::DefaultBackend::InMemory(http_cache_params_.max_size);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  http_transaction_factory.reset(<span class="keyword">new</span> HttpCache(</div><div class="line">      storage-&gt;http_network_session(), std::move(http_cache_backend), <span class="keyword">true</span>));</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  http_transaction_factory.reset(</div><div class="line">      <span class="keyword">new</span> HttpNetworkLayer(storage-&gt;http_network_session()));</div><div class="line">&#125;</div><div class="line">storage-&gt;set_http_transaction_factory(std::move(http_transaction_factory));</div></pre></td></tr></table></figure></p>
<p>这里根据是否启用Cache，而使用不同的HttpTransactionFactory。启用了Cache时，会使用HttpCache作为HttpTransactionFactory；而没有启用Cache时，则会使用HttpNetworkLayer作为HttpTransactionFactory。</p>
<p>在URLRequestHttpJob::StartTransactionInternal()中会调用HttpTransactionFactory的CreateTransaction()来创建Transaction。</p>
<p>HttpCache的CreateTransaction()定义(chromium_android/src/net/http/http_cache.cc)如下：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> HttpCache::CreateTransaction(RequestPriority priority,</div><div class="line">                                 std::unique_ptr&lt;HttpTransaction&gt;* trans) &#123;</div><div class="line">  <span class="comment">// Do lazy initialization of disk cache if needed.</span></div><div class="line">  <span class="keyword">if</span> (!disk_cache_.get()) &#123;</div><div class="line">    <span class="comment">// We don't care about the result.</span></div><div class="line">    CreateBackend(<span class="keyword">NULL</span>, CompletionCallback());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">   HttpCache::Transaction* transaction =</div><div class="line">      <span class="keyword">new</span> HttpCache::Transaction(priority, this);</div><div class="line">   <span class="keyword">if</span> (bypass_lock_for_test_)</div><div class="line">    transaction-&gt;BypassLockForTest();</div><div class="line">   <span class="keyword">if</span> (fail_conditionalization_for_test_)</div><div class="line">     transaction-&gt;FailConditionalizationForTest();</div><div class="line"></div><div class="line">  trans-&gt;reset(transaction);</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里是创建类型为HttpCache::Transaction的对象。HttpCache::Transaction (chromium_android/src/net/http/http_cache_transaction.cc)看起来还是蛮复杂的：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">HttpCache::Transaction::Transaction(RequestPriority priority, HttpCache* cache)</div><div class="line">    : next_state_(STATE_NONE),</div><div class="line">      request_(NULL),</div><div class="line">      priority_(priority),</div><div class="line">      cache_(cache-&gt;GetWeakPtr()),</div><div class="line">      entry_(NULL),</div><div class="line">      new_entry_(NULL),</div><div class="line">      new_response_(NULL),</div><div class="line">      mode_(NONE),</div><div class="line">      reading_(<span class="keyword">false</span>),</div><div class="line">      invalid_range_(<span class="keyword">false</span>),</div><div class="line">      truncated_(<span class="keyword">false</span>),</div><div class="line">      is_sparse_(<span class="keyword">false</span>),</div><div class="line">      range_requested_(<span class="keyword">false</span>),</div><div class="line">      handling_206_(<span class="keyword">false</span>),</div><div class="line">      cache_pending_(<span class="keyword">false</span>),</div><div class="line">      done_reading_(<span class="keyword">false</span>),</div><div class="line">      vary_mismatch_(<span class="keyword">false</span>),</div><div class="line">      couldnt_conditionalize_request_(<span class="keyword">false</span>),</div><div class="line">      bypass_lock_for_test_(<span class="keyword">false</span>),</div><div class="line">      fail_conditionalization_for_test_(<span class="keyword">false</span>),</div><div class="line">      io_buf_len_(0),</div><div class="line">      read_offset_(0),</div><div class="line">      effective_load_flags_(0),</div><div class="line">      write_len_(0),</div><div class="line">      cache_entry_status_(CacheEntryStatus::ENTRY_UNDEFINED),</div><div class="line">      validation_cause_(VALIDATION_CAUSE_UNDEFINED),</div><div class="line">      total_received_bytes_(0),</div><div class="line">      total_sent_bytes_(0),</div><div class="line">      websocket_handshake_stream_base_create_helper_(NULL),</div><div class="line">      weak_factory_(<span class="keyword">this</span>) &#123;</div><div class="line">  static_assert(HttpCache::Transaction::kNumValidationHeaders ==</div><div class="line">                    arraysize(kValidationHeaders),</div><div class="line">                <span class="string">"invalid number of validation headers"</span>);</div><div class="line"></div><div class="line">  io_callback_ = base::Bind(&amp;Transaction::OnIOComplete,</div><div class="line">                              weak_factory_.GetWeakPtr());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后来看HttpNetworkLayer (chromium_android/src/net/http/http_network_layer.cc)的CreateTransaction()函数：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int <span class="symbol">HttpNetworkLayer:</span><span class="symbol">:CreateTransaction</span>(</div><div class="line">    RequestPriority priority,</div><div class="line">    <span class="symbol">std:</span><span class="symbol">:unique_ptr&lt;HttpTransaction&gt;*</span> trans) &#123;</div><div class="line">  if (suspended<span class="number">_</span>)</div><div class="line">    <span class="keyword">return</span> ERR_NETWORK_IO_SUSPENDED;</div><div class="line"></div><div class="line">  trans-&gt;reset(new HttpNetworkTransaction(priority, GetSession()));</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里创建的则是HttpNetworkTransaction。</p>
<p>至此，http请求启动的过程就基本分析完了。</p>
</div><div class="tags"><a href="/tags/网络协议/">网络协议</a><a href="/tags/Android开发/">Android开发</a><a href="/tags/源码分析/">源码分析</a><a href="/tags/chromium/">chromium</a></div><div class="post-nav"><a href="/2016/10/29/Cronet_android_altsvc/" class="pre">Cronet android 设计与实现分析——备选服务机制</a><a href="/2016/10/29/Cronet_android设计与实现分析__库的初始化/" class="next">Cronet android设计与实现分析--库的初始化﻿</a></div><div id="disqus_thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-图形系统/">Android 图形系统</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发/">Android开发</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-开发/">C/C++开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java开发/">Java开发</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核/">Linux内核</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/live555/">live555</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/业界趣闻/">业界趣闻</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台开发/">后台开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络调试/">网络调试</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随想杂谈/">随想杂谈</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频开发/">音视频开发</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/Android开发/" style="font-size: 15px;">Android开发</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/chromium/" style="font-size: 15px;">chromium</a> <a href="/tags/后台开发/" style="font-size: 15px;">后台开发</a> <a href="/tags/Java开发/" style="font-size: 15px;">Java开发</a> <a href="/tags/QUIC/" style="font-size: 15px;">QUIC</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/网络调试/" style="font-size: 15px;">网络调试</a> <a href="/tags/HTTP2/" style="font-size: 15px;">HTTP2</a> <a href="/tags/UDT/" style="font-size: 15px;">UDT</a> <a href="/tags/图形图像/" style="font-size: 15px;">图形图像</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/C-C-开发/" style="font-size: 15px;">C/C++开发</a> <a href="/tags/音视频开发/" style="font-size: 15px;">音视频开发</a> <a href="/tags/Linux内核/" style="font-size: 15px;">Linux内核</a> <a href="/tags/live555/" style="font-size: 15px;">live555</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/Go-语言/" style="font-size: 15px;">Go 语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">二月 2013</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/15/egl_context_creation/">EGL Context 创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/14/egl_init_drivers/">Android 图形驱动初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/opengl_on_android_with_sv/">在 Android 中使用 OpenGL</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/12/android_debug_gdb/">使用 GDB 调试 Android 应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/11/android_emulator_dev/">Android 模拟器下载、编译及调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/live555_src_analysis_start_streaming/">live555 源码分析：播放启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/live555_src_analysis_subsession_setup/">live555 源码分析：子会话 SETUP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/07/live555_src_analysis_subsession_sdp/">live555 源码分析：子会话 SDP 行生成</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/07/live555_src_analysis_servermediasession/">live555 源码分析：ServerMediaSession</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/live555_src_analysis_rtspserver_arch/">live555 源码分析：RTSPServer 组件结构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="https://source.android.com/" title="Android Open Source Project" target="_blank">Android Open Source Project</a><ul></ul><a href="http://www.vants.org/" title="蚂蚁网" target="_blank">蚂蚁网</a></div><div class="widget"><div class="widget-title"><i class="fa fa-commt"> 最近评论</i></div><script type="text/javascript" src="//wolfcstech.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.2.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:hanpfei@gmail.com" target="_blank" class="fa fa-email"> </a><a href="undefined" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/hanpfei" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">Han Pengfei</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var disqus_shortname = 'wolfcstech';
var disqus_identifier = '2016/10/29/Cronet_android设计与实现分析__HTTP请求启动/';
var disqus_title = 'Cronet android设计与实现分析--HTTP请求启动';
var disqus_url = 'https://www.wolfcstech.com/2016/10/29/Cronet_android设计与实现分析__HTTP请求启动/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wolfcstech.disqus.com/count.js" async></script><script type="text/javascript" src="/js/search.json.js?v=1.2.0"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3c736b12c32c019fd9ff6c825b6b9b44";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></body></html>