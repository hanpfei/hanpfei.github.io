<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>HTTP/2规范：8. HTTP消息交换 | WolfcsTech</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.2.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.2.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HTTP/2规范：8. HTTP消息交换</h1><a id="logo" href="/.">WolfcsTech</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">HTTP/2规范：8. HTTP消息交换</h1><div class="post-meta">Oct 29, 2016<span> | </span><span class="category"><a href="/categories/网络协议/">网络协议</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/10/29/8-zh-cn/" href="/2016/10/29/8-zh-cn/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>HTTP/2被期待着尽可能与当前使用的HTTP兼容。这意味着，从应用程序的视角来看，大部分的协议的功能不能变。为了实现这一点，而保留了所有的请求和响应的语义，尽管携带这些语义的语法已经变了。</p>
<p>因而，HTTP/1.1的规范和要求，Semantics and Content <a href="https://http2.github.io/http2-spec/#RFC7231" target="_blank" rel="external">[RFC7231]
</a>，Conditional Requests <a href="https://http2.github.io/http2-spec/#RFC7232" target="_blank" rel="external">[RFC7232]
</a>，Range Requests <a href="https://http2.github.io/http2-spec/#RFC7233" target="_blank" rel="external">[RFC7233]
</a>，Caching <a href="https://http2.github.io/http2-spec/#RFC7234" target="_blank" rel="external">[RFC7234]
</a>，和Authentication <a href="https://http2.github.io/http2-spec/#RFC7235" target="_blank" rel="external">[RFC7235]
</a>依然适用于HTTP/2。选中的HTTP/1.1 Message Syntax and Routing <a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>的部分，比如HTTP和HTTPS URI schemes，也适用于HTTP/2，但是对于这个协议，那些语义的表达则在下面的小节定义。</p>
<a id="more"></a>
<h2 id="8-1-HTTP-请求-响应-交换"><a href="#8-1-HTTP-请求-响应-交换" class="headerlink" title="8.1 HTTP 请求/响应 交换"></a><a href="https://http2.github.io/http2-spec/#HttpSequence" target="_blank" rel="external">8.1 HTTP 请求/响应 交换</a></h2><p>一个客户端在一个新流上发送一个HTTP请求，使用一个之前未使用的流标识符(<a href="https://http2.github.io/http2-spec/#StreamIdentifiers" target="_blank" rel="external">Section 5.1.1</a>)。一个服务器在与请求相同的流上发送HTTP响应。</p>
<p>一个HTTP消息 (请求或响应)的组成为：</p>
<ol>
<li><p>仅适用于响应，0个或多个<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧 (每个后面都跟着0个或多个<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a>帧)包含信息性的 (1xx) HTTP响应的消息头(参见<a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#header.fields" target="_blank" rel="external">Section 3.2</a>和<a href="https://http2.github.io/http2-spec/#RFC7231" target="_blank" rel="external">[RFC7231]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#status.1xx" target="_blank" rel="external">Section 6.2</a>)。</p>
</li>
<li><p>一个<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧 (每个后面都跟着0个或多个<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a>帧)包含消息首部 (参见<a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#header.fields" target="_blank" rel="external">Section 3.2</a>)</p>
</li>
<li><p>0个或多个<a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a>帧包含载荷体 (参见<a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#message.body" target="_blank" rel="external">Section 3.3</a>)，以及</p>
</li>
<li><p>可选的，一个<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧 (每个后面都跟着0个或多个<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a>帧)包含尾部，如果存在的话(参见<a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#chunked.trailer.part" target="_blank" rel="external">Section 4.1.2</a>)</p>
</li>
</ol>
<p>序列的最后一帧携带END_STREAM标记，注意一个携带了END_STREAM标记的<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧后面可以跟多个<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a>帧来携带首部块的其余部分。</p>
<p><a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧和它后面跟着的任何<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a>帧之间 <strong>必须不(MUST NOT)</strong> 能出现任何其它帧(来自于任何流)。</p>
<p>HTTP/2使用DATA帧来携带携带消息载荷。在HTTP/2中 <strong>必须不(MUST NOT)</strong> 能使用在<a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>的<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#chunked.encoding" target="_blank" rel="external">Section 4.1</a>定义的分块传输编码。</p>
<p>首部尾字段 (trailing header fields)由一个首部块携带，首部块也会终止流。这样的一个首部块一个<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧起始，后跟0个或多个<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a>帧，其中<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧携带了END_STREAM标记。第一个首部块之后没有终止流的首部块不是HTTP请求或响应的一部分。</p>
<p><a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧 (及其相关的<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a>帧)只能出现在一个流的开始或结尾处。一个终端在接收到一个最终的 (final) (非信息性的)状态码之后，接收到了一个没有设置END_STREAM的<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧，则它 <strong>必须(MUST)</strong> 将对应的请求或响应当作是已损坏的(<a href="https://http2.github.io/http2-spec/#malformed" target="_blank" rel="external">Section 8.1.2.6</a>)。</p>
<p>一个HTTP请求/响应交换完全消耗一个流。一个请求以一个<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧开始，而将流放进“打开”状态。请求以一个携带了END_STREAM的帧结束，而使得流对于客户端变为”half-closed (local)”，对于服务器变为”half-closed (remote)”。一个响应以一个<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧开始，以一个携带了END_STREAM的帧结束，而将流放进”closed”状态。</p>
<p>一个HTTP响应在服务器发送——或客户端收到——一个设置了END_STREAM标记的帧(包含任何完成一个首部块所需的 <a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a>帧)之后完成。如果响应不依赖于请求的任何还未接收到的部分的话，则它可以在客户端发送完整的请求之前就发送一个完整的响应。如果是这种情况，服务器 <strong>可以(MAY)</strong> 在发送了完整的响应之后，通过发送一个携带了错误码<a href="https://http2.github.io/http2-spec/#NO_ERROR" target="_blank" rel="external">NO_ERROR</a>的<a href="https://http2.github.io/http2-spec/#RST_STREAM" target="_blank" rel="external">RST_STREAM</a>，无错误地请求客户端停止传输请求 (比如一个设置了END_STREAM标记的帧)。客户端在收到了这样的一个<a href="https://http2.github.io/http2-spec/#RST_STREAM" target="_blank" rel="external">RST_STREAM</a>时， <strong>必须不(MUST NOT)</strong> 能丢弃响应，尽管因为其它原因客户端总是有丢弃响应的自由。</p>
<h3 id="8-1-1-从HTTP-2升级"><a href="#8-1-1-从HTTP-2升级" class="headerlink" title="8.1.1 从HTTP/2升级"></a><a href="https://http2.github.io/http2-spec/#informational-responses" target="_blank" rel="external">8.1.1 从HTTP/2升级</a></h3><p>HTTP/2移除了对101 (Switching Protocols) 信息性状态码(<a href="https://http2.github.io/http2-spec/#RFC7231" target="_blank" rel="external">[RFC7231]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#status.101" target="_blank" rel="external">Section 6.2.2</a>)的支持。</p>
<p>101 (Switching Protocols)的语义不再适用于多路复用的协议。HTTP/2使用的替代协议能够使用相同的语义来协商使用(参见<a href="https://http2.github.io/http2-spec/#starting" target="_blank" rel="external">Section 3</a>)。</p>
<h3 id="8-1-2-HTTP-首部字段"><a href="#8-1-2-HTTP-首部字段" class="headerlink" title="8.1.2 HTTP 首部字段"></a><a href="https://http2.github.io/http2-spec/#HttpHeaders" target="_blank" rel="external">8.1.2 HTTP 首部字段</a></h3><p>HTTP首部字段以一系列键-值对的形式携带信息。要获得已注册的HTTP首部的列表，参见维护于<a href="[https://www.iana.org/assignments/message-headers](https://www.iana.org/assignments/message-headers)">[https://www.iana.org/assignments/message-headers](https://www.iana.org/assignments/message-headers)</a>的“消息首部字段”注册。</p>
<p>就如同HTTP/1.x中的那样，首部字段名是不区分大小写的ASCII字符串。然而，首部字段名 <strong>必须(MUST)</strong> 在被编码进HTTP/2之前被转换为小写形式。一个请求或响应包含了大写的首部字段名 <strong>必须(MUST)</strong> 被当作是损坏的(<a href="https://http2.github.io/http2-spec/#malformed" target="_blank" rel="external">Section 8.1.2.6</a>)。</p>
<h4 id="8-1-2-1-伪首部字段"><a href="#8-1-2-1-伪首部字段" class="headerlink" title="8.1.2.1 伪首部字段"></a><a href="https://http2.github.io/http2-spec/#PseudoHeaderFields" target="_blank" rel="external">8.1.2.1 伪首部字段</a></h4><p>尽管 HTTP/1.x 使用消息起始行(参见<a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#start.line" target="_blank" rel="external">Section 3.1</a>)来携带目标URI，请求的method，和响应的状态码，而HTTP/2则使用以’:’字符 (ASCII 0x3a)起始的特殊的伪首部字段来达到这一目的。</p>
<p>伪首部字段不是HTTP首部字段。终端 <strong>一定不能(MUST NOT)</strong> 产生这份文档中定义的之外的伪首部字段。</p>
<p>伪首部字段只在定义它们的上下文有效。为请求定义的伪首部字段 <strong>一定不能(MUST NOT)</strong> 出现在响应中；为响应定义的伪首部字段 <strong>一定不能(MUST NOT)</strong> 出现在请求中。伪首部字段 <strong>一定不能(MUST NOT)</strong> 出现在尾部。终端 <strong>一定要(MUST)</strong> 将包含了未定义或无效的伪首部字段的请求或响应当做是损坏的(<a href="https://http2.github.io/http2-spec/#malformed" target="_blank" rel="external">Section 8.1.2.6</a>)。</p>
<p>所有的伪首部字段 <strong>必须(MUST)</strong> 出现在首部块中普通的首部字段之前。任何的在首部块中包含了位于普通首部字段之后的伪首部字段的请求或响应 <strong>必须(MUST)</strong> 被当做是损坏的(<a href="https://http2.github.io/http2-spec/#malformed" target="_blank" rel="external">Section 8.1.2.6</a>)。</p>
<h4 id="8-1-2-2-连接特有首部字段"><a href="#8-1-2-2-连接特有首部字段" class="headerlink" title="8.1.2.2 连接特有首部字段"></a><a href="https://http2.github.io/http2-spec/#rfc.section.8.1.2.2" target="_blank" rel="external">8.1.2.2 连接特有首部字段</a></h4><p>HTTP/2不使用Connection首部字段来指明 连接特有(connection-specific) 首部字段；在这个协议中，连接特有(connection-specific) 元数据有其它方式传送。一个终端 <strong>一定不能(MUST NOT)</strong> 产生包含 连接特有(connection-specific) 首部字段的HTTP/2消息；任何包含了 连接特有(connection-specific) 首部字段的消息  <strong>必须(MUST)</strong> 被当做是损坏的(<a href="https://http2.github.io/http2-spec/#malformed" target="_blank" rel="external">Section 8.1.2.6</a>)</p>
<p>这条规则仅有的例外是TE首部字段，它 <strong>可以(MAY)</strong> 出现HTTP/2请求中；当出现时，它 <strong>一定不能(MUST NOT)</strong> 包含除”trailers”之外的任何值。</p>
<p>这意味着一个中继传输一个HTTP/1.x消息给HTTP/2时，将需要与移除Connection首部字段本身一起，移除任何Connection首部字段提名的字段。这样的中继也 <strong>应该(SHOULD)</strong> 移除其它的连接特有首部字段，比如Keep-Alive，Proxy-Connection，Transfer-Encoding，和Upgrade，即使它们没有被Connection首部字段提名。</p>
<p><strong>注意：</strong> HTTP/2自觉地不支持升级到其它协议。<a href="https://http2.github.io/http2-spec/#starting" target="_blank" rel="external">Section 3</a>中描述的握手方法对于协商使用的协议相信足够了。</p>
<h4 id="8-1-2-3-请求的伪首部字段"><a href="#8-1-2-3-请求的伪首部字段" class="headerlink" title="8.1.2.3 请求的伪首部字段"></a><a href="https://http2.github.io/http2-spec/#HttpRequest" target="_blank" rel="external">8.1.2.3 请求的伪首部字段</a></h4><p>下面的伪首部字段是为HTTP/2请求定义的：</p>
<ul>
<li><code>:method</code> 伪首部字段包含HTTP method(<a href="https://http2.github.io/http2-spec/#RFC7231" target="_blank" rel="external">[RFC7231]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#methods" target="_blank" rel="external">Section 4</a>)</li>
</ul>
<ul>
<li><code>:scheme</code> 伪首部字段包含了目标URI (<a href="https://http2.github.io/http2-spec/#RFC3986" target="_blank" rel="external">[RFC3986]
</a>，<a href="https://tools.ietf.org/html/rfc3986#section-3.1" target="_blank" rel="external">Section 3.1</a>) 的scheme部分。</li>
</ul>
<p><code>:scheme</code> 不限于http和https schemed URIs。一个代理或网关可以为非HTTP schemes转换请求，以便于使用HTTP来与非HTTP服务交互。</p>
<ul>
<li><p><code>:authority</code> 伪首部字段包含了目标URI (<a href="https://http2.github.io/http2-spec/#RFC3986" target="_blank" rel="external">[RFC3986]
</a>，<a href="https://tools.ietf.org/html/rfc3986#section-3.1" target="_blank" rel="external">Section 3.1</a>) 的认证部分。<code>authority</code>  <strong>一定不能(MUST NOT)</strong> 给http或https schemed URIs包含废弃的<code>userinfo</code>子组件。要确保HTTP/1.1请求行可以被精确地重现，当从 一个有着 以origin或asterisk的形式 (参见 <a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#request-target" target="_blank" rel="external">Section 5.3</a>) 的请求目标的HTTP/1.1请求转换时，这个伪首部字段 <strong>必须(MUST)</strong> 被省略。直接产生HTTP/2请求的客户端 <strong>应该(SHOULD)</strong> 使用<code>:authority</code> 伪首部字段，而不是Host首部字段。如果请求中没有Host首部字段的话，则将HTTP/2请求转换为HTTP/1.1的中继 <strong>必须(MUST)</strong> 通过复制<code>:authority</code>伪首部字段的值来创建一个。</p>
</li>
<li><p><code>:path</code> 伪首部字段包含了目标URI (完整的路径和一个可选的’?’字符及其后面接着的query) 的path和query部分(参见<a href="https://http2.github.io/http2-spec/#RFC3986" target="_blank" rel="external">[RFC3986]
</a>的 Sections <a href="https://tools.ietf.org/html/rfc3986#section-3.3" target="_blank" rel="external">3.3</a>和<a href="https://tools.ietf.org/html/rfc3986#section-3.4" target="_blank" rel="external">3.4</a>)。星号形式的请求包含了值为’<em>‘的<code>:path</code>伪首部字段。对于http和https URI，这个伪首部字段 <strong>一定不能(MUST NOT)</strong> 是空的。不包含一个path组件的http和https URIs <strong>必须(MUST)</strong> 包含一个’/‘值。这条规则的例外是不包含path组件的http或https URI的OPTIONS请求；这些<strong>必须(MUST)</strong> 包含一个值为’</em>‘的<code>:path</code>伪首部字段(参见<a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#asterisk-form" target="_blank" rel="external">Section 5.3.4</a>)。</p>
</li>
</ul>
<p>所有的HTTP/2请求 <strong>必须(MUST)</strong> 为<code>:method</code>，<code>:scheme</code>和<code>:path</code>伪首部字段包含且只包含一个有效值，除非它是一个CONNECT请求 (<a href="https://http2.github.io/http2-spec/#CONNECT" target="_blank" rel="external">Section 8.3</a>)。一个省略了必须的伪首部字段的HTTP请求是损坏的(<a href="https://http2.github.io/http2-spec/#malformed" target="_blank" rel="external">Section 8.1.2.6</a>)。</p>
<p>HTTP/2没有定义一种方式来携带版本标识符，如同HTTP/1.1的请求行中包含的那样。</p>
<h4 id="8-1-2-4-响应的伪首部字段"><a href="#8-1-2-4-响应的伪首部字段" class="headerlink" title="8.1.2.4 响应的伪首部字段"></a><a href="https://http2.github.io/http2-spec/#HttpResponse" target="_blank" rel="external">8.1.2.4 响应的伪首部字段</a></h4><p>对于HTTP/2响应，<code>:status</code>伪首部字段被定义来携带HTTP状态码字段(参见 <a href="https://http2.github.io/http2-spec/#RFC7231" target="_blank" rel="external">[RFC7231]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#status.codes" target="_blank" rel="external">Section 6</a>)。这个伪首部字段 <strong>必须(MUST)</strong> 被包含在所有的响应中；否则，响应是损坏的 (<a href="https://http2.github.io/http2-spec/#malformed" target="_blank" rel="external">Section 8.1.2.6</a>)。</p>
<p>HTTP/2没有定义一种携带HTTP/1.1的状态行中包含的版本或原因描述的方式。</p>
<h4 id="8-1-2-5-压缩Cookie首部字段"><a href="#8-1-2-5-压缩Cookie首部字段" class="headerlink" title="8.1.2.5 压缩Cookie首部字段"></a><a href="https://http2.github.io/http2-spec/#CompressCookie" target="_blank" rel="external">8.1.2.5 压缩Cookie首部字段</a></h4><p><a href="https://http2.github.io/http2-spec/#COOKIE" target="_blank" rel="external">Cookie首部字段</a> [COOKIE]使用分号(“;”)来分割cookie-pairs (或 “crumbs”)。这个首部字段不遵守HTTP中 列表结构规则 (参见<a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#field.order" target="_blank" rel="external">Section 3.2.2</a>)，那使得cookie-pairs无法被分成不同的名值对。在只有单独的cookie-pairs更新时，这将大大地降低压缩效率</p>
<p>要达到更好的压缩效率，Cookie首部字段 <strong>可以(MAY)</strong> 被分割为分开的首部字段，每个包含一个或多个cookie-pairs。如果解压后有多个Cookie首部字段，则这些首部字段 <strong>必须(MUST)</strong> 在被传递给非HTTP/2上下文，如一个HTTP/1.1连接，或一个普通的HTTP服务应用 之前，使用值为0x3B，0x20的2-字节分隔符 (ASCII字符串”; “) 连接为一个单独字节串。</p>
<p>因此，下面的两个Cookie首部字段列表在语义上是等价的。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cookie: <span class="attr">a=b;</span> <span class="attr">c=d;</span> <span class="attr">e=f</span></div><div class="line"></div><div class="line">cookie: <span class="attr">a=b</span></div><div class="line">cookie: <span class="attr">c=d</span></div><div class="line">cookie: <span class="attr">e=f</span></div></pre></td></tr></table></figure>
<h4 id="8-1-2-6-损坏的请求和响应"><a href="#8-1-2-6-损坏的请求和响应" class="headerlink" title="8.1.2.6 损坏的请求和响应"></a><a href="https://http2.github.io/http2-spec/#malformed" target="_blank" rel="external">8.1.2.6 损坏的请求和响应</a></h4><p>一个损坏的请求或响应，是那种其它方面依然是一个有效的HTTP/2序列，但由于出现了无关的帧，禁用的首部字段，缺失了必要的首部字段，或包含了大写的首部字段名而变得无效的请求或响应。</p>
<p>一个包含载荷体的请求或响应可以包含一个content-length首部字段。如果content-length首部字段的值不等于构成了载荷体的<a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a>帧载荷的长度和的请求或响应也是损坏的。被定义为不含有载荷的响应，在 <a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#header.content-length" target="_blank" rel="external">Section 3.3.2</a> 中描述，可以具有一个非零的content-length首部字段，尽管在 <a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a> 帧不包含内容。</p>
<p>处理HTTP请求或响应的中继 (例如，任何不扮演隧道角色的中继) <strong>一定不能(MUST NOT)</strong> 转发损坏的请求或响应。探测到的损坏的请求或响应 <strong>必须(MUST)</strong> 被作为一个类型是 <a href="https://http2.github.io/http2-spec/#PROTOCOL_ERROR" target="_blank" rel="external">PROTOCOL_ERROR</a> 的流错误 (<a href="https://http2.github.io/http2-spec/#StreamErrorHandler" target="_blank" rel="external">Section 5.4.2</a>)对待。</p>
<p>对于损坏的请求，服务器 <strong>可以(MAY)</strong> 在关闭或重置流之前发送一个HTTP响应。客户端 <strong>一定不能(MUST NOT)</strong> 接受一个损坏的响应。注意，这些要求被用来保护某些常见类型的HTTP攻击；由于许可可能将实现暴露给这些脆弱性，它们有意地比较严格。</p>
<h3 id="8-1-3-例子"><a href="#8-1-3-例子" class="headerlink" title="8.1.3 例子"></a><a href="https://http2.github.io/http2-spec/#rfc.section.8.1.3" target="_blank" rel="external">8.1.3 例子</a></h3><p>这个小节展示了HTTP/1.1的请求和响应，以及等价的HTTP/2请求和相应的描述。</p>
<p>一个HTTP GET请求包含请求首部字段而没有载荷体，因此由一个单独的 <a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a> 帧，后面跟着0个或多个包含请求首部序列化块的<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a> 帧传输。下面的 <a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a> 帧同时设置了END_HEADERS和END_STREAM标记；没有发送<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a> 帧。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /resource HTTP/<span class="number">1.1</span>           HEADERS</div><div class="line">Host: example.<span class="attr">org</span>          ==&gt;     + END_STREAM</div><div class="line">Accept: image/jpeg                 + END_HEADERS</div><div class="line">                                     :<span class="attr">method</span> = GET</div><div class="line">                                     :<span class="attr">scheme</span> = https</div><div class="line">                                     :<span class="attr">path</span> = /resource</div><div class="line">                                     <span class="attr">host</span> = example.org</div><div class="line">                                     <span class="attr">accept</span> = image/jpeg</div></pre></td></tr></table></figure>
<p>类似地，只包含响应首部字段的响应也由一个包含响应首部字段的序列化块的 <a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a> 帧传输 (再一次，后面跟着0个或多个 <a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a> 帧)。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HTTP/<span class="number">1.1</span> <span class="number">304</span> <span class="literal">Not</span> Modified        HEADERS</div><div class="line">ETag: <span class="string">"xyzzy"</span>              ==&gt;     + END_STREAM</div><div class="line">Expires: Thu, <span class="number">23</span> Jan <span class="params">...</span>           + END_HEADERS</div><div class="line">                                     :status = <span class="number">304</span></div><div class="line">                                     etag = <span class="string">"xyzzy"</span></div><div class="line">                                     expires = Thu, <span class="number">23</span> Jan <span class="params">...</span></div></pre></td></tr></table></figure>
<p>一个包含了请求首部字段和载荷数据的HTTP POST请求以一个 <a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a> 帧，后跟包含有请求首部字段的0个或多个 <a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a> 帧，再后面跟着一个或多个<a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a>帧来传输，其中最后的<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a> (或<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>)帧设置了END_HEADERS标记，最后的<a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a>帧设置了END_STREAM标记：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">POST /resource HTTP/<span class="number">1.1</span>          HEADERS</div><div class="line">Host: <span class="built_in">example</span>.org          ==&gt;     - END_STREAM</div><div class="line">Content-Type: <span class="built_in">image</span>/jpeg           - END_HEADERS</div><div class="line">Content-Length: <span class="number">123</span>                  :<span class="built_in">method</span> = POST</div><div class="line">                                     :path = /resource</div><div class="line">&#123;binary data&#125;                        :scheme = https</div><div class="line"></div><div class="line">                                 CONTINUATION</div><div class="line">                                   + END_HEADERS</div><div class="line">                                     <span class="built_in">content</span>-type = <span class="built_in">image</span>/jpeg</div><div class="line">                                     host = <span class="built_in">example</span>.org</div><div class="line">                                     <span class="built_in">content</span>-<span class="built_in">length</span> = <span class="number">123</span></div><div class="line"></div><div class="line">                                 DATA</div><div class="line">                                   + END_STREAM</div><div class="line">                                 &#123;binary data&#125;</div></pre></td></tr></table></figure>
<p>注意任何给定首部字段的数据可以在首部块片段之间传播。这个例子中为帧分配的首部字段只是说明性的。</p>
<p>包含了首部字段和载荷数据的响应以一个<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a> 帧，后跟0个或多个 <a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a> 帧，再后面跟着一个或多个<a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a>帧来传输，其中序列中最后的<a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a>帧设置了END_STREAM标记：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK                  HEADERS</div><div class="line">Content-<span class="keyword">Type</span>: image/jpeg   ==&gt;     - END_STREAM</div><div class="line">Content-Length: <span class="number">123</span>                + END_HEADERS</div><div class="line">                                     :<span class="keyword">status</span> = <span class="number">200</span></div><div class="line">&#123;binary <span class="keyword">data</span>&#125;                        content-<span class="keyword">type</span> = image/jpeg</div><div class="line">                                     content-length = <span class="number">123</span></div><div class="line"></div><div class="line">                                 <span class="keyword">DATA</span></div><div class="line">                                   + END_STREAM</div><div class="line">                                 &#123;binary <span class="keyword">data</span>&#125;</div></pre></td></tr></table></figure>
<p>一个使用非101的1xx状态码的信息性的响应以一个 <a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a> 帧，后跟0个或多个 <a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a> 帧。</p>
<p>在请求或响应的的首部块及所有的<a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a>帧都被发送了之后，以一个首部块发送尾部首部字段。<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>帧启动尾部首部块，设置了END_STREAM标记。</p>
<p>下面的例子包含一个100 (Continue)状态码，作为对一个在Expect首部字段，和尾部首部字段中包含了 “100-continue” token的请求的响应：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">100</span> Continue            HEADERS</div><div class="line"><span class="symbol">Extension</span>-<span class="meta">Field</span>: <span class="keyword">bar </span>      ==&gt;     - END_STREAM</div><div class="line">                                   + END_HEADERS</div><div class="line">                                     :status = <span class="number">100</span></div><div class="line">                                     extension-<span class="meta">field</span> = <span class="keyword">bar</span></div><div class="line"></div><div class="line"><span class="symbol">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">200</span> OK                  HEADERS</div><div class="line"><span class="symbol">Content</span>-Type: image/jpeg   ==&gt;     - END_STREAM</div><div class="line"><span class="symbol">Transfer</span>-Encoding: chunked         + END_HEADERS</div><div class="line"><span class="symbol">Trailer</span>: Foo                         :status = <span class="number">200</span></div><div class="line">                                     content-length = <span class="number">123</span></div><div class="line"><span class="number">123</span>                                  content-type = image/jpeg</div><div class="line">&#123;<span class="keyword">binary </span><span class="meta">data</span>&#125;                        trailer = Foo</div><div class="line"><span class="number">0</span></div><div class="line"><span class="symbol">Foo</span>: <span class="keyword">bar </span>                        <span class="meta">DATA</span></div><div class="line">                                   - END_STREAM</div><div class="line">                                 &#123;<span class="keyword">binary </span><span class="meta">data</span>&#125;</div><div class="line"></div><div class="line">                                 HEADERS</div><div class="line">                                   + END_STREAM</div><div class="line">                                   + END_HEADERS</div><div class="line">                                     foo = <span class="keyword">bar</span></div></pre></td></tr></table></figure>
<h3 id="8-1-4-HTTP-2中的请求可靠性机制"><a href="#8-1-4-HTTP-2中的请求可靠性机制" class="headerlink" title="8.1.4 HTTP/2中的请求可靠性机制"></a><a href="https://http2.github.io/http2-spec/#Reliability" target="_blank" rel="external">8.1.4 HTTP/2中的请求可靠性机制</a></h3><p>在HTTP/1.1中，一个HTTP客户端不能在发生错误时重试一个非幂等的请求，因为没有方式来确定错误的性质。有可能一些服务器在发生错误之前处理了请求，如果重试请求的话，那可能导致不希望看到的结果。</p>
<p>HTTP/2提供两种机制来为客户端提供保证，保证请求还没有被处理：</p>
<ul>
<li><p><a href="https://http2.github.io/http2-spec/#GOAWAY" target="_blank" rel="external">GOAWAY</a> 帧指示了可能已经被处理的最高的流号。因而，流号更高的流上的请求的重试保证是安全的。</p>
</li>
<li><p><a href="https://http2.github.io/http2-spec/#REFUSED_STREAM" target="_blank" rel="external">REFUSED_STREAM</a> 错误码可以被包含进一个 <a href="https://http2.github.io/http2-spec/#RST_STREAM" target="_blank" rel="external">RST_STREAM</a> 帧来表明，流在任何处理发生之前之前被关闭了。在重置的流上发送的任何请求可以被安全地重试。</p>
</li>
</ul>
<p>还没有被处理的请求并没有失败；客户端 <strong>可以(MAY)</strong> 自动地重试它们，即使它们的methods是非幂等的。</p>
<p>除非服务器能作出保证，否则它 <strong>一定不能(MUST NOT)</strong> 表明一个流还没有被处理。对于任何的流，如果流上的帧被传给了应用层，则 <strong>一定不能(MUST NOT)</strong> 再将<a href="https://http2.github.io/http2-spec/#REFUSED_STREAM" target="_blank" rel="external">REFUSED_STREAM</a>用于那个流了，<a href="https://http2.github.io/http2-spec/#GOAWAY" target="_blank" rel="external">GOAWAY</a> 帧 <strong>必须(MUST)</strong> 包含一个大于等于给定流标识符的流标识符。</p>
<p>除了这些机制，<a href="https://http2.github.io/http2-spec/#PING" target="_blank" rel="external">PING</a> 帧给客户端提供了一种方式来简单地测试一个连接。处于闲置状态的连接可能由于一些middleboxes (比如，网络地址转换器，负载均衡器) 安静地废弃了连接绑定而损坏。<a href="https://http2.github.io/http2-spec/#PING" target="_blank" rel="external">PING</a> 帧使得客户端可以在不发送请求的情况下安全地测试一个连接是否有效。</p>
<h2 id="8-2-服务器推送"><a href="#8-2-服务器推送" class="headerlink" title="8.2 服务器推送"></a><a href="https://http2.github.io/http2-spec/#PushResources" target="_blank" rel="external">8.2 服务器推送</a></h2><p>HTTP/2使服务器可以抢先地发送 (或推送) 与客户端之前初始化的请求相关联的响应 (伴随着对应的”promised”请求) 给客户端。当服务器知道客户端将需要那些响应以完全处理最初的请求的响应。</p>
<p>客户端可以请求禁用服务器推送，尽管会为每个独立的hop协商。<a href="https://http2.github.io/http2-spec/#SETTINGS_ENABLE_PUSH" target="_blank" rel="external">SETTINGS_ENABLE_PUSH</a>设置项可以被设置为0以表明服务器推送被禁用。</p>
<p>Promised请求 <strong>必须(MUST)</strong> 是可缓存的 (参见<a href="https://http2.github.io/http2-spec/#RFC7231" target="_blank" rel="external">[RFC7231]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#cacheable.methods" target="_blank" rel="external">Section 4.2.3</a>)， <strong>必须(MUST)</strong> 是安全的(参见 <a href="https://http2.github.io/http2-spec/#RFC7231" target="_blank" rel="external">[RFC7231]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#safe.methods" target="_blank" rel="external">Section 4.2.1</a>)， <strong>一定不能(MUST NOT)</strong> 包含请求体。客户端接收到一个promised请求，但请求不能被缓存，不知道是否安全，或者出现了请求体，必须通过一个类型为<a href="https://http2.github.io/http2-spec/#PROTOCOL_ERROR" target="_blank" rel="external">PROTOCOL_ERROR</a>的流错误(<a href="https://http2.github.io/http2-spec/#StreamErrorHandler" target="_blank" rel="external">Section 5.4.2</a>)来重置promised流。注意如果客户端无法确认一个新定义的method是安全的，则这可能导致promised流被重置。</p>
<p>推送的可缓存的响应 (参见<a href="https://http2.github.io/http2-spec/#RFC7234" target="_blank" rel="external">[RFC7234]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7234.html#response.cacheability" target="_blank" rel="external">Section 3</a>) 可以被客户端保存，如果它实现了一个HTTP缓存的话。推送的响应被认为在原始的服务器上已经被成功地验证过 (比如，如果出现了”no-cache”缓存响应指示(<a href="https://http2.github.io/http2-spec/#RFC7234" target="_blank" rel="external">[RFC7234]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7234.html#cache-response-directive" target="_blank" rel="external">Section 5.2.2</a>)) 了，尽管由promised流ID标识的流依然是打开的。</p>
<p>不能缓存的推送的响应 <strong>一定不能(MUST NOT)</strong> 被任何HTTP缓存保存。它们 <strong>可以(MAY)</strong> 单独提供给应用。</p>
<p>服务器 <strong>必须(MUST)</strong> 在<code>:authority</code>伪首部字段中包含服务器认证授权的值(参见<a href="https://http2.github.io/http2-spec/#authority" target="_blank" rel="external">Section 10.1</a>)。客户端 <strong>必须(MUST)</strong> 将服务器没有认证的 <a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> 当作类型为<a href="https://http2.github.io/http2-spec/#PROTOCOL_ERROR" target="_blank" rel="external">PROTOCOL_ERROR</a>的流错误(<a href="https://http2.github.io/http2-spec/#StreamErrorHandler" target="_blank" rel="external">Section 5.4.2</a>)。</p>
<p>一个中继可从服务器接收推送而选择不把它们转发给客户端。换句话说，如何使用推送的信息由中继自行处理。同样的，服务器在没有采取任何行动的时候，中继也可能选择给客户端创建额外的推送。</p>
<p>客户端不能推送。因此，服务器 <strong>必须(MUST)</strong> 将收到一个 <a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> 帧作为一个类型是 <a href="https://http2.github.io/http2-spec/#PROTOCOL_ERROR" target="_blank" rel="external">PROTOCOL_ERROR</a> 的连接错误 (<a href="https://http2.github.io/http2-spec/#ConnectionErrorHandler" target="_blank" rel="external">Section 5.4.1</a>) 处理。客户端 <strong>必须(MUST)</strong> 拒绝任何试图改变 <a href="https://http2.github.io/http2-spec/#SETTINGS_ENABLE_PUSH" target="_blank" rel="external">SETTINGS_ENABLE_PUSH</a> 设置项为0之外的值的行为，并将其作为一个类型是 <a href="https://http2.github.io/http2-spec/#PROTOCOL_ERROR" target="_blank" rel="external">PROTOCOL_ERROR</a> 的连接错误 (<a href="https://http2.github.io/http2-spec/#ConnectionErrorHandler" target="_blank" rel="external">Section 5.4.1</a>)。</p>
<h3 id="8-2-1-推送请求"><a href="#8-2-1-推送请求" class="headerlink" title="8.2.1 推送请求"></a><a href="https://http2.github.io/http2-spec/#PushRequests" target="_blank" rel="external">8.2.1 推送请求</a></h3><p>服务器推送在语义上与服务器响应一个请求是等价的；然而，在这种情况下，那个请求也会由服务器发送，以 <a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> 帧的形式。</p>
<p><a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> 帧包含一个首部块，其中包含了完整的服务器认为属于请求的请求首部字段集合。不可能推送一个响应给包含请求体的请求。</p>
<p>推送的响应总是与一个来自于客户端的显式的请求关联。服务器发送的<a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> 帧是在那个显式的请求的流上发送的。<a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> 帧还包含一个promised流标识符，从服务器可用的流表示符中选择的 (参见 <a href="https://http2.github.io/http2-spec/#StreamIdentifiers" target="_blank" rel="external">Section 5.1.1</a>)。</p>
<p><a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a>中的首部字段，及任何随后的 <a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a> 帧， <strong>必须(MUST)</strong> 是一个有效的且完整的请求首部字段集 (<a href="https://http2.github.io/http2-spec/#HttpRequest" target="_blank" rel="external">Section 8.1.2.3</a>)。服务器 <strong>必须(MUST)</strong> 在可缓存的且安全的 <code>:method</code> 伪首部字段中包含一个method。如果一个客户端收到了一个<a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a>，但其中不包含一个完整且有效的首部字段集，或 <code>:method</code>伪首部字段描述了一个method但它不是安全的，它 <strong>必须(MUST)</strong> 以一个类型为 <a href="https://http2.github.io/http2-spec/#PROTOCOL_ERROR" target="_blank" rel="external">PROTOCOL_ERROR</a> 的流错误 (<a href="https://http2.github.io/http2-spec/#StreamErrorHandler" target="_blank" rel="external">Section 5.4.2</a>) 作为响应。</p>
<p>服务器 <strong>应该(SHOULD)</strong> 在发送任何引用了promised响应的帧之前发送<a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> (<a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">Section 6.6</a>)帧。这避免了一个竞态，即客户端在接收到任何 <a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> 帧之前发出了请求。</p>
<p>比如，如果服务器收到了一个对一个document的请求，其中包含了多个图片文件的内嵌的链接，服务器选择把那些图片推送给客户端，它在发送包含了图片的链接的<a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a>帧之前发送<a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> 帧，以确保客户端能够在发现内嵌的链接之前知道一份资源将被推送。类似地，如果服务器推送了被首部块引用的响应 (比如，在Link首部字段中)，则在发送首部块之前发送一个 <a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a>，以确保客户端没有清求那些资源。</p>
<p><a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a>帧 <strong>一定不能(MUST NOT)</strong> 由客户端发送。</p>
<p><a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a>帧可以由服务器作为对客户端初始化的任何流的响应而发送，但是流对于服务器 <strong>必须(MUST)</strong> 处于”open”或”half-closed (remote)” 状态。<a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a>穿插在包含响应的帧中，尽管它们不能穿插在包含一个单独的首部块的<a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a>和<a href="https://http2.github.io/http2-spec/#CONTINUATION" target="_blank" rel="external">CONTINUATION</a>帧之间。</p>
<p>发送一个<a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a>帧创建一个新流，并将流置于服务器端的 “reserved (local)” 状态，及客户端的 “reserved (remote)” 状态。</p>
<h3 id="8-2-2-推送响应"><a href="#8-2-2-推送响应" class="headerlink" title="8.2.2 推送响应"></a><a href="https://http2.github.io/http2-spec/#PushResponses" target="_blank" rel="external">8.2.2 推送响应</a></h3><p>发送了<a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a>帧之后，服务器可以开始在一个服务器初始化的使用了promised流标识符的流上传送推送的响应作为一个响应(<a href="https://http2.github.io/http2-spec/#HttpResponse" target="_blank" rel="external">Section 8.1.2.4</a>)了。服务器使用这个流来传输HTTP响应，使用如同在 <a href="https://http2.github.io/http2-spec/#HttpSequence" target="_blank" rel="external">Section 8.1</a> 中定义的相同的帧序列。在初始的 <a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a> 帧发送之后，对于客户端而言这个流变为了”half-closed” (<a href="https://http2.github.io/http2-spec/#StreamStates" target="_blank" rel="external">Section 5.1</a>)。</p>
<p>一旦客户端接收到一个 <a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> 帧并选择接受推送的响应，客户端 <strong>不应该(SHOULD NOT)</strong> 为promised响应发出任何请求直到promised流已经关闭。</p>
<p>如果客户端决定，由于任何原因，它不愿意接收服务器推送的响应，或如果服务器花费了太长时间才开始发送promised响应，客户端可以发送一个 <a href="https://http2.github.io/http2-spec/#RST_STREAM" target="_blank" rel="external">RST_STREAM</a> 帧，使用 <a href="https://http2.github.io/http2-spec/#CANCEL" target="_blank" rel="external">CANCEL</a> 或 <a href="https://http2.github.io/http2-spec/#REFUSED_STREAM" target="_blank" rel="external">REFUSED_STREAM</a> 错误码，并引用推送的流的标识符。</p>
<p>一个客户端使用 <a href="https://http2.github.io/http2-spec/#SETTINGS_MAX_CONCURRENT_STREAMS" target="_blank" rel="external">SETTINGS_MAX_CONCURRENT_STREAMS</a> 设置项来限制服务器可以并发地推送的响应的个数。将<a href="https://http2.github.io/http2-spec/#SETTINGS_MAX_CONCURRENT_STREAMS" target="_blank" rel="external">SETTINGS_MAX_CONCURRENT_STREAMS</a>设置为0值通过阻止服务器创建必要的流来禁用服务器推送。这不禁止服务器发送<a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a> 帧；客户端需要重置任何它不想要的promised流。</p>
<p>客户端接收了一个推送的响应，<strong>必须(MUST)</strong> 验证服务器是否认证 (参见 <a href="https://http2.github.io/http2-spec/#authority" target="_blank" rel="external">Section 10.1</a>)，或提供推送响应的代理为相应的请求做了配置。比如，一个只为 example.com DNS-ID提供了一个证书的服务器，或者Common Name不被允许为 <a href="https://www.example.org/doc" target="_blank" rel="external">https://www.example.org/doc</a> 推送一个响应。</p>
<p><a href="https://http2.github.io/http2-spec/#PUSH_PROMISE" target="_blank" rel="external">PUSH_PROMISE</a>流的响应以一个 <a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a> 帧开始，它立即将服务器端的响应流置于”half-closed (remote)”状态，而将客户端的置于”half-closed (local)”状态，而以一个设置了END_STREAM的帧结束，它将流置于”closed”状态。</p>
<p><strong>注意：</strong> 客户端从不为服务器推送发送设置了END_STREAM标记的帧。</p>
<h2 id="8-3-CONNECT-Method"><a href="#8-3-CONNECT-Method" class="headerlink" title="8.3 CONNECT Method"></a><a href="https://http2.github.io/http2-spec/#CONNECT" target="_blank" rel="external">8.3 CONNECT Method</a></h2><p>在HTTP/1.x，pseudo-method CONNECT (<a href="https://http2.github.io/http2-spec/#RFC7231" target="_blank" rel="external">[RFC7231]</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#CONNECT" target="_blank" rel="external">Section 4.3.6</a>) 被用于将一个HTTP连接转换为一个到远程主机的隧道。CONNECT主要与HTTP代理一起使用，为了与https资源进行交互，而与原始服务器建立一个TLS会话。</p>
<p>在HTTP/2中，为了类似的目的，CONNECT method被用于建立一个到远程的主机的基于单独的HTTP/2流的隧道。HTTP首部字段映射如同<a href="https://http2.github.io/http2-spec/#HttpRequest" target="_blank" rel="external">Section 8.1.2.3</a> (“<a href="https://http2.github.io/http2-spec/#HttpRequest" target="_blank" rel="external">请求的伪首部字段</a>“)中定义的那样工作，但略有不同。特别地：<code>:method</code> 伪首部字段被设置为CONNECT。而<code>:scheme</code> 和 <code>:path</code> 伪首部字段 <strong>必须(MUST)</strong> 被省略。<code>:authority</code> 伪首部字段包含了要连接的主机和端口 (等价于CONNECT请求(参见 <a href="https://http2.github.io/http2-spec/#RFC7230" target="_blank" rel="external">[RFC7230]</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230.html#request-target" target="_blank" rel="external">Section 5.3</a>)的request-target的authority-form)</p>
<p>不符合这些限制的CONNECT请求是损坏的(<a href="https://http2.github.io/http2-spec/#malformed" target="_blank" rel="external">Section 8.1.2.6</a>)。</p>
<p>支持CONNECT的代理建立一个与由<code>:authority</code>伪首部字段确定的服务器的<a href="https://http2.github.io/http2-spec/#TCP" target="_blank" rel="external">TCP connection</a> [TCP]。一旦这个连接被成功地建立了，代理给客户端发送一个 <a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a> 帧，其中包含了2xx系列状态码，如同 <a href="https://http2.github.io/http2-spec/#RFC7231" target="_blank" rel="external">[RFC7231]
</a>，<a href="https://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7231.html#CONNECT" target="_blank" rel="external">Section 4.3.6</a> 中定义的那样。</p>
<p>在每个端点发送了初始的 <a href="https://http2.github.io/http2-spec/#HEADERS" target="_blank" rel="external">HEADERS</a> 帧之后，数据对应的所有后续 <a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a> 帧在那个TCP连接上发送。客户端发送的所有 <a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a> 帧的载荷由代理传输给TCP服务器；从TCP服务器接收的数据由代理汇集为 <a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a> 帧。 <a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a> 和流管理帧(<a href="https://http2.github.io/http2-spec/#RST_STREAM" target="_blank" rel="external">RST_STREAM</a>，<a href="https://http2.github.io/http2-spec/#WINDOW_UPDATE" target="_blank" rel="external">WINDOW_UPDATE</a>，和 <a href="https://http2.github.io/http2-spec/#PRIORITY" target="_blank" rel="external">PRIORITY</a>)之外的其它类型帧 <strong>一定不能(MUST NOT)</strong> 在一个已连接的流上发送，而在出现时 <strong>必须(MUST)</strong> 被当作一个流错误 (<a href="https://http2.github.io/http2-spec/#StreamErrorHandler" target="_blank" rel="external">Section 5.4.2</a>)。</p>
<p>TCP连接可以由连接的任何一端关闭。一个 <a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a> 帧的END_STREAM标记被认为与TCP FIN位一样。客户端在收到一个设置了END_STREAM标记的帧之后，被预期要发送一个设置了END_STREAM标记的 <a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a> 帧。接收到一个设置了END_STREAM标记的 <a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a> 帧的代理，发送在最后的片段上设置FIN位整合数据。接收到一个设置了FIN位的TCP片段的代理发送一个设置了END_STREAM标记的 <a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a> 帧。注意最后的TCP片段或 <a href="https://http2.github.io/http2-spec/#DATA" target="_blank" rel="external">DATA</a> 帧不能是空的。</p>
<p>TCP连接错误用 <a href="https://http2.github.io/http2-spec/#RST_STREAM" target="_blank" rel="external">RST_STREAM</a> 通知。代理将TCP连接中的任何错误，包括接收到一个设置了RST位的TCP片段，作为类型是 <a href="https://http2.github.io/http2-spec/#CONNECT_ERROR" target="_blank" rel="external">CONNECT_ERROR</a> 的流错误 (<a href="https://http2.github.io/http2-spec/#StreamErrorHandler" target="_blank" rel="external">Section 5.4.2</a>)。相应的，如果探测到流或HTTP/2连接的错误，则代理 <strong>必须(MUST)</strong> 发送一个设置了RST位的TCP片段。</p>
</div><div class="tags"><a href="/tags/网络协议/">网络协议</a><a href="/tags/HTTP2/">HTTP2</a></div><div class="post-nav"><a href="/2016/10/29/9-zh-cn/" class="pre">HTTP/2规范：9. 额外的HTTP要求/注意事项</a><a href="/2016/10/29/7-zh-cn/" class="next">HTTP/2规范：7. 错误码</a></div><div id="disqus_thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-图形系统/">Android 图形系统</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发/">Android开发</a><span class="category-list-count">29</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-开发/">C/C++开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java开发/">Java开发</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核/">Linux内核</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/live555/">live555</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/业界趣闻/">业界趣闻</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/云计算/">云计算</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台开发/">后台开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络调试/">网络调试</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随想杂谈/">随想杂谈</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频开发/">音视频开发</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/UDT/" style="font-size: 15px;">UDT</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/Android开发/" style="font-size: 15px;">Android开发</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/chromium/" style="font-size: 15px;">chromium</a> <a href="/tags/后台开发/" style="font-size: 15px;">后台开发</a> <a href="/tags/Java开发/" style="font-size: 15px;">Java开发</a> <a href="/tags/QUIC/" style="font-size: 15px;">QUIC</a> <a href="/tags/网络调试/" style="font-size: 15px;">网络调试</a> <a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/HTTP2/" style="font-size: 15px;">HTTP2</a> <a href="/tags/图形图像/" style="font-size: 15px;">图形图像</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/C-C-开发/" style="font-size: 15px;">C/C++开发</a> <a href="/tags/音视频开发/" style="font-size: 15px;">音视频开发</a> <a href="/tags/Linux内核/" style="font-size: 15px;">Linux内核</a> <a href="/tags/live555/" style="font-size: 15px;">live555</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Go-语言/" style="font-size: 15px;">Go 语言</a> <a href="/tags/云计算/" style="font-size: 15px;">云计算</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">二月 2013</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/06/anbox_lxc/">Anbox LXC</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/lxc_c_api_usage/">LXC C API 使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/04/ubuntu_lxc/">Ubuntu LXC</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/01/anbox_container_manager_service/">Anbox 容器管理服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/run_anbox/">运行 Anbox</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/Anbox/">Anbox</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/24/gerrit_codereview/">Gerrit代码审核服务器搭建全过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/20/adb_overview/">关于 ADB 实现的说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/adb-standalone/">adb standalone</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/qcow2_on_linux/">在 Linux 上如何挂载 qcow2 磁盘镜像</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="https://source.android.com/" title="Android Open Source Project" target="_blank">Android Open Source Project</a><ul></ul><a href="http://www.vants.org/" title="蚂蚁网" target="_blank">蚂蚁网</a></div><div class="widget"><div class="widget-title"><i class="fa fa-commt"> 最近评论</i></div><script type="text/javascript" src="//wolfcstech.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.2.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:hanpfei@gmail.com" target="_blank" class="fa fa-email"> </a><a href="undefined" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/hanpfei" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">Han Pengfei</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var disqus_shortname = 'wolfcstech';
var disqus_identifier = '2016/10/29/8-zh-cn/';
var disqus_title = 'HTTP/2规范：8. HTTP消息交换';
var disqus_url = 'https://www.wolfcstech.com/2016/10/29/8-zh-cn/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wolfcstech.disqus.com/count.js" async></script><script type="text/javascript" src="/js/search.json.js?v=1.2.0"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-109419024-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3c736b12c32c019fd9ff6c825b6b9b44";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></body></html>