<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>UDT协议实现分析——数据的发送 | WolfcsTech</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.2.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.2.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">UDT协议实现分析——数据的发送</h1><a id="logo" href="/.">WolfcsTech</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">UDT协议实现分析——数据的发送</h1><div class="post-meta">Sep 14, 2015<span> | </span><span class="category"><a href="/categories/网络协议/">网络协议</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2015/09/14/UDT协议实现分析——数据的发送/" href="/2015/09/14/UDT协议实现分析——数据的发送/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>连接建立起来之后，我们就可以通过UDT Socket进行数据的收发了。先来看用来发送数据的几个函数。UDT提供了如下的几个函数用于不同目的下的数据发送：<br><a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">UDT_API <span class="keyword">int</span> <span class="title">send</span><span class="params">(UDTSOCKET u, <span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</div><div class="line"></div><div class="line"><span class="function">UDT_API <span class="keyword">int</span> <span class="title">sendmsg</span><span class="params">(UDTSOCKET u, <span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> ttl = <span class="number">-1</span>, <span class="keyword">bool</span> inorder = <span class="literal">false</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function">UDT_API int64_t <span class="title">sendfile</span><span class="params">(UDTSOCKET u, <span class="built_in">std</span>::fstream&amp; ifs, <span class="keyword">int64_t</span>&amp; offset, <span class="keyword">int64_t</span> size, <span class="keyword">int</span> block = <span class="number">364000</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function">UDT_API int64_t <span class="title">sendfile2</span><span class="params">(UDTSOCKET u, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int64_t</span>* offset, <span class="keyword">int64_t</span> size, <span class="keyword">int</span> block = <span class="number">364000</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>send()用来进行流式的数据发送；sendmsg()用来进行数据报式的数据发送；sendfile()与sendfile2()用来执行文件的发送，流式发送，这两者基本一样，仅有的差异在于，前者接收文件的流来发送，而后者则接收文件的路径。</p>
<h1 id="UDT-sendmsg"><a href="#UDT-sendmsg" class="headerlink" title="UDT sendmsg()"></a>UDT sendmsg()</h1><p>这里先来看UDT::sendmsg()：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CUDT::sendmsg(UDTSOCKET u, <span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> ttl, <span class="keyword">bool</span> inorder) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        CUDT* udt = s_UDTUnited.lookup(u);</div><div class="line">        <span class="keyword">return</span> udt-&gt;sendmsg(buf, len, ttl, inorder);</div><div class="line">    &#125; <span class="keyword">catch</span> (CUDTException &amp;e) &#123;</div><div class="line">        s_UDTUnited.setError(<span class="keyword">new</span> CUDTException(e));</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125; <span class="keyword">catch</span> (bad_alloc&amp;) &#123;</div><div class="line">        s_UDTUnited.setError(<span class="keyword">new</span> CUDTException(<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>));</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">        s_UDTUnited.setError(<span class="keyword">new</span> CUDTException(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>));</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> sendmsg(UDTSOCKET u, <span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> ttl, <span class="keyword">bool</span> inorder) &#123;</div><div class="line">    <span class="keyword">return</span> CUDT::sendmsg(u, buf, len, ttl, inorder);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个API的实现结构与之前看到的listen()、bind()这些略微有点区别，在CUDT的API层，会调用CUDT 对应的实现函数，调用过程：UDT::sendmsg() -&gt; CUDT::sendmsg(UDTSOCKET u, const char<em> buf, int len, int ttl, bool inorder) -&gt; CUDT::sendmsg(const char</em> data, int len, int msttl, bool inorder)。直接来看CUDT::sendmsg(const char* data, int len, int msttl, bool inorder)(src/core.cpp)：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">void CUDT::waitBlockingSending(<span class="keyword">int</span> space) &#123;</div><div class="line">    <span class="keyword">if</span> (!m_bSynSending)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// wait here during a blocking sending</span></div><div class="line"><span class="comment">#ifndef WIN32</span></div><div class="line">        pthread_mutex_lock(&amp;m_SendBlockLock);</div><div class="line">        <span class="keyword">if</span> (m_iSndTimeOut &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">while</span> (!m_bBroken &amp;&amp; m_bConnected &amp;&amp; !m_bClosing</div><div class="line">                    &amp;&amp; ((m_iSndBufSize - m_pSndBuffer-&gt;getCurrBufSize()) * m_iPayloadSize &lt; space) &amp;&amp; m_bPeerHealth)</div><div class="line">                pthread_cond_wait(&amp;m_SendBlockCond, &amp;m_SendBlockLock);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            uint64_t exptime = CTimer::getTime() + m_iSndTimeOut * <span class="number">1000</span>ULL;</div><div class="line">            timespec locktime;</div><div class="line"></div><div class="line">            locktime.tv_sec = exptime / <span class="number">1000000</span>;</div><div class="line">            locktime.tv_nsec = (exptime % <span class="number">1000000</span>) * <span class="number">1000</span>;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (!m_bBroken &amp;&amp; m_bConnected &amp;&amp; !m_bClosing</div><div class="line">                    &amp;&amp; ((m_iSndBufSize - m_pSndBuffer-&gt;getCurrBufSize()) * m_iPayloadSize &lt; space) &amp;&amp; m_bPeerHealth</div><div class="line">                    &amp;&amp; (CTimer::getTime() &lt; exptime))</div><div class="line">                pthread_cond_timedwait(&amp;m_SendBlockCond, &amp;m_SendBlockLock, &amp;locktime);</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_unlock(&amp;m_SendBlockLock);</div><div class="line"><span class="comment">#else</span></div><div class="line">        <span class="keyword">if</span> (m_iSndTimeOut &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">while</span> (!m_bBroken &amp;&amp; m_bConnected &amp;&amp; !m_bClosing</div><div class="line">                    &amp;&amp; ((m_iSndBufSize - m_pSndBuffer-&gt;getCurrBufSize()) * m_iPayloadSize &lt; space) &amp;&amp; m_bPeerHealth)</div><div class="line">                WaitForSingleObject(m_SendBlockCond, INFINITE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            uint64_t exptime = CTimer::getTime() + m_iSndTimeOut * <span class="number">1000</span>ULL;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (!m_bBroken &amp;&amp; m_bConnected &amp;&amp; !m_bClosing</div><div class="line">                    &amp;&amp; ((m_iSndBufSize - m_pSndBuffer-&gt;getCurrBufSize()) * m_iPayloadSize &lt; space) &amp;&amp; m_bPeerHealth</div><div class="line">                    &amp;&amp; (CTimer::getTime() &lt; exptime))</div><div class="line">                WaitForSingleObject(m_SendBlockCond, DWORD((exptime - CTimer::getTime()) / <span class="number">1000</span>));</div><div class="line">        &#125;</div><div class="line"><span class="comment">#endif</span></div><div class="line"></div><div class="line">        <span class="comment">// check the connection status</span></div><div class="line">        <span class="keyword">if</span> (m_bBroken || m_bClosing)</div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!m_bConnected)</div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!m_bPeerHealth) &#123;</div><div class="line">            m_bPeerHealth = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">7</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> CUDT::sendmsg(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span> msttl, <span class="keyword">bool</span> inorder) &#123;</div><div class="line">    <span class="keyword">if</span> (UDT_STREAM == m_iSockType)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// throw an exception if not connected</span></div><div class="line">    <span class="keyword">if</span> (m_bBroken || m_bClosing)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!m_bConnected)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (len &gt; m_iSndBufSize * m_iPayloadSize)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">12</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    CGuard sendguard(m_SendLock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_pSndBuffer-&gt;getCurrBufSize() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// delay the EXP timer to avoid mis-fired timeout</span></div><div class="line">        uint64_t currtime;</div><div class="line">        CTimer::rdtsc(currtime);</div><div class="line">        m_ullLastRspTime = currtime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((m_iSndBufSize - m_pSndBuffer-&gt;getCurrBufSize()) * m_iPayloadSize &lt; len) &#123;</div><div class="line">        waitBlockingSending(len);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((m_iSndBufSize - m_pSndBuffer-&gt;getCurrBufSize()) * m_iPayloadSize &lt; len) &#123;</div><div class="line">        <span class="keyword">if</span> (m_iSndTimeOut &gt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// record total time used for sending</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_pSndBuffer-&gt;getCurrBufSize())</div><div class="line">        m_llSndDurationCounter = CTimer::getTime();</div><div class="line"></div><div class="line">    <span class="comment">// insert the user buffer into the sening list</span></div><div class="line">    m_pSndBuffer-&gt;addBuffer(data, len, msttl, inorder);</div><div class="line"></div><div class="line">    <span class="comment">// insert this socket to the snd list if it is not on the list yet</span></div><div class="line">    m_pSndQueue-&gt;m_pSndUList-&gt;update(this, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_iSndBufSize &lt;= m_pSndBuffer-&gt;getCurrBufSize()) &#123;</div><div class="line">        <span class="comment">// write is not available any more</span></div><div class="line">        s_UDTUnited.m_EPoll.update_events(m_SocketID, m_sPollID, UDT_EPOLL_OUT, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CUDT::sendmsg()主要做了如下这样的一些事情：</p>
<ol>
<li><p>检查UDT Socket的类型SockType，若为UDT_STREAM则直接抛异常退出，否则继续执行。</p>
</li>
<li><p>检查CUDT的状态，若UDT Socket不处于Connected状态，就抛异常退出，否则继续执行。</p>
</li>
<li><p>检查传入的参数，主要是数据的长度，既不能太大也不能太小。数据长度太小是指，小于等于0；太大是指，超出了CUDT发送缓冲区的最大大小。若参数无效，就返回，否则继续执行。在默认不通过UDT::setsockopt()修改m_iSndBufSize和m_iMSS这些选项的情况下，m_iSndBufSize为8192，m_iPayloadSize为1456，也就是大概12MB。</p>
</li>
<li><p>当CUDT发送缓冲区的已用大小为0时，会将m_ullLastRspTime更新为当前时间。</p>
</li>
<li><p>检查CUDT发送缓冲区中可用大小，若可用大小不足消息的长度时，执行waitBlockingSending()等待有足够大小可用。在waitBlockingSending()中可以看到，它主要处理了这样3中情况：</p>
</li>
</ol>
<p>(1). UDT Socket不是处于同步发送模式。抛异常，结束发送的整个流程。</p>
<p>(2). 发送的超时时间m_iSndTimeOut为一个小于0的无效值，则永久等待，直到UDT Socket被关掉。</p>
<p>(3). 发送的超时时间m_iSndTimeOut为一个大于等于0的有效值，则等待m_iSndTimeOut个ms或UDT Socket被关闭。在CUDT的构造函数中，iSndTimeOut默认是被设置为-1的，但可以通过UDT::setsockopt()进行设置。</p>
<p>对于后两种情况里，若等待过程是由于CUDT状态变得无效而终止，则还将抛出异常以结束发送过程。</p>
<ol>
<li>检查CUDT发送缓冲区中可用大小，若可用大小不足消息的长度时，则说明waitBlockingSending()可能是因如下的几种情况中的一种出现而结束：</li>
</ol>
<p>(1). CUDT处于非同步发送模式而直接结束。</p>
<p>(2). CUDT处于同步模式，m_iSndTimeOut为一个有效值，但超市时间到来时仍然没有等到发送缓冲区中有足够的空间。</p>
<p>对于第一种情况的处理是直接返回0。对于第二种情况的处理则是抛出异常。waitBlockingSending()等待过程终结由于UDT Socket而造成的情况，waitBlockingSending()自己会抛出异常的，而不会走到这一步。</p>
<ol>
<li><p>当发送缓冲区的已用大小为0时，更新m_llSndDurationCounter为当前时间。</p>
</li>
<li><p>执行m_pSndBuffer-&gt;addBuffer(data, len, msttl, inorder)将要发送的数据放入发送缓冲区。</p>
</li>
<li><p>将这个socket加入发送队列SndQueue的发送列表m_pSndUList中。</p>
</li>
<li><p>返回数据长度，也即发送的数据长度。</p>
</li>
</ol>
<p>这也是一个生产与消费的故事。在这里发起发送的线程为生产者，真正将数据发送到网络上的的发送队列RcvQueue的worker线程则为消费者。在UDT::sendmsg()的执行过程中，我们同样只能看到这个故事的一半，生产的那一半。后面会再来分析故事的另一半。</p>
<h1 id="UDT-send"><a href="#UDT-send" class="headerlink" title="UDT send()"></a>UDT send()</h1><p>然后来看UDT::send()(src/api.cpp)：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CUDT::send(UDTSOCKET u, <span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> len, <span class="keyword">int</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        CUDT* udt = s_UDTUnited.lookup(u);</div><div class="line">        <span class="keyword">return</span> udt-&gt;send(buf, len);</div><div class="line">    &#125; <span class="keyword">catch</span> (CUDTException &amp;e) &#123;</div><div class="line">        s_UDTUnited.setError(<span class="keyword">new</span> CUDTException(e));</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125; <span class="keyword">catch</span> (bad_alloc&amp;) &#123;</div><div class="line">        s_UDTUnited.setError(<span class="keyword">new</span> CUDTException(<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>));</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">        s_UDTUnited.setError(<span class="keyword">new</span> CUDTException(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>));</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(UDTSOCKET u, <span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> CUDT::send(u, buf, len, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用用过程：UDT::send() -&gt; CUDT::send(UDTSOCKET u, const char<em> buf, int len, int) -&gt; CUDT::send(const char</em> data, int len)。直接来看CUDT::send(const char* data, int len)(src/core.cpp)：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CUDT::send(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">int</span> len) &#123;</div><div class="line">    <span class="keyword">if</span> (UDT_DGRAM == m_iSockType)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">10</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// throw an exception if not connected</span></div><div class="line">    <span class="keyword">if</span> (m_bBroken || m_bClosing)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!m_bConnected)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    CGuard sendguard(m_SendLock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_pSndBuffer-&gt;getCurrBufSize() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// delay the EXP timer to avoid mis-fired timeout</span></div><div class="line">        uint64_t currtime;</div><div class="line">        CTimer::rdtsc(currtime);</div><div class="line">        m_ullLastRspTime = currtime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_iSndBufSize &lt;= m_pSndBuffer-&gt;getCurrBufSize()) &#123;</div><div class="line">        waitBlockingSending(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_iSndBufSize &lt;= m_pSndBuffer-&gt;getCurrBufSize()) &#123;</div><div class="line">        <span class="keyword">if</span> (m_iSndTimeOut &gt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> size = (m_iSndBufSize - m_pSndBuffer-&gt;getCurrBufSize()) * m_iPayloadSize;</div><div class="line">    <span class="keyword">if</span> (size &gt; len)</div><div class="line">        size = len;</div><div class="line"></div><div class="line">    <span class="comment">// record total time used for sending</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_pSndBuffer-&gt;getCurrBufSize())</div><div class="line">        m_llSndDurationCounter = CTimer::getTime();</div><div class="line"></div><div class="line">    <span class="comment">// insert the user buffer into the sening list</span></div><div class="line">    m_pSndBuffer-&gt;addBuffer(data, size);</div><div class="line"></div><div class="line">    <span class="comment">// insert this socket to snd list if it is not on the list yet</span></div><div class="line">    m_pSndQueue-&gt;m_pSndUList-&gt;update(this, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_iSndBufSize &lt;= m_pSndBuffer-&gt;getCurrBufSize()) &#123;</div><div class="line">        <span class="comment">// write is not available any more</span></div><div class="line">        s_UDTUnited.m_EPoll.update_events(m_SocketID, m_sPollID, UDT_EPOLL_OUT, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数与CUDT::sendmsg(const char* data, int len, int msttl, bool inorder)的执行过程极为相似，但还是有如下这样的一些区别：</p>
<ol>
<li><p>这个函数的执行要求UDT Socket的类型必须为UDT_STREAM，而不是UDT_DGRAM，这一点与CUDT::sendmsg()正好相反。</p>
</li>
<li><p>要发送的数据的长度，只要大于0就可以了。而在CUDT::sendmsg()中会限制要发送的数据的大小不能超过发送缓冲区的最大大小。</p>
</li>
<li><p>在CUDT::sendmsg()中对数据发送的规则执行的是，要么全部发送，要么一点也不发送。而在这里则是，只要发送缓冲区还没有满，则会将数据尽可能多的加进发送缓冲区以待发送。</p>
</li>
</ol>
<p>其它则完全一样。</p>
<h1 id="发送缓冲区CSndBuffer"><a href="#发送缓冲区CSndBuffer" class="headerlink" title="发送缓冲区CSndBuffer"></a>发送缓冲区CSndBuffer</h1><p>来看一下CUDT中用来管理待发送数据的发送缓冲区CSndBuffer，先来看它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CSndBuffer &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    CSndBuffer(<span class="keyword">int</span> size = <span class="number">32</span>, <span class="keyword">int</span> mss = <span class="number">1500</span>);</div><div class="line">    ~CSndBuffer();</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Insert a user buffer into the sending list.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    0) [in] data: pointer to the user data block.</span></div><div class="line">    <span class="comment">//    1) [in] len: size of the block.</span></div><div class="line">    <span class="comment">//    2) [in] ttl: time to live in milliseconds</span></div><div class="line">    <span class="comment">//    3) [in] order: if the block should be delivered in order, for DGRAM only</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBuffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span> ttl = <span class="number">-1</span>, <span class="keyword">bool</span> order = <span class="literal">false</span>)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Read a block of data from file and insert it into the sending list.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    0) [in] ifs: input file stream.</span></div><div class="line">    <span class="comment">//    1) [in] len: size of the block.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    actual size of data added from the file.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addBufferFromFile</span><span class="params">(<span class="built_in">std</span>::fstream&amp; ifs, <span class="keyword">int</span> len)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Find data position to pack a DATA packet from the furthest reading point.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    0) [out] data: the pointer to the data position.</span></div><div class="line">    <span class="comment">//    1) [out] msgno: message number of the packet.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    Actual length of data read.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readData</span><span class="params">(<span class="keyword">char</span>** data, <span class="keyword">int32_t</span>&amp; msgno)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Find data position to pack a DATA packet for a retransmission.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    0) [out] data: the pointer to the data position.</span></div><div class="line">    <span class="comment">//    1) [in] offset: offset from the last ACK point.</span></div><div class="line">    <span class="comment">//    2) [out] msgno: message number of the packet.</span></div><div class="line">    <span class="comment">//    3) [out] msglen: length of the message</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    Actual length of data read.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readData</span><span class="params">(<span class="keyword">char</span>** data, <span class="keyword">const</span> <span class="keyword">int</span> offset, <span class="keyword">int32_t</span>&amp; msgno, <span class="keyword">int</span>&amp; msglen)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Update the ACK point and may release/unmap/return the user data according to the flag.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    0) [in] offset: number of packets acknowledged.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ackData</span><span class="params">(<span class="keyword">int</span> offset)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Read size of data still in the sending list.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    Current size of the data in the sending list.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCurrBufSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">pthread_mutex_t</span> m_BufLock;           <span class="comment">// used to synchronize buffer operation</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span> Block &#123;</div><div class="line">        <span class="keyword">char</span>* m_pcData;                   <span class="comment">// pointer to the data block</span></div><div class="line">        <span class="keyword">int</span> m_iLength;                    <span class="comment">// length of the block</span></div><div class="line"></div><div class="line">        <span class="keyword">int32_t</span> m_iMsgNo;                 <span class="comment">// message number</span></div><div class="line">        <span class="keyword">uint64_t</span> m_OriginTime;            <span class="comment">// original request time</span></div><div class="line">        <span class="keyword">int</span> m_iTTL;                       <span class="comment">// time to live (milliseconds)</span></div><div class="line"></div><div class="line">        Block* m_pNext;                   <span class="comment">// next block</span></div><div class="line">    &#125;*m_pBlock, *m_pFirstBlock, *m_pCurrBlock, *m_pLastBlock;</div><div class="line"></div><div class="line">    <span class="comment">// m_pBlock:         The head pointer</span></div><div class="line">    <span class="comment">// m_pFirstBlock:    The first block</span></div><div class="line">    <span class="comment">// m_pCurrBlock:	The current block</span></div><div class="line">    <span class="comment">// m_pLastBlock:     The last block (if first == last, buffer is empty)</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span> Buffer &#123;</div><div class="line">        <span class="keyword">char</span>* m_pcData;			<span class="comment">// buffer</span></div><div class="line">        <span class="keyword">int</span> m_iSize;			<span class="comment">// size</span></div><div class="line">        Buffer* m_pNext;			<span class="comment">// next buffer</span></div><div class="line">    &#125;*m_pBuffer;			<span class="comment">// physical buffer</span></div><div class="line"></div><div class="line">    <span class="keyword">int32_t</span> m_iNextMsgNo;                <span class="comment">// next message number</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> m_iSize;				<span class="comment">// buffer size (number of packets)</span></div><div class="line">    <span class="keyword">int</span> m_iMSS;                          <span class="comment">// maximum seqment/packet size</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> m_iCount;			<span class="comment">// number of used blocks</span></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">    CSndBuffer(<span class="keyword">const</span> CSndBuffer&amp;);</div><div class="line">    CSndBuffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CSndBuffer&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在这个结构中，似乎在用几个单链表来管理发送缓冲区的数据存储区，struct Buffer的链表，和struct Block的链表，但这些结构究竟如何组织，每个链表的意义是什么，还是要看下几个成员函数的定义。首先是构造函数：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">CSndBuffer::CSndBuffer(<span class="keyword">int</span> size, <span class="keyword">int</span> mss)</div><div class="line">        : m_BufLock(),</div><div class="line">          m_pBlock(<span class="keyword">NULL</span>),</div><div class="line">          m_pFirstBlock(<span class="keyword">NULL</span>),</div><div class="line">          m_pCurrBlock(<span class="keyword">NULL</span>),</div><div class="line">          m_pLastBlock(<span class="keyword">NULL</span>),</div><div class="line">          m_pBuffer(<span class="keyword">NULL</span>),</div><div class="line">          m_iNextMsgNo(<span class="number">1</span>),</div><div class="line">          m_iSize(size),</div><div class="line">          m_iMSS(mss),</div><div class="line">          m_iCount(<span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// initial physical buffer of "size"</span></div><div class="line">    m_pBuffer = <span class="keyword">new</span> Buffer;</div><div class="line">    m_pBuffer-&gt;m_pcData = <span class="keyword">new</span> <span class="keyword">char</span>[m_iSize * m_iMSS];</div><div class="line">    m_pBuffer-&gt;m_iSize = m_iSize;</div><div class="line">    m_pBuffer-&gt;m_pNext = <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// circular linked list for out bound packets</span></div><div class="line">    m_pBlock = <span class="keyword">new</span> Block;</div><div class="line">    Block* pb = m_pBlock;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m_iSize; ++i) &#123;</div><div class="line">        pb-&gt;m_pNext = <span class="keyword">new</span> Block;</div><div class="line">        pb-&gt;m_iMsgNo = <span class="number">0</span>;</div><div class="line">        pb = pb-&gt;m_pNext;</div><div class="line">    &#125;</div><div class="line">    pb-&gt;m_pNext = m_pBlock;</div><div class="line"></div><div class="line">    pb = m_pBlock;</div><div class="line">    <span class="keyword">char</span>* pc = m_pBuffer-&gt;m_pcData;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_iSize; ++i) &#123;</div><div class="line">        pb-&gt;m_pcData = pc;</div><div class="line">        pb = pb-&gt;m_pNext;</div><div class="line">        pc += m_iMSS;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_pFirstBlock = m_pCurrBlock = m_pLastBlock = m_pBlock;</div><div class="line"></div><div class="line"><span class="comment">#ifndef WIN32</span></div><div class="line">    pthread_mutex_init(&amp;m_BufLock, <span class="keyword">NULL</span>);</div><div class="line"><span class="comment">#else</span></div><div class="line">    m_BufLock = CreateMutex(<span class="keyword">NULL</span>, <span class="keyword">false</span>, <span class="keyword">NULL</span>);</div><div class="line"><span class="comment">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个构造函数中会做如下这样一些事情：</p>
<ol>
<li>在成员初始化列表中初始化所有的成员变量。注意，m_iNextMsgNo被初始化为了1，表示已用blocks数量的m_iCount被初始化为了0。</li>
</ol>
<p>初始化物理buffer，即分配一个Buffer结构m_pBuffer，为这个Buffer结构分配一块大小为m_iSize * m_iMSS的内存，初始化Buffer结构的m_iSize为m_iSize。m_iSize和m_iMSS的值来自于传入的两个参数size和mss。在connect成功(无论是主动发起连接的UDT Socket，还是由Listening的UDT Socket创建的都一样)，创建CSndBuffer时，size值为32，而mss值为m_iPayloadSize。在前面 UDT协议实现分析——连接的建立 一文中我们有仔细地分析过m_iPayloadSize这个值的计算过程。</p>
<ol>
<li><p>创建一个Block结构的循环链表，m_pBlock指向链表头。链表的长度同样为m_iSize，也就是32。</p>
</li>
<li><p>初始化前一步创建的链表。使每个Block结构的m_pcData指向m_pBuffer-&gt;m_pcData的不同位置，相邻的两个Block结构，所指位置的距离为m_iMSS。</p>
</li>
</ol>
<p>由此不难猜测，Buffer用于实际保存要发送的数据。而Block结构则用于将Buffer的数据缓冲区分段管理。</p>
<ol>
<li><p>将m_pFirstBlock、m_pCurrBlock和m_pLastBlock的值都初始化为m_pBlock的值。</p>
</li>
<li><p>初始化用于同步缓冲区操作的m_BufLock。</p>
</li>
</ol>
<p>这里我们弄清了struct Buffer和struct Block，但还是有许多问题还没有弄清楚。m_pBlock，m_pFirstBlock，m_pCurrBlock和m_pLastBlock这几个指针的含义是什么？struct Buffer链表的扩展与收缩，MsgNo的意义等。</p>
<p>接着就来看一下CSndBuffer的其它一些成员函数。来看向CSndBuffer中添加数据的CSndBuffer::addBuffer()：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">void CSndBuffer::addBuffer(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span> ttl, <span class="keyword">bool</span> order) &#123;</div><div class="line">    <span class="keyword">int</span> size = len / m_iMSS;</div><div class="line">    <span class="keyword">if</span> ((len % m_iMSS) != <span class="number">0</span>)</div><div class="line">        size++;</div><div class="line"></div><div class="line">    <span class="comment">// dynamically increase sender buffer</span></div><div class="line">    <span class="keyword">while</span> (size + m_iCount &gt;= m_iSize)</div><div class="line">        increase();</div><div class="line"></div><div class="line">    uint64_t time = CTimer::getTime();</div><div class="line">    int32_t inorder = order;</div><div class="line">    inorder &lt;&lt;= <span class="number">29</span>;</div><div class="line"></div><div class="line">    Block* s = m_pLastBlock;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">        <span class="keyword">int</span> pktlen = len - i * m_iMSS;</div><div class="line">        <span class="keyword">if</span> (pktlen &gt; m_iMSS)</div><div class="line">            pktlen = m_iMSS;</div><div class="line"></div><div class="line">        memcpy(s-&gt;m_pcData, data + i * m_iMSS, pktlen);</div><div class="line">        s-&gt;m_iLength = pktlen;</div><div class="line"></div><div class="line">        s-&gt;m_iMsgNo = m_iNextMsgNo | inorder;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">            s-&gt;m_iMsgNo |= <span class="number">0x80000000</span>;</div><div class="line">        <span class="keyword">if</span> (i == size - <span class="number">1</span>)</div><div class="line">            s-&gt;m_iMsgNo |= <span class="number">0x40000000</span>;</div><div class="line"></div><div class="line">        s-&gt;m_OriginTime = time;</div><div class="line">        s-&gt;m_iTTL = ttl;</div><div class="line"></div><div class="line">        s = s-&gt;m_pNext;</div><div class="line">    &#125;</div><div class="line">    m_pLastBlock = s;</div><div class="line"></div><div class="line">    CGuard::enterCS(m_BufLock);</div><div class="line">    m_iCount += size;</div><div class="line">    CGuard::leaveCS(m_BufLock);</div><div class="line"></div><div class="line">    m_iNextMsgNo++;</div><div class="line">    <span class="keyword">if</span> (m_iNextMsgNo == CMsgNo::m_iMaxMsgNo)</div><div class="line">        m_iNextMsgNo = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的执行过程大体如下：</p>
<ol>
<li><p>向CSndBuffer中添加数据总是以整块Block为单位的，对于最后不满整块Block的数据仍然占用整块Block。在这个函数中做的第一件事情就是，计算添加所有的数据需要的Block的个数。</p>
</li>
<li><p>如果CSndBuffer中的可用空间不足，则扩展CSndBuffer空间的大小，直到能满足添加的数据的需求为止。</p>
</li>
<li><p>计算inorder。</p>
</li>
<li><p>通过一个循环将数据复制到CSndBuffer中。</p>
</li>
</ol>
<p>在这段code中，我们不难想到m_pLastBlock指向的是最后一块已用Block之后的那块Block。</p>
<p>关于UDT的Msg，Msg指的是一次UDT::send()或UDT::sendmsg()所发的全部数据。一个Msg中所有的Block共用了相同的一个m_iNextMsgNo。</p>
<p>这里可以看到UDT中Msg的开始与结束的表示方法：Block的m_iMsgNo的最高两位被用来指示Msg的开始和结束，最高位为1表示Msg的开始，第二高位为1则表示Msg的结束。</p>
<ol>
<li><p>更新表示一用Block数的m_iCount。</p>
</li>
<li><p>更新m_iNextMsgNo，达到最大值时会重新回到1。</p>
</li>
</ol>
<p>再来看一个与CSndBuffer::addBuffer()类似的函数CSndBuffer::addBufferFromFile()：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CSndBuffer::addBufferFromFile(fstream&amp; ifs, <span class="keyword">int</span> len) &#123;</div><div class="line">    <span class="keyword">int</span> size = len / m_iMSS;</div><div class="line">    <span class="keyword">if</span> ((len % m_iMSS) != <span class="number">0</span>)</div><div class="line">        size++;</div><div class="line"></div><div class="line">    <span class="comment">// dynamically increase sender buffer</span></div><div class="line">    <span class="keyword">while</span> (size + m_iCount &gt;= m_iSize)</div><div class="line">        increase();</div><div class="line"></div><div class="line">    Block* s = m_pLastBlock;</div><div class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (ifs.bad() || ifs.fail() || ifs.eof())</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> pktlen = len - i * m_iMSS;</div><div class="line">        <span class="keyword">if</span> (pktlen &gt; m_iMSS)</div><div class="line">            pktlen = m_iMSS;</div><div class="line"></div><div class="line">        ifs.read(s-&gt;m_pcData, pktlen);</div><div class="line">        <span class="keyword">if</span> ((pktlen = ifs.gcount()) &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// currently file transfer is only available in streaming mode, message is always in order, ttl = infinite</span></div><div class="line">        s-&gt;m_iMsgNo = m_iNextMsgNo | <span class="number">0x20000000</span>;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">            s-&gt;m_iMsgNo |= <span class="number">0x80000000</span>;</div><div class="line">        <span class="keyword">if</span> (i == size - <span class="number">1</span>)</div><div class="line">            s-&gt;m_iMsgNo |= <span class="number">0x40000000</span>;</div><div class="line"></div><div class="line">        s-&gt;m_iLength = pktlen;</div><div class="line">        s-&gt;m_iTTL = -<span class="number">1</span>;</div><div class="line">        s = s-&gt;m_pNext;</div><div class="line"></div><div class="line">        total += pktlen;</div><div class="line">    &#125;</div><div class="line">    m_pLastBlock = s;</div><div class="line"></div><div class="line">    CGuard::enterCS(m_BufLock);</div><div class="line">    m_iCount += size;</div><div class="line">    CGuard::leaveCS(m_BufLock);</div><div class="line"></div><div class="line">    m_iNextMsgNo++;</div><div class="line">    <span class="keyword">if</span> (m_iNextMsgNo == CMsgNo::m_iMaxMsgNo)</div><div class="line">        m_iNextMsgNo = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> total;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的执行过程，与CSndBuffer::addBuffer()的执行过程极为相似，仅有的差别在于，在这个函数，是将文件的数据逐步的read进CSndBuffer，而在addBuffer()中则是memcpy。</p>
<p>在CSndBuffer::addBuffer()与CSndBuffer::addBufferFromFile()中有这么多的重复code，实在是很有进一步进行抽象的空间。在循环中拷贝数据时，每次计算剩余了多少字节，然后和m_iMSS进行比较以确定到底要复制多少数据。这种计算和比较在大多数情况下都比较多余，只有在循环的最后一次执行时才真正需要这样的操作。可以通过特殊处理最后一块数据的复制，并将循环的退出条件值改为(size -1)来提升性能。</p>
<p>我们前面提到了CSndBuffer容量的扩展，那这里就来看一下执行单次扩展的increase()：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">void CSndBuffer::increase() &#123;</div><div class="line">    <span class="keyword">int</span> unitsize = m_pBuffer-&gt;m_iSize;</div><div class="line"></div><div class="line">    <span class="comment">// new physical buffer</span></div><div class="line">    Buffer* nbuf = <span class="keyword">NULL</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        nbuf = <span class="keyword">new</span> Buffer;</div><div class="line">        nbuf-&gt;m_pcData = <span class="keyword">new</span> <span class="keyword">char</span>[unitsize * m_iMSS];</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">        delete nbuf;</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    nbuf-&gt;m_iSize = unitsize;</div><div class="line">    nbuf-&gt;m_pNext = <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// insert the buffer at the end of the buffer list</span></div><div class="line">    Buffer* p = m_pBuffer;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">NULL</span> != p-&gt;m_pNext)</div><div class="line">        p = p-&gt;m_pNext;</div><div class="line">    p-&gt;m_pNext = nbuf;</div><div class="line"></div><div class="line">    <span class="comment">// new packet blocks</span></div><div class="line">    Block* nblk = <span class="keyword">NULL</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        nblk = <span class="keyword">new</span> Block;</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">        delete nblk;</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    Block* pb = nblk;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; unitsize; ++i) &#123;</div><div class="line">        pb-&gt;m_pNext = <span class="keyword">new</span> Block;</div><div class="line">        pb = pb-&gt;m_pNext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// insert the new blocks onto the existing one</span></div><div class="line">    pb-&gt;m_pNext = m_pLastBlock-&gt;m_pNext;</div><div class="line">    m_pLastBlock-&gt;m_pNext = nblk;</div><div class="line"></div><div class="line">    pb = nblk;</div><div class="line">    <span class="keyword">char</span>* pc = nbuf-&gt;m_pcData;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unitsize; ++i) &#123;</div><div class="line">        pb-&gt;m_pcData = pc;</div><div class="line">        pb = pb-&gt;m_pNext;</div><div class="line">        pc += m_iMSS;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_iSize += unitsize;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看下执行单次容量扩充的含义及过程：</p>
<ol>
<li><p>获取CSndBuffer中已有的Block的总数量unitsize。</p>
</li>
<li><p>创建一个Buffer结构，并为它分配数据缓冲区，数据缓冲区的大小为unitsize个Block。由此可见，每一次CSndBuffer的扩展，都会使它的容量加倍。</p>
</li>
<li><p>将前一步创建的Buffer插入到已有的Buffer单链表的尾部。</p>
</li>
<li><p>为前面创建的Buffer，创建对应的Block结构链表，nblk指向这个单链表的头节点，而pb指向这个单链表的尾节点。</p>
</li>
<li><p>如我们前面提到的CSndBuffer中的Block结构是一个循环单向链表，这一步即是将前一步创建的Block单向链表插入CSndBuffer的Block循环链表中。</p>
</li>
<li><p>设置前面创建的所有Block，使它们指向前面创建的Buffer的数据部分的适当位置。</p>
</li>
<li><p>更新表示CSndBuffer中总的Block大小的m_iSize。</p>
</li>
</ol>
<p>如我们前面了解到的，发送数据也是一个生产与消费的故事，UDT::send()和UDT::sendmsg()讲的是生产的故事，至此我们基本上将生产的故事都理清了，接着就来看下消费的故事，也就是CSndQueue中的实际数据发送。</p>
<h1 id="发送队列CSndQueue中数据的实际发送"><a href="#发送队列CSndQueue中数据的实际发送" class="headerlink" title="发送队列CSndQueue中数据的实际发送"></a>发送队列CSndQueue中数据的实际发送</h1><p>接着来讲数据发送这个生产-消费故事的另一半，也就是消费的那一半，发送队列CSndQueue中实际的数据发送。先来瞅一下CSndQueue的定义(src/queue.h)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CSndQueue &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> CUDT;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> CUDTUnited;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    CSndQueue();</div><div class="line">    ~CSndQueue();</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Initialize the sending queue.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    1) [in] c: UDP channel to be associated to the queue</span></div><div class="line">    <span class="comment">//    2) [in] t: Timer</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(CChannel* c, CTimer* t)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Send out a packet to a given address.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    1) [in] addr: destination address</span></div><div class="line">    <span class="comment">//    2) [in] packet: packet to be sent out</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    Size of data sent out.</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(<span class="keyword">const</span> sockaddr* addr, CPacket&amp; packet)</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* param)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="function"><span class="keyword">static</span> DWORD WINAPI <span class="title">worker</span><span class="params">(LPVOID param)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">pthread_t</span> m_WorkerThread;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">    CSndUList* m_pSndUList;		<span class="comment">// List of UDT instances for data sending</span></div><div class="line">    CChannel* m_pChannel;                <span class="comment">// The UDP channel for data sending</span></div><div class="line">    CTimer* m_pTimer;			<span class="comment">// Timing facility</span></div><div class="line"></div><div class="line">    <span class="keyword">pthread_mutex_t</span> m_WindowLock;</div><div class="line">    <span class="keyword">pthread_cond_t</span> m_WindowCond;</div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> m_bClosing;		<span class="comment">// closing the worker</span></div><div class="line">    <span class="keyword">pthread_cond_t</span> m_ExitCond;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">    CSndQueue(<span class="keyword">const</span> CSndQueue&amp;);</div><div class="line">    CSndQueue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CSndQueue&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个class，不管是成员变量，还是成员函数，看上去基本都还比较亲切，其作用不会让人完全无感，但唯独一个成员变量，也就是CSndUList的m_pSndUList。因而这里就先来看一下这个类。先来看CSndUList的定义：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">struct CSNode &#123;</div><div class="line">    CUDT* m_pUDT;		// Pointer to the<span class="built_in"> instance </span>of CUDT socket</div><div class="line">    uint64_t m_llTimeStamp;      // Time Stamp</div><div class="line"></div><div class="line">   <span class="built_in"> int </span>m_iHeap<span class="class">Loc;</span>		// location on the heap, -1 means<span class="built_in"> not </span>on the heap</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class CSndUList &#123;</div><div class="line">    friend class CSndQueue;</div><div class="line"></div><div class="line"><span class="keyword"> public</span>:</div><div class="line">    CSndUList();</div><div class="line">    ~CSndUList();</div><div class="line"></div><div class="line"><span class="keyword"> public</span>:</div><div class="line"></div><div class="line">    // Functionality:</div><div class="line">    //    Insert a<span class="built_in"> new </span>UDT<span class="built_in"> instance </span>into the list.</div><div class="line">    // Parameters:</div><div class="line">    //    1) [in] ts: time stamp: next processing time</div><div class="line">    //    2) [in] u: pointer to the UDT<span class="built_in"> instance</span></div><div class="line">    // Returned value:</div><div class="line">    //    None.</div><div class="line"></div><div class="line">    void insert(int64_t ts,<span class="built_in"> const </span>CUDT* u);</div><div class="line"></div><div class="line">    // Functionality:</div><div class="line">    //    Update the timestamp of the UDT<span class="built_in"> instance </span>on the list.</div><div class="line">    // Parameters:</div><div class="line">    //    1) [in] u: pointer to the UDT<span class="built_in"> instance</span></div><div class="line">    //    2) [in] resechedule:<span class="built_in"> if </span>the timestampe shoudl be rescheduled</div><div class="line">    // Returned value:</div><div class="line">    //    None.</div><div class="line"></div><div class="line">    void update(const CUDT* u, bool reschedule = true);</div><div class="line"></div><div class="line">    // Functionality:</div><div class="line">    //    Retrieve the next packet<span class="built_in"> and </span>peer address from the first entry,<span class="built_in"> and </span>reschedule it in the queue.</div><div class="line">    // Parameters:</div><div class="line">    //    0) [out] addr: destination address of the next packet</div><div class="line">    //    1) [out] pkt: the next packet to be sent</div><div class="line">    // Returned value:</div><div class="line">    //    1<span class="built_in"> if </span>successfully retrieved, -1<span class="built_in"> if </span>no packet found.</div><div class="line"></div><div class="line">   <span class="built_in"> int </span>pop(sockaddr*&amp; addr, CPacket&amp; pkt);</div><div class="line"></div><div class="line">    // Functionality:</div><div class="line">    //    Remove UDT<span class="built_in"> instance </span>from the list.</div><div class="line">    // Parameters:</div><div class="line">    //    1) [in] u: pointer to the UDT<span class="built_in"> instance</span></div><div class="line">    // Returned value:</div><div class="line">    //    None.</div><div class="line"></div><div class="line">    void remove(const CUDT* u);</div><div class="line"></div><div class="line">    // Functionality:</div><div class="line">    //    Retrieve the next scheduled processing time.</div><div class="line">    // Parameters:</div><div class="line">    //    None.</div><div class="line">    // Returned value:</div><div class="line">    //    Scheduled processing time of the first UDT socket in the list.</div><div class="line"></div><div class="line">    uint64_t getNextProcTime();</div><div class="line"></div><div class="line"><span class="keyword"> private</span>:</div><div class="line">    void insert_(int64_t ts,<span class="built_in"> const </span>CUDT* u);</div><div class="line">    void remove_(const CUDT* u);</div><div class="line"></div><div class="line"><span class="keyword"> private</span>:</div><div class="line">    CSNode** m_pHeap;			// The heap<span class="built_in"> array</span></div><div class="line">   <span class="built_in"> int </span>m_iArray<span class="class">Length;</span>			// physical length of the<span class="built_in"> array</span></div><div class="line">   <span class="built_in"> int </span>m_i<span class="class">LastEntry;</span>			// position of last entry on the heap<span class="built_in"> array</span></div><div class="line"></div><div class="line">    pthread_mutex_t m_<span class="class">ListLock;</span></div><div class="line"></div><div class="line">    pthread_mutex_t* m_pWindow<span class="class">Lock;</span></div><div class="line">    pthread_cond_t* m_pWindowCond;</div><div class="line"></div><div class="line">    CTimer* m_pTimer;</div><div class="line"></div><div class="line"><span class="keyword"> private</span>:</div><div class="line">    CSndUList(const CSndU<span class="class">List&amp;);</span></div><div class="line">    CSndUList&amp; operator=(const CSndU<span class="class">List&amp;);</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从这个类的定义中，我们大概能感觉到这是一个CSNode的容器，但容器的许多组织的细节则仍然是一头雾水，那就从它的构造函数和成员函数中来厘清这些细节。来看它的构造函数(src/queue.cpp)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">CSndUList::CSndUList()</div><div class="line">        : m_pHeap(<span class="literal">NULL</span>),</div><div class="line">          m_iArrayLength(<span class="number">4096</span>),</div><div class="line">          m_iLastEntry(<span class="number">-1</span>),</div><div class="line">          m_ListLock(),</div><div class="line">          m_pWindowLock(<span class="literal">NULL</span>),</div><div class="line">          m_pWindowCond(<span class="literal">NULL</span>),</div><div class="line">          m_pTimer(<span class="literal">NULL</span>) &#123;</div><div class="line">    m_pHeap = <span class="keyword">new</span> CSNode*[m_iArrayLength];</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></div><div class="line">    pthread_mutex_init(&amp;m_ListLock, <span class="literal">NULL</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    m_ListLock = CreateMutex(<span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中做的事情就是分配了一个CSNode指针的数组，并初始化了一个mutex m_ListLock，但这似乎也无法透漏出太多的讯息。然后来看向其中插入元素的insert()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CSndUList::insert(<span class="keyword">int64_t</span> ts, <span class="keyword">const</span> CUDT* u) &#123;</div><div class="line">    <span class="function">CGuard <span class="title">listguard</span><span class="params">(m_ListLock)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// increase the heap array size if necessary</span></div><div class="line">    <span class="keyword">if</span> (m_iLastEntry == m_iArrayLength - <span class="number">1</span>) &#123;</div><div class="line">        CSNode** temp = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            temp = <span class="keyword">new</span> CSNode*[m_iArrayLength * <span class="number">2</span>];</div><div class="line">        &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">memcpy</span>(temp, m_pHeap, <span class="keyword">sizeof</span>(CSNode*) * m_iArrayLength);</div><div class="line">        m_iArrayLength *= <span class="number">2</span>;</div><div class="line">        <span class="keyword">delete</span>[] m_pHeap;</div><div class="line">        m_pHeap = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    insert_(ts, u);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>m_iLastEntry是数组中已经被占用的最后一个位置。在这个函数中，做了两件事：</p>
<ol>
<li><p>检查m_iLastEntry是否等于m_iArrayLength - 1，若是，则表明数组中所有的位置都被占用了此时则需要扩充容量，这里的做法就是创建一个长度为之前数组长度2倍的新数组，将之前数组中的内容拷贝到新数组里，更新m_iArrayLength，删除之前的数组，更新m_pHeap只想新数组。</p>
</li>
<li><p>执行CSndUList::insert_()进行实际的插入动作。</p>
</li>
</ol>
<p>再来看CSndUList::insert_()：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">void CSndUList::insert_(int64_t ts, <span class="keyword">const</span> CUDT* u) &#123;</div><div class="line">    CSNode* n = u-&gt;m_pSNode;</div><div class="line"></div><div class="line">    <span class="comment">// do not insert repeated node</span></div><div class="line">    <span class="keyword">if</span> (n-&gt;m_iHeapLoc &gt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    m_iLastEntry++;</div><div class="line">    m_pHeap[m_iLastEntry] = n;</div><div class="line">    n-&gt;m_llTimeStamp = ts;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> q = m_iLastEntry;</div><div class="line">    <span class="keyword">int</span> p = q;</div><div class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>) &#123;</div><div class="line">        p = (q - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (m_pHeap[p]-&gt;m_llTimeStamp &gt; m_pHeap[q]-&gt;m_llTimeStamp) &#123;</div><div class="line">            CSNode* t = m_pHeap[p];</div><div class="line">            m_pHeap[p] = m_pHeap[q];</div><div class="line">            m_pHeap[q] = t;</div><div class="line">            t-&gt;m_iHeapLoc = q;</div><div class="line">            q = p;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    n-&gt;m_iHeapLoc = q;</div><div class="line"></div><div class="line">    <span class="comment">// an earlier event has been inserted, wake up sending worker</span></div><div class="line">    <span class="keyword">if</span> (n-&gt;m_iHeapLoc == <span class="number">0</span>)</div><div class="line">        m_pTimer-&gt;interrupt();</div><div class="line"></div><div class="line">    <span class="comment">// first entry, activate the sending queue</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_iLastEntry) &#123;</div><div class="line"><span class="comment">#ifndef WIN32</span></div><div class="line">        pthread_mutex_lock(m_pWindowLock);</div><div class="line">        pthread_cond_signal(m_pWindowCond);</div><div class="line">        pthread_mutex_unlock(m_pWindowLock);</div><div class="line"><span class="comment">#else</span></div><div class="line">        SetEvent(*m_pWindowCond);</div><div class="line"><span class="comment">#endif</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中主要做了这样一些事：</p>
<ol>
<li><p>检查要插入的元素是否已经插入了，主要是根据CUDT的CSNode n的HeapLoc字段是否大于0来判断的。若已经插入，则直接返回。</p>
</li>
<li><p>将CSNode放在数组的尾部。</p>
</li>
<li><p>调整CSNode n在数组中的位置，以使它处于适当的位置。要厘清这个地方的调整过程，可能要复习一下我们曾经学习过的堆数据结构了。可以将堆理解为一个用数组表示的二叉树，如下图所示：</p>
</li>
</ol>
<p><img src="https://www.wolfcstech.com/images/1315506-4ad895fec8c402f0.jpg" alt=""></p>
<p>如上图，每个框框中的数字表示该节点在数组中的位置。可以看到一个节点的位置与它的两个子节点及父节点的位置之间的关系：</p>
<p>假设一个节点的位置，也就是该节点在数组中的index为n，则它的父节点的位置为((n -1)/2)，而它的两个子几点的位置分别为(2×N+1)和(2×n+2)。</p>
<p>回到CSndUList::insert_()的节点CSNode n的位置调整过程。可以看到，这个过程主要是根据CSNode n的m_llTimeStamp值，若CSNode n的m_llTimeStamp值比它的父节点的m_llTimeStamp小的话就把CSNode n往二叉树的上层浮，而把它的父节点向二叉树的下层沉，依次类推，直到找到某个位置，其父节点的m_llTimeStamp值比它的m_llTimeStamp值小，或者浮到二叉树的最顶层。</p>
<p>由此可见m_pHeap是一个根据CSNode的m_llTimeStamp值建的堆，越往上层，该值越小。而m_pHeap[0]则是整个堆中所有CSNode元素m_llTimeStamp值最小的那个。</p>
<ol>
<li><p>更新CSNode n的m_iHeapLoc指向它在数组m_pHeap中的索引。</p>
</li>
<li><p>CSNode n被浮到堆的顶部时，唤醒发送队列的worker线程。</p>
</li>
<li><p>插入的如果是堆中的第一个元素的话，唤醒等待在m_pWindowCond上的线程。</p>
</li>
</ol>
<p>看完了插入元素，再来看移除元素也就是CSndUList::remove()：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">void CSndUList::remove(const CUDT* u) &#123;</div><div class="line">    CGuard listguard(m_ListLock);</div><div class="line"></div><div class="line">    remove_(u);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void CSndUList::remove_(const CUDT* u) &#123;</div><div class="line">    CSN<span class="function"><span class="title">ode</span>* n = u-&gt;</span>m_pSNode;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">if</span> (n-&gt;</span>m_iHeapLoc &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// remove the node from heap</span></div><div class="line">        <span class="function"><span class="title">m_pHeap</span>[n-&gt;</span>m_iHeapLoc] = m_pHeap[m_iLastEntry];</div><div class="line">        m_iLastEntry--;</div><div class="line">        <span class="function"><span class="title">m_pHeap</span>[n-&gt;</span><span class="function"><span class="title">m_iHeapLoc</span>]-&gt;</span><span class="function"><span class="title">m_iHeapLoc</span> = n-&gt;</span>m_iHeapLoc;</div><div class="line"></div><div class="line">        <span class="function"><span class="title">int</span> q = n-&gt;</span>m_iHeapLoc;</div><div class="line">        int p = q * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (p &lt;= m_iLastEntry) &#123;</div><div class="line">            <span class="function"><span class="title">if</span> ((p + 1 &lt;= m_iLastEntry) &amp;&amp; (m_pHeap[p]-&gt;</span><span class="function"><span class="title">m_llTimeStamp</span> &gt; m_pHeap[p + 1]-&gt;</span>m_llTimeStamp))</div><div class="line">                p++;</div><div class="line"></div><div class="line">            <span class="function"><span class="title">if</span> (m_pHeap[q]-&gt;</span><span class="function"><span class="title">m_llTimeStamp</span> &gt; m_pHeap[p]-&gt;</span>m_llTimeStamp) &#123;</div><div class="line">                CSNode* t = m_pHeap[p];</div><div class="line">                m_pHeap[p] = m_pHeap[q];</div><div class="line">                <span class="function"><span class="title">m_pHeap</span>[p]-&gt;</span>m_iHeapLoc = p;</div><div class="line">                m_pHeap[q] = t;</div><div class="line">                <span class="function"><span class="title">m_pHeap</span>[q]-&gt;</span>m_iHeapLoc = q;</div><div class="line"></div><div class="line">                q = p;</div><div class="line">                p = q * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span></div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="title">n</span>-&gt;</span>m_iHeapLoc = -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// the only event has been deleted, wake up immediately</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_iLastEntry)</div><div class="line">        <span class="function"><span class="title">m_pTimer</span>-&gt;</span>interrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CSndUList::remove()是直接调用了CSndUList::remove<em>()，而在CSndUList::remove</em>()主要做了如下这样一些事情：</p>
<ol>
<li><p>先检查要移除的CSNode n是否存在与堆中，主要根据CSNode n的HeapLoc字段是否大于0来判断的。若没有插入，则跳到第5步，否则继续执行。</p>
</li>
<li><p>将m_pHeap中的最末尾的元素放进原本由要移除的CSNode n所占用的位置，更新m_iLastEntry，及被改变了位置的原来的最末尾元素CSNode的m_iHeapLoc指向它当前被放置的位置。</p>
</li>
<li><p>如果被调整了位置的CSNode的新位置不是最末尾的位置，则调整该节点的位置。这里主要是在这个节点的m_llTimeStamp值比它的子节点的m_llTimeStamp值更大时，将这个节点向二叉树层次结构的下层沉，而将它的字节点向上浮的过程。一个节点总是有两个字节点，也就是两棵子树，那它又会向哪一棵那边沉呢？可以看到是字节点中m_llTimeStamp值更小的那一边。</p>
</li>
</ol>
<p>总觉得这里应该再有一个节点上浮的过程。如果移除的节点是最末尾节点的直系父节点，这当然没有问题，但如果不是，则关系还是有许多不确定的地方。</p>
<ol>
<li><p>更新CSNode n的m_iHeapLoc指向-1。</p>
</li>
<li><p>如果m_iLastEntry为0，即表示堆中不再有元素了，则还会执行唤醒。</p>
</li>
</ol>
<p>回头看我们前面分析的CUDT::send()和CUDT::sendmsg()，它们都通过m_pSndQueue-&gt;m_pSndUList-&gt;update(this, false)将CUDT插入CSndUList m_pSndUList，这里再来看一下CSndUList::update()：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void CSndUList::update(<span class="keyword">const</span> CUDT* u, <span class="keyword">bool</span> reschedule) &#123;</div><div class="line">    CGuard listguard(m_ListLock);</div><div class="line"></div><div class="line">    CSNode* n = u-&gt;m_pSNode;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n-&gt;m_iHeapLoc &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!reschedule)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (n-&gt;m_iHeapLoc == <span class="number">0</span>) &#123;</div><div class="line">            n-&gt;m_llTimeStamp = <span class="number">1</span>;</div><div class="line">            m_pTimer-&gt;interrupt();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        remove_(u);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    insert_(<span class="number">1</span>, u);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>reschedule参数表示的是，如果之前的已经有发送任务，且还没有执行完，则将新的发送任务放在老的之后。</p>
<p>可以看到在这个函数中，如果CSNode还没有被插入堆中，则尽可能将CSNode放如堆的顶部以便于发送任务尽快执行。若已经插入，且reschedule为false，则直接返回。若已经插入，且reschedule为true，则检查一下CSNode当前是否已经在堆的顶部了，若是就退出。若不是，则先将CSNode从堆中移除，然后再尽可能将CSNode插入堆的顶部。</p>
<p>对发送队列CSndQueue所用的数据结构做这么多分析之后，我们再来看它的worker线程，也就是CSndQueue::worker()：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">CSndQueue::CSndQueue()</div><div class="line">        : m_WorkerThread(),</div><div class="line">          m_pSndUList(<span class="keyword">NULL</span>),</div><div class="line">          m_pChannel(<span class="keyword">NULL</span>),</div><div class="line">          m_pTimer(<span class="keyword">NULL</span>),</div><div class="line">          m_WindowLock(),</div><div class="line">          m_WindowCond(),</div><div class="line">          m_bClosing(<span class="keyword">false</span>),</div><div class="line">          m_ExitCond() &#123;</div><div class="line"><span class="comment">#ifndef WIN32</span></div><div class="line">    pthread_cond_init(&amp;m_WindowCond, <span class="keyword">NULL</span>);</div><div class="line">    pthread_mutex_init(&amp;m_WindowLock, <span class="keyword">NULL</span>);</div><div class="line"><span class="comment">#else</span></div><div class="line">    m_WindowLock = CreateMutex(<span class="keyword">NULL</span>, <span class="keyword">false</span>, <span class="keyword">NULL</span>);</div><div class="line">    m_WindowCond = CreateEvent(<span class="keyword">NULL</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">NULL</span>);</div><div class="line">    m_ExitCond = CreateEvent(<span class="keyword">NULL</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">NULL</span>);</div><div class="line"><span class="comment">#endif</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">CSndQueue::~CSndQueue() &#123;</div><div class="line">    m_bClosing = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="comment">#ifndef WIN32</span></div><div class="line">    pthread_mutex_lock(&amp;m_WindowLock);</div><div class="line">    pthread_cond_signal(&amp;m_WindowCond);</div><div class="line">    pthread_mutex_unlock(&amp;m_WindowLock);</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != m_WorkerThread)</div><div class="line">        pthread_join(m_WorkerThread, <span class="keyword">NULL</span>);</div><div class="line">    pthread_cond_destroy(&amp;m_WindowCond);</div><div class="line">    pthread_mutex_destroy(&amp;m_WindowLock);</div><div class="line"><span class="comment">#else</span></div><div class="line">    SetEvent(m_WindowCond);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">NULL</span> != m_WorkerThread)</div><div class="line">    WaitForSingleObject(m_ExitCond, INFINITE);</div><div class="line">    CloseHandle(m_WorkerThread);</div><div class="line">    CloseHandle(m_WindowLock);</div><div class="line">    CloseHandle(m_WindowCond);</div><div class="line">    CloseHandle(m_ExitCond);</div><div class="line"><span class="comment">#endif</span></div><div class="line"></div><div class="line">    delete m_pSndUList;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void CSndQueue::init(CChannel* c, CTimer* t) &#123;</div><div class="line">    m_pChannel = c;</div><div class="line">    m_pTimer = t;</div><div class="line">    m_pSndUList = <span class="keyword">new</span> CSndUList;</div><div class="line">    m_pSndUList-&gt;m_pWindowLock = &amp;m_WindowLock;</div><div class="line">    m_pSndUList-&gt;m_pWindowCond = &amp;m_WindowCond;</div><div class="line">    m_pSndUList-&gt;m_pTimer = m_pTimer;</div><div class="line"></div><div class="line"><span class="comment">#ifndef WIN32</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != pthread_create(&amp;m_WorkerThread, <span class="keyword">NULL</span>, CSndQueue::worker, this)) &#123;</div><div class="line">        m_WorkerThread = <span class="number">0</span>;</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">3</span>, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"><span class="comment">#else</span></div><div class="line">    DWORD threadID;</div><div class="line">    m_WorkerThread = CreateThread(<span class="keyword">NULL</span>, <span class="number">0</span>, CSndQueue::worker, this, <span class="number">0</span>, &amp;threadID);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">NULL</span> == m_WorkerThread)</div><div class="line">    <span class="keyword">throw</span> CUDTException(<span class="number">3</span>, <span class="number">1</span>);</div><div class="line"><span class="comment">#endif</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#ifndef WIN32</span></div><div class="line">void* CSndQueue::worker(void* param)</div><div class="line"><span class="comment">#else</span></div><div class="line">        DWORD WINAPI CSndQueue::worker(LPVOID param)</div><div class="line"><span class="comment">#endif</span></div><div class="line">        &#123;</div><div class="line">    CSndQueue* <span class="keyword">self</span> = (CSndQueue*) param;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!<span class="keyword">self</span>-&gt;m_bClosing) &#123;</div><div class="line">        uint64_t ts = <span class="keyword">self</span>-&gt;m_pSndUList-&gt;getNextProcTime();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ts &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// wait until next processing time of the first socket on the list</span></div><div class="line">            uint64_t currtime;</div><div class="line">            CTimer::rdtsc(currtime);</div><div class="line">            <span class="keyword">if</span> (currtime &lt; ts)</div><div class="line">                <span class="keyword">self</span>-&gt;m_pTimer-&gt;sleepto(ts);</div><div class="line"></div><div class="line">            <span class="comment">// it is time to send the next pkt</span></div><div class="line">            sockaddr* addr;</div><div class="line">            CPacket pkt;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;m_pSndUList-&gt;pop(addr, pkt) &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">            <span class="keyword">self</span>-&gt;m_pChannel-&gt;sendto(addr, pkt);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// wait here if there is no sockets with data to be sent</span></div><div class="line"><span class="comment">#ifndef WIN32</span></div><div class="line">            pthread_mutex_lock(&amp;<span class="keyword">self</span>-&gt;m_WindowLock);</div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">self</span>-&gt;m_bClosing &amp;&amp; (<span class="keyword">self</span>-&gt;m_pSndUList-&gt;m_iLastEntry &lt; <span class="number">0</span>))</div><div class="line">                pthread_cond_wait(&amp;<span class="keyword">self</span>-&gt;m_WindowCond, &amp;<span class="keyword">self</span>-&gt;m_WindowLock);</div><div class="line">            pthread_mutex_unlock(&amp;<span class="keyword">self</span>-&gt;m_WindowLock);</div><div class="line"><span class="comment">#else</span></div><div class="line">            WaitForSingleObject(<span class="keyword">self</span>-&gt;m_WindowCond, INFINITE);</div><div class="line"><span class="comment">#endif</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">#ifndef WIN32</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line"><span class="comment">#else</span></div><div class="line">    SetEvent(<span class="keyword">self</span>-&gt;m_ExitCond);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="comment">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CSndQueue::worker()中的while循环几乎就是CSndQueue的worker线程执行的全部任务了，这个循环的循环体中主要做了如下这样的一些事情：</p>
<ol>
<li>调用self-&gt;m_pSndUList-&gt;getNextProcTime()，来查看最近的一次发送任务所需要执行的时间ts。这里来看一下CSndUList::getNextProcTime()的定义：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint64_t</span> CSndUList::getNextProcTime() &#123;</div><div class="line">    <span class="function">CGuard <span class="title">listguard</span><span class="params">(m_ListLock)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == m_iLastEntry)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> m_pHeap[<span class="number">0</span>]-&gt;m_llTimeStamp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若返回值小于等于0，就表示当前没有需要发送的数据，没有需要执行的发送任务。则进入等待状态。在CSndQueue::init()的定义中，CSndUList m_pSndUList的m_pWindowLock和m_pWindowCond会分别指向CSndQueue的m_WindowLock和m<em>WindowCond，因而可见，这个地方的等待，是被CSndUList::insert</em>()唤醒的。</p>
<p>若返回值大于0，则表明存在着需要执行的发送任务。此时则执行下一步。</p>
<ol>
<li><p>获取当前的时间currtime。比较currtime与ts，若前者较小，则表明最近需要执行的发送任务它请求的执行时间还没到，则休眠等待直到ts的到来。如我们前面的分析，并根据CSndQueue::init()的定义可见，向m_pSndUList中插入、移除或更新元素，都可能会唤醒这里的等待。若前者较大，或者等待的时刻到了则执行下一步。</p>
</li>
<li><p>执行self-&gt;m_pSndUList-&gt;pop(addr, pkt)，从CSndUList m_pSndUList中抓一个CPacket出来。若没抓到，则进入下一次循环，否则发送抓到的CPacket。来看CSndUList::pop()：</p>
</li>
</ol>
<p>int CSndUList::pop(sockaddr*&amp; addr, CPacket&amp; pkt) {<br>    CGuard listguard(m_ListLock);</p>
<pre><code>if (-1 == m_iLastEntry)
    return -1;

// no pop until the next schedulled time
uint64_t ts;
CTimer::rdtsc(ts);
if (ts &lt; m_pHeap[0]-&gt;m_llTimeStamp)
    return -1;

CUDT* u = m_pHeap[0]-&gt;m_pUDT;
remove_(u);

if (!u-&gt;m_bConnected || u-&gt;m_bBroken)
    return -1;

// pack a packet from the socket
if (u-&gt;packData(pkt, ts) &lt;= 0)
    return -1;

addr = u-&gt;m_pPeerAddr;

// insert a new entry, ts is the next processing time
if (ts &gt; 0)
    insert_(ts, u);

return 1;
</code></pre><p>}</p>
<p>可以看到CSndUList::pop()做了这样一些事情：</p>
<ol>
<li><p>检查m_iLastEntry是否为-1，若为-1，表明没有要执行发送的任务，因而直接返回-1。否则继续执行。</p>
</li>
<li><p>检查当前时间是否小于堆顶元素的m_llTimeStamp，若小于则表明，最近一次发送任务的发送时间还没到，则返回-1，否则继续执行。</p>
</li>
<li><p>获取堆顶元素的CUDT对象u，也就是发送任务的请求者，并将堆顶元素先从对中移除。</p>
</li>
<li><p>检查u的状态，若不处于有效的连接状态，则返回-1，否则继续执行。</p>
</li>
<li><p>执行u-&gt;packData(pkt, ts)打出一个数据包来。</p>
</li>
<li><p>使传进来的addr只想CUDT u的PeerAddr，CSndQueue会将这个地址作为包的发送目的地址。</p>
</li>
<li><p>将CUDT u重新插入堆中，时间戳为当前时间，这也就意味着，如果可以的话，就在下一个循环中继续发送CUDT u的数据。</p>
</li>
<li><p>返回1。</p>
</li>
</ol>
<p>在发送队列CSndQueue的worker线程中，最最需要的是尽可能快的获得最近需要执行的发送任务的一些信息。CSndUList::getNextProcTime()和CSndUList::pop()中获取的最主要的信息也是堆顶元素的一些信息。一个严格依照请求的执行时间进行排列的列表意义并不是很大，为了保证这种有序性反倒可能需要消耗不少的时间，采用堆却可以想CSndQueue的worker线程尽可能快的返回最近将要执行的发送任务请求执行的时间。</p>
<p>Done。</p>
</div><div class="tags"><a href="/tags/网络协议/">网络协议</a><a href="/tags/源码分析/">源码分析</a><a href="/tags/UDT/">UDT</a></div><div class="post-nav"><a href="/2015/09/18/UDT协议实现分析——数据发送控制/" class="pre">UDT协议实现分析——数据发送控制</a><a href="/2015/09/12/UDT协议实现分析——连接的建立/" class="next">UDT协议实现分析——连接的建立</a></div><div id="disqus_thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-图形系统/">Android 图形系统</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发/">Android开发</a><span class="category-list-count">28</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-开发/">C/C++开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java开发/">Java开发</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核/">Linux内核</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/live555/">live555</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/业界趣闻/">业界趣闻</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台开发/">后台开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络调试/">网络调试</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随想杂谈/">随想杂谈</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频开发/">音视频开发</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/UDT/" style="font-size: 15px;">UDT</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/Android开发/" style="font-size: 15px;">Android开发</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/chromium/" style="font-size: 15px;">chromium</a> <a href="/tags/后台开发/" style="font-size: 15px;">后台开发</a> <a href="/tags/Java开发/" style="font-size: 15px;">Java开发</a> <a href="/tags/QUIC/" style="font-size: 15px;">QUIC</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/网络调试/" style="font-size: 15px;">网络调试</a> <a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/HTTP2/" style="font-size: 15px;">HTTP2</a> <a href="/tags/图形图像/" style="font-size: 15px;">图形图像</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/C-C-开发/" style="font-size: 15px;">C/C++开发</a> <a href="/tags/音视频开发/" style="font-size: 15px;">音视频开发</a> <a href="/tags/Linux内核/" style="font-size: 15px;">Linux内核</a> <a href="/tags/live555/" style="font-size: 15px;">live555</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/Go-语言/" style="font-size: 15px;">Go 语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">二月 2013</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/24/gerrit_codereview/">Gerrit代码审核服务器搭建全过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/20/adb_overview/">关于 ADB 实现的说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/adb-standalone/">adb standalone</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/31/qcow2_on_linux/">在 Linux 上如何挂载 qcow2 磁盘镜像</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/android_graphics_gralloc/">Android 图形系统之gralloc</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/20/android_graphics_bufferalloc/">Android 图形系统之图形缓冲区分配</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/16/opengles_android_emulation/">Android 硬件 OpenGL ES 模拟设计概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/15/egl_context_creation/">EGL Context 创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/14/egl_init_drivers/">Android 图形驱动初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/opengl_on_android_with_sv/">在 Android 中使用 OpenGL</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="https://source.android.com/" title="Android Open Source Project" target="_blank">Android Open Source Project</a><ul></ul><a href="http://www.vants.org/" title="蚂蚁网" target="_blank">蚂蚁网</a></div><div class="widget"><div class="widget-title"><i class="fa fa-commt"> 最近评论</i></div><script type="text/javascript" src="//wolfcstech.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.2.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:hanpfei@gmail.com" target="_blank" class="fa fa-email"> </a><a href="undefined" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/hanpfei" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">Han Pengfei</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var disqus_shortname = 'wolfcstech';
var disqus_identifier = '2015/09/14/UDT协议实现分析——数据的发送/';
var disqus_title = 'UDT协议实现分析——数据的发送';
var disqus_url = 'https://www.wolfcstech.com/2015/09/14/UDT协议实现分析——数据的发送/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wolfcstech.disqus.com/count.js" async></script><script type="text/javascript" src="/js/search.json.js?v=1.2.0"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-109419024-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3c736b12c32c019fd9ff6c825b6b9b44";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></body></html>