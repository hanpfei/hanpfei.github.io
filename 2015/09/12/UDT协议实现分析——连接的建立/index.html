<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/freesoft.jpg?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/freesoft.jpg?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/freesoft.jpg?v=6.0.3">


  <link rel="mask-icon" href="/images/freesoft.jpg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="网络协议,源码分析,UDT," />


<meta name="description" content="UDT Server在执行UDT::listen()之后，就可以接受其它节点的连接请求了。这里我们研究一下UDT连接建立的过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="UDT协议实现分析——连接的建立">
<meta property="og:url" content="https://www.wolfcstech.com/2015/09/12/UDT协议实现分析——连接的建立/index.html">
<meta property="og:site_name" content="WolfcsTech">
<meta property="og:description" content="UDT Server在执行UDT::listen()之后，就可以接受其它节点的连接请求了。这里我们研究一下UDT连接建立的过程。">
<meta property="og:image" content="https://www.wolfcstech.com/images/1315506-eadbc50fbe607bfa.png">
<meta property="og:updated_time" content="2017-02-16T06:49:20.953Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UDT协议实现分析——连接的建立">
<meta name="twitter:description" content="UDT Server在执行UDT::listen()之后，就可以接受其它节点的连接请求了。这里我们研究一下UDT连接建立的过程。">
<meta name="twitter:image" content="https://www.wolfcstech.com/images/1315506-eadbc50fbe607bfa.png">






  <link rel="canonical" href="https://www.wolfcstech.com/2015/09/12/UDT协议实现分析——连接的建立/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>UDT协议实现分析——连接的建立 | WolfcsTech</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-109419024-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-109419024-1');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3c736b12c32c019fd9ff6c825b6b9b44";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WolfcsTech</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="http://www.ixirong.com/404.html" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />公益 404</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.wolfcstech.com/2015/09/12/UDT协议实现分析——连接的建立/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han Pengfei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/freesoft.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WolfcsTech">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UDT协议实现分析——连接的建立</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-12T16:05:49+08:00">2015-09-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/09/12/UDT协议实现分析——连接的建立/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2015/09/12/UDT协议实现分析——连接的建立/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2015/09/12/UDT协议实现分析——连接的建立/" class="leancloud_visitors" data-flag-title="UDT协议实现分析——连接的建立">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>UDT Server在执行UDT::listen()之后，就可以接受其它节点的连接请求了。这里我们研究一下UDT连接建立的过程。<br><a id="more"></a></p>
<h1 id="连接的发起"><a href="#连接的发起" class="headerlink" title="连接的发起"></a>连接的发起</h1><p>来看连接的发起方。如前面我们看到的那样，UDT Client创建一个Socket，可以将该Socket绑定到某个端口，也可以不绑定，然后就可以调用UDT::connect()将这个Socket连接到UDT Server了。来看UDT::connect()的定义(src/api.cpp)：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CUDTUnited::connect(<span class="keyword">const</span> UDTSOCKET u, <span class="keyword">const</span> sockaddr* name, <span class="keyword">int</span> namelen) &#123;</div><div class="line">    CUDTSocket* s = locate(u);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">NULL</span> == s)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    CGuard cg(s-&gt;m_ControlLock);</div><div class="line"></div><div class="line">    <span class="comment">// check the size of SOCKADDR structure</span></div><div class="line">    <span class="keyword">if</span> (AF_INET == s-&gt;m_iIPversion) &#123;</div><div class="line">        <span class="keyword">if</span> (namelen != sizeof(sockaddr_in))</div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (namelen != sizeof(sockaddr_in6))</div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// a socket can "connect" only if it is in INIT or OPENED status</span></div><div class="line">    <span class="keyword">if</span> (INIT == s-&gt;m_Status) &#123;</div><div class="line">        <span class="keyword">if</span> (!s-&gt;m_pUDT-&gt;m_bRendezvous) &#123;</div><div class="line">            s-&gt;m_pUDT-&gt;open();</div><div class="line">            updateMux(s);</div><div class="line">            s-&gt;m_Status = OPENED;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (OPENED != s-&gt;m_Status)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// connect_complete() may be called before connect() returns.</span></div><div class="line">    <span class="comment">// So we need to update the status before connect() is called,</span></div><div class="line">    <span class="comment">// otherwise the status may be overwritten with wrong value (CONNECTED vs. CONNECTING).</span></div><div class="line">    s-&gt;m_Status = CONNECTING;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        s-&gt;m_pUDT-&gt;connect(name);</div><div class="line">    &#125; <span class="keyword">catch</span> (CUDTException &amp;e) &#123;</div><div class="line">        s-&gt;m_Status = OPENED;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// record peer address</span></div><div class="line">    delete s-&gt;m_pPeerAddr;</div><div class="line">    <span class="keyword">if</span> (AF_INET == s-&gt;m_iIPversion) &#123;</div><div class="line">        s-&gt;m_pPeerAddr = (sockaddr*) (<span class="keyword">new</span> sockaddr_in);</div><div class="line">        memcpy(s-&gt;m_pPeerAddr, name, sizeof(sockaddr_in));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        s-&gt;m_pPeerAddr = (sockaddr*) (<span class="keyword">new</span> sockaddr_in6);</div><div class="line">        memcpy(s-&gt;m_pPeerAddr, name, sizeof(sockaddr_in6));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> CUDT::connect(UDTSOCKET u, <span class="keyword">const</span> sockaddr* name, <span class="keyword">int</span> namelen) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> s_UDTUnited.connect(u, name, namelen);</div><div class="line">    &#125; <span class="keyword">catch</span> (CUDTException &amp;e) &#123;</div><div class="line">        s_UDTUnited.setError(<span class="keyword">new</span> CUDTException(e));</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125; <span class="keyword">catch</span> (bad_alloc&amp;) &#123;</div><div class="line">        s_UDTUnited.setError(<span class="keyword">new</span> CUDTException(<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>));</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">        s_UDTUnited.setError(<span class="keyword">new</span> CUDTException(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>));</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> connect(UDTSOCKET u, <span class="keyword">const</span> struct sockaddr* name, <span class="keyword">int</span> namelen) &#123;</div><div class="line">    <span class="keyword">return</span> CUDT::connect(u, name, namelen);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>UDT::connect() API实现的结构跟其它的API没有太大的区别，不再赘述，直接来分析CUDTUnited::connect()：</p>
<ol>
<li><p>调用CUDTUnited::locate()，查找UDT Socket对应的CUDTSocket结构。若找不到，则抛出异常直接返回；否则，继续执行。</p>
</li>
<li><p>根据UDT Socket的IP版本，检查目标地址的有效性。若无效，则退出，否则继续执行。</p>
</li>
<li><p>检查UDT Socket的状态。确保只有处于INIT或OPENED状态的UDT Socket才可以执行connect()操作。新创建的UDT Socket处于INIT状态，bind之后UDT Socket处于OPENED状态。如果UDT Socket处于INIT状态，且不是Rendezvous模式，还会执行s-&gt;m_pUDT-&gt;open()，将UDT Socket与多路复用器CMultiplexer，然后将状态置为OPENED。<br>前面我们在bind的执行过程中有看到<a href="http://my.oschina.net/wolfcs/blog/503959" target="_blank" rel="external">将UDT Socket与多路复用器</a><a href="http://my.oschina.net/wolfcs/blog/503959" target="_blank" rel="external">CMultiplexer关联</a>的过程CUDTUnited::updateMux()。但这里执行的updateMux()的不同之处在于，它既没有传递有效的系统UDP socket，也没有传递有效的本地端口地址。回想updateMux()的实现，这两个参数主要决定了CMultiplexer的CChannel将与哪个端口关联。来看两个CChannel::open()的实现(src/channel.cpp)：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CChannel::open(<span class="keyword">const</span> sockaddr* addr) &#123;</div><div class="line">    <span class="comment">// construct an socket</span></div><div class="line">    m_iSocket = ::socket(m_iIPversion, SOCK_DGRAM, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></div><div class="line">    <span class="keyword">if</span> (INVALID_SOCKET == m_iSocket)</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">if</span> (m_iSocket &lt; <span class="number">0</span>)</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">1</span>, <span class="number">0</span>, NET_ERROR);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != addr) &#123;</div><div class="line">        <span class="keyword">socklen_t</span> namelen = m_iSockAddrSize;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> != ::bind(m_iSocket, addr, namelen))</div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">1</span>, <span class="number">3</span>, NET_ERROR);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//sendto or WSASendTo will also automatically bind the socket</span></div><div class="line">        addrinfo hints;</div><div class="line">        addrinfo* res;</div><div class="line"></div><div class="line">        <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</div><div class="line"></div><div class="line">        hints.ai_flags = AI_PASSIVE;</div><div class="line">        hints.ai_family = m_iIPversion;</div><div class="line">        hints.ai_socktype = SOCK_DGRAM;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> != ::getaddrinfo(<span class="literal">NULL</span>, <span class="string">"0"</span>, &amp;hints, &amp;res))</div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">1</span>, <span class="number">3</span>, NET_ERROR);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> != ::bind(m_iSocket, res-&gt;ai_addr, res-&gt;ai_addrlen))</div><div class="line">            <span class="keyword">throw</span> CUDTException(<span class="number">1</span>, <span class="number">3</span>, NET_ERROR);</div><div class="line"></div><div class="line">        ::freeaddrinfo(res);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setUDPSockOpt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> CChannel::open(UDPSOCKET udpsock) &#123;</div><div class="line">    m_iSocket = udpsock;</div><div class="line">    setUDPSockOpt();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> CChannel::setUDPSockOpt() &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(BSD) || defined(OSX)</span></div><div class="line">    <span class="comment">// BSD system will fail setsockopt if the requested buffer size exceeds system maximum value</span></div><div class="line">    <span class="keyword">int</span> maxsize = <span class="number">64000</span>;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ::setsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (<span class="keyword">char</span>*)&amp;m_iRcvBufSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</div><div class="line">    ::setsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (<span class="keyword">char</span>*)&amp;maxsize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ::setsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">char</span>*)&amp;m_iSndBufSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</div><div class="line">    ::setsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">char</span>*)&amp;maxsize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">// for other systems, if requested is greated than maximum, the maximum value will be automactally used</span></div><div class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != ::setsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (<span class="keyword">char</span>*) &amp;m_iRcvBufSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)))</div><div class="line">            || (<span class="number">0</span> != ::setsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (<span class="keyword">char</span>*) &amp;m_iSndBufSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>))))</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">1</span>, <span class="number">3</span>, NET_ERROR);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    timeval tv;</div><div class="line">    tv.tv_sec = <span class="number">0</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (BSD) || defined (OSX)</span></div><div class="line">    <span class="comment">// Known BSD bug as the day I wrote this code.</span></div><div class="line">    <span class="comment">// A small time out value will cause the socket to block forever.</span></div><div class="line">    tv.tv_usec = <span class="number">10000</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    tv.tv_usec = <span class="number">100</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNIX</span></div><div class="line">    <span class="comment">// Set non-blocking I/O</span></div><div class="line">    <span class="comment">// UNIX does not support SO_RCVTIMEO</span></div><div class="line">    <span class="keyword">int</span> opts = ::fcntl(m_iSocket, F_GETFL);</div><div class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ::fcntl(m_iSocket, F_SETFL, opts | O_NONBLOCK))</div><div class="line">    <span class="keyword">throw</span> CUDTException(<span class="number">1</span>, <span class="number">3</span>, NET_ERROR);</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> WIN32</span></div><div class="line">    DWORD ot = <span class="number">1</span>;  <span class="comment">//milliseconds</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ::setsockopt(m_iSocket, SOL_SOCKET, SO_RCVTIMEO, (<span class="keyword">char</span> *)&amp;ot, <span class="keyword">sizeof</span>(DWORD)))</div><div class="line">    <span class="keyword">throw</span> CUDTException(<span class="number">1</span>, <span class="number">3</span>, NET_ERROR);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="comment">// Set receiving time-out value</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ::setsockopt(m_iSocket, SOL_SOCKET, SO_RCVTIMEO, (<span class="keyword">char</span> *) &amp;tv, <span class="keyword">sizeof</span>(timeval)))</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">1</span>, <span class="number">3</span>, NET_ERROR);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到CChannel::open()主要是把UDT的CChannel与一个系统的UDP socket关联起来，它们总共处理了3中情况，一是调用者已经创建并绑定到了目标端口的系统UDP socket，这种最简单，直接将传递进来的UDPSOCKET赋值给CChannel的m_iSocket，然后设置系统UDP socket的选项；二是传递进来了一个有效的本地端口地址，此时CChannel会自己先创建一个系统UDP socket，并将该socket绑定到传进来的目标端口地址，一、二两种情况正是UDT的两个bind API的情况；三是既没有有效的系统UDP socket，又没有有效的本地端口地址传进来，则会在创建了系统UDP socket之后，先再找一个可用的端口地址，然后将该socket绑定到找到的端口地址，这也就是UDT Socket没有bind，直接connect的情况。</p>
<ol>
<li><p>将UDT Socket的状态置为CONNECTING。</p>
</li>
<li><p>执行s-&gt;m_pUDT-&gt;connect(name)，连接UDT Server。如果连接失败，有异常抛出，UDT Socket的状态会退回到OPENED状态，然后返回。在这个函数中会完成建立连接整个的网络消息交互过程。</p>
</li>
<li><p>将连接的目标地址复制到UDT Socket的Peer Address。然后返回0表示成功结束。</p>
</li>
</ol>
<p>在仔细地分析连接建立过程中的数据包交互之前，可以先粗略地看一下这个过程收发了几个包，及各个包收发的顺序。我们知道在UDT中，所有数据包的收发都是通过CChannel完成的，我们可以在CChannel::sendto()和CChannel::recvfrom()中加log来track这一过程。通过UDT提供的demo程序appserver和appclient(在app/目录下)来研究。先在一个终端下执行appserver：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xxxxxx<span class="variable">@ThundeRobot</span><span class="symbol">:/media/data/downloads/hudt/app</span><span class="variable">$ </span>./appserver </div><div class="line">server is ready at <span class="symbol">port:</span> <span class="number">9000</span></div></pre></td></tr></table></figure></p>
<p>改造appclient，使得它只发送一个比较小的数据包就结束，编译后在另一个终端下执行，可以看到有如下的logs吐出来：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">xxxxxx<span class="variable">@ThundeRobot</span><span class="symbol">:/media/data/downloads/hudt/app</span><span class="variable">$ </span>./appclient <span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span> <span class="number">9000</span></div><div class="line">To connect</div><div class="line"><span class="symbol">CRcvQueue:</span><span class="symbol">:registerConnector</span></div><div class="line">Send packet <span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line">Receive packet <span class="number">364855723</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">364855723</span></div><div class="line">Send packet <span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line">Receive packet <span class="number">364855723</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">364855723</span></div><div class="line"></div><div class="line">To send data.</div><div class="line">send <span class="number">10</span> bytes</div><div class="line">Send packet <span class="number">1020108693</span></div><div class="line"></div><div class="line"></div><div class="line">Receive packet <span class="number">364855723</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">364855723</span></div><div class="line">Send packet <span class="number">1020108693</span></div><div class="line"></div><div class="line"></div><div class="line">Receive packet <span class="number">364855723</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">364855723</span></div><div class="line">Send packet <span class="number">1020108693</span></div><div class="line"></div><div class="line"></div><div class="line">Receive packet <span class="number">364855723</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">364855723</span></div><div class="line">Send packet <span class="number">1020108693</span></div></pre></td></tr></table></figure></p>
<p>在appclient运行的这段时间，在运行appserver的终端下的可以看到有如下的logs输出：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">xxxxxx<span class="variable">@ThundeRobot</span><span class="symbol">:/media/data/downloads/hudt/app</span><span class="variable">$ </span>./appserver </div><div class="line">server is ready at <span class="symbol">port:</span> <span class="number">9000</span></div><div class="line"></div><div class="line">Receive packet <span class="number">0</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">0</span></div><div class="line">Send packet <span class="number">364855723</span></div><div class="line"></div><div class="line"></div><div class="line">Receive packet <span class="number">0</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">0</span></div><div class="line">new CUDTSocket SocketID is <span class="number">1020108693</span> PeerID <span class="number">364855723</span></div><div class="line">Send packet <span class="number">364855723</span></div><div class="line"></div><div class="line">new <span class="symbol">connection:</span> <span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span><span class="symbol">:</span><span class="number">59847</span></div><div class="line"></div><div class="line"></div><div class="line">Receive packet <span class="number">1020108693</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">1020108693</span></div><div class="line">Send packet <span class="number">364855723</span></div><div class="line"></div><div class="line">Send packet <span class="number">364855723</span></div><div class="line"></div><div class="line">Send packet <span class="number">364855723</span></div><div class="line"></div><div class="line"></div><div class="line">Receive packet <span class="number">1020108693</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">1020108693</span></div><div class="line"></div><div class="line">Receive packet <span class="number">1020108693</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">1020108693</span></div><div class="line"></div><div class="line">Receive packet <span class="number">1020108693</span></div><div class="line">unit-&gt;m_Packet.m_iID <span class="number">1020108693</span></div><div class="line"><span class="symbol">recv:</span>Connection was broken.</div></pre></td></tr></table></figure></p>
<p>可以看到，UDT Client端先发送了一个消息MSG1给UDT Server；UDT Server端收到消息MSG1之后，回了一个消息MSG2给UDT Client；UDT Client收到消息MSG2，又回了一个消息MSG3给UDT Server；UDT Server收到消息MSG3后又回了一个消息MSG4给UDT Client，然后从UDT::accept()返回，自此UDT Server认为一个连接已经成功建立；UDT Client则在收到消息MSG4后，从UDT::connect()返回，并自此认为连接已成功建立，可以进行数据的收发了。用一幅图来描述这个过程：</p>
<p><img src="https://www.wolfcstech.com/images/1315506-eadbc50fbe607bfa.png" alt="150954_myfS_919237.png"></p>
<p>至于MSG1、2、3、4的具体格式及内容，则留待我们后面来具体分析了。</p>
<p>接着来看连接建立过程消息交互具体的实现，也就是CUDT::connect()函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CUDT::connect(<span class="keyword">const</span> sockaddr* serv_addr) &#123;</div><div class="line">    <span class="function">CGuard <span class="title">cg</span><span class="params">(m_ConnectionLock)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!m_bOpened)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_bListening)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_bConnecting || m_bConnected)</div><div class="line">        <span class="keyword">throw</span> CUDTException(<span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// record peer/server address</span></div><div class="line">    <span class="keyword">delete</span> m_pPeerAddr;</div><div class="line">    m_pPeerAddr = (AF_INET == m_iIPversion) ? (sockaddr*) <span class="keyword">new</span> sockaddr_in : (sockaddr*) <span class="keyword">new</span> sockaddr_in6;</div><div class="line">    <span class="built_in">memcpy</span>(m_pPeerAddr, serv_addr, (AF_INET == m_iIPversion) ? <span class="keyword">sizeof</span>(sockaddr_in) : <span class="keyword">sizeof</span>(sockaddr_in6));</div><div class="line"></div><div class="line">    <span class="comment">// register this socket in the rendezvous queue</span></div><div class="line">    <span class="comment">// RendezevousQueue is used to temporarily store incoming handshake, non-rendezvous connections also require this function</span></div><div class="line">    <span class="keyword">uint64_t</span> ttl = <span class="number">3000000</span>;</div><div class="line">    <span class="keyword">if</span> (m_bRendezvous)</div><div class="line">        ttl *= <span class="number">10</span>;</div><div class="line">    ttl += CTimer::getTime();</div><div class="line">    m_pRcvQueue-&gt;registerConnector(m_SocketID, <span class="keyword">this</span>, m_iIPversion, serv_addr, ttl);</div><div class="line"></div><div class="line">    <span class="comment">// This is my current configurations</span></div><div class="line">    m_ConnReq.m_iVersion = m_iVersion;</div><div class="line">    m_ConnReq.m_iType = m_iSockType;</div><div class="line">    m_ConnReq.m_iMSS = m_iMSS;</div><div class="line">    m_ConnReq.m_iFlightFlagSize = (m_iRcvBufSize &lt; m_iFlightFlagSize) ? m_iRcvBufSize : m_iFlightFlagSize;</div><div class="line">    m_ConnReq.m_iReqType = (!m_bRendezvous) ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">    m_ConnReq.m_iID = m_SocketID;</div><div class="line">    CIPAddress::ntop(serv_addr, m_ConnReq.m_piPeerIP, m_iIPversion);</div><div class="line"></div><div class="line">    <span class="comment">// Random Initial Sequence Number</span></div><div class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>) CTimer::getTime());</div><div class="line">    m_iISN = m_ConnReq.m_iISN = (<span class="keyword">int32_t</span>) (CSeqNo::m_iMaxSeqNo * (<span class="keyword">double</span>(rand()) / RAND_MAX));</div><div class="line"></div><div class="line">    m_iLastDecSeq = m_iISN - <span class="number">1</span>;</div><div class="line">    m_iSndLastAck = m_iISN;</div><div class="line">    m_iSndLastDataAck = m_iISN;</div><div class="line">    m_iSndCurrSeqNo = m_iISN - <span class="number">1</span>;</div><div class="line">    m_iSndLastAck2 = m_iISN;</div><div class="line">    m_ullSndLastAck2Time = CTimer::getTime();</div><div class="line"></div><div class="line">    <span class="comment">// Inform the server my configurations.</span></div><div class="line">    CPacket request;</div><div class="line">    <span class="keyword">char</span>* reqdata = <span class="keyword">new</span> <span class="keyword">char</span>[m_iPayloadSize];</div><div class="line">    request.pack(<span class="number">0</span>, <span class="literal">NULL</span>, reqdata, m_iPayloadSize);</div><div class="line">    <span class="comment">// ID = 0, connection request</span></div><div class="line">    request.m_iID = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> hs_size = m_iPayloadSize;</div><div class="line">    m_ConnReq.serialize(reqdata, hs_size);</div><div class="line">    request.setLength(hs_size);</div><div class="line">    m_pSndQueue-&gt;sendto(serv_addr, request);</div><div class="line">    m_llLastReqTime = CTimer::getTime();</div><div class="line"></div><div class="line">    m_bConnecting = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">// asynchronous connect, return immediately</span></div><div class="line">    <span class="keyword">if</span> (!m_bSynRecving) &#123;</div><div class="line">        <span class="keyword">delete</span>[] reqdata;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Wait for the negotiated configurations from the peer side.</span></div><div class="line">    CPacket response;</div><div class="line">    <span class="keyword">char</span>* resdata = <span class="keyword">new</span> <span class="keyword">char</span>[m_iPayloadSize];</div><div class="line">    response.pack(<span class="number">0</span>, <span class="literal">NULL</span>, resdata, m_iPayloadSize);</div><div class="line"></div><div class="line">    <span class="function">CUDTException <span class="title">e</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!m_bClosing) &#123;</div><div class="line">        <span class="comment">// avoid sending too many requests, at most 1 request per 250ms</span></div><div class="line">        <span class="keyword">if</span> (CTimer::getTime() - m_llLastReqTime &gt; <span class="number">250000</span>) &#123;</div><div class="line">            m_ConnReq.serialize(reqdata, hs_size);</div><div class="line">            request.setLength(hs_size);</div><div class="line">            <span class="keyword">if</span> (m_bRendezvous)</div><div class="line">                request.m_iID = m_ConnRes.m_iID;</div><div class="line">            m_pSndQueue-&gt;sendto(serv_addr, request);</div><div class="line">            m_llLastReqTime = CTimer::getTime();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        response.setLength(m_iPayloadSize);</div><div class="line">        <span class="keyword">if</span> (m_pRcvQueue-&gt;recvfrom(m_SocketID, response) &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (connect(response) &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="comment">// new request/response should be sent out immediately on receving a response</span></div><div class="line">            m_llLastReqTime = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (CTimer::getTime() &gt; ttl) &#123;</div><div class="line">            <span class="comment">// timeout</span></div><div class="line">            e = CUDTException(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">delete</span>[] reqdata;</div><div class="line">    <span class="keyword">delete</span>[] resdata;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (e.getErrorCode() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (m_bClosing)                                                 <span class="comment">// if the socket is closed before connection...</span></div><div class="line">            e = CUDTException(<span class="number">1</span>);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1002</span> == m_ConnRes.m_iReqType)                          <span class="comment">// connection request rejected</span></div><div class="line">            e = CUDTException(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((!m_bRendezvous) &amp;&amp; (m_iISN != m_ConnRes.m_iISN))      <span class="comment">// secuity check</span></div><div class="line">            e = CUDTException(<span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (e.getErrorCode() != <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在这个函数中主要完成了如下的这样一些事情：</p>
<ol>
<li><p>检查CUDT的状态。确保只有已经与多路复用器关联，即处于OPENED状态的UDT Socket才能执行CUDT::connect()操作。如前面看到的，bind操作可以使UDT Socket进入OPENED状态。对于没有进行过bind的UDT Socket，CUDTUnited::connect()会做这样的保证。</p>
</li>
<li><p>拷贝目标网络地址为UDT Socket的PeerAddr。</p>
</li>
<li><p>执行m_pRcvQueue-&gt;registerConnector()向接收队列注册Connector。来看这个函数的执行过程(src/queue.cpp)：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CRendezvousQueue::insert(<span class="keyword">const</span> UDTSOCKET&amp; id, CUDT* u, <span class="keyword">int</span> ipv, <span class="keyword">const</span> sockaddr* addr, <span class="keyword">uint64_t</span> ttl) &#123;</div><div class="line">    <span class="function">CGuard <span class="title">vg</span><span class="params">(m_RIDVectorLock)</span></span>;</div><div class="line"></div><div class="line">    CRL r;</div><div class="line">    r.m_iID = id;</div><div class="line">    r.m_pUDT = u;</div><div class="line">    r.m_iIPversion = ipv;</div><div class="line">    r.m_pPeerAddr = (AF_INET == ipv) ? (sockaddr*) <span class="keyword">new</span> sockaddr_in : (sockaddr*) <span class="keyword">new</span> sockaddr_in6;</div><div class="line">    <span class="built_in">memcpy</span>(r.m_pPeerAddr, addr, (AF_INET == ipv) ? <span class="keyword">sizeof</span>(sockaddr_in) : <span class="keyword">sizeof</span>(sockaddr_in6));</div><div class="line">    r.m_ullTTL = ttl;</div><div class="line"></div><div class="line">    m_lRendezvousID.push_back(r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> CRcvQueue::registerConnector(<span class="keyword">const</span> UDTSOCKET&amp; id, CUDT* u, <span class="keyword">int</span> ipv, <span class="keyword">const</span> sockaddr* addr, <span class="keyword">uint64_t</span> ttl) &#123;</div><div class="line">    m_pRendezvousQueue-&gt;insert(id, u, ipv, addr, ttl);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在这个函数中，主要是向接收队列CRcvQueue的CRendezvousQueue m_pRendezvousQueue中插入了一个CRL结构。那CRendezvousQueue又是个什么东西呢？来看它的定义(src/queue.h)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CRendezvousQueue &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    CRendezvousQueue();</div><div class="line">    ~CRendezvousQueue();</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> UDTSOCKET&amp; id, CUDT* u, <span class="keyword">int</span> ipv, <span class="keyword">const</span> sockaddr* addr, <span class="keyword">uint64_t</span> ttl)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> UDTSOCKET&amp; id)</span></span>;</div><div class="line">    <span class="function">CUDT* <span class="title">retrieve</span><span class="params">(<span class="keyword">const</span> sockaddr* addr, UDTSOCKET&amp; id)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateConnStatus</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">struct</span> CRL &#123;</div><div class="line">        UDTSOCKET m_iID;			<span class="comment">// UDT socket ID (self)</span></div><div class="line">        CUDT* m_pUDT;			<span class="comment">// UDT instance</span></div><div class="line">        <span class="keyword">int</span> m_iIPversion;                 <span class="comment">// IP version</span></div><div class="line">        sockaddr* m_pPeerAddr;		<span class="comment">// UDT sonnection peer address</span></div><div class="line">        <span class="keyword">uint64_t</span> m_ullTTL;			<span class="comment">// the time that this request expires</span></div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;CRL&gt; m_lRendezvousID;      <span class="comment">// The sockets currently in rendezvous mode</span></div><div class="line"></div><div class="line">    <span class="keyword">pthread_mutex_t</span> m_RIDVectorLock;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，它就是一个简单的容器，提供的操作也是常规的插入、移除及检索等操作：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void CRendezvousQueue::remove(<span class="keyword">const</span> UDTSOCKET&amp; id) &#123;</div><div class="line">    CGuard vg(m_RIDVectorLock);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">list</span>&lt;CRL&gt;::iterator i = m_lRendezvousID.begin(); i != m_lRendezvousID.end(); ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (i-&gt;m_iID == id) &#123;</div><div class="line">            <span class="keyword">if</span> (AF_INET == i-&gt;m_iIPversion)</div><div class="line">                delete (sockaddr_in*) i-&gt;m_pPeerAddr;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                delete (sockaddr_in6*) i-&gt;m_pPeerAddr;</div><div class="line"></div><div class="line">            m_lRendezvousID.erase(i);</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CUDT* CRendezvousQueue::retrieve(<span class="keyword">const</span> sockaddr* addr, UDTSOCKET&amp; id) &#123;</div><div class="line">    CGuard vg(m_RIDVectorLock);</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> optimize search</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">list</span>&lt;CRL&gt;::iterator i = m_lRendezvousID.begin(); i != m_lRendezvousID.end(); ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (CIPAddress::ipcmp(addr, i-&gt;m_pPeerAddr, i-&gt;m_iIPversion) &amp;&amp; ((<span class="number">0</span> == id) || (id == i-&gt;m_iID))) &#123;</div><div class="line">            id = i-&gt;m_iID;</div><div class="line">            <span class="keyword">return</span> i-&gt;m_pUDT;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那接收队列CRcvQueue是用这个队列来做什么的呢？这主要与接收队列CRcvQueue的消息dispatch机制有关。在接收队列CRcvQueue的worker线程中，接收到一条消息之后，它会根据消息的目标SocketID，及发送端的地址等信息，将消息以不同的方式进行dispatch，m_pRendezvousQueue中的CUDT是其中的一类dispatch目标。后面我们在研究消息接收时，会再来仔细研究接收队列CRcvQueue的worker线程及m_pRendezvousQueue。</p>
<ol>
<li>构造 连接请求 消息CHandShake m_ConnReq。可以看一下CHandShake的定义(src/packet.h)：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CHandShake &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    CHandShake();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">serialize</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">int</span>&amp; size)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deserialize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">int</span> size)</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> m_iContentSize;  <span class="comment">// Size of hand shake data</span></div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int32_t</span> m_iVersion;          <span class="comment">// UDT version</span></div><div class="line">    <span class="keyword">int32_t</span> m_iType;             <span class="comment">// UDT socket type</span></div><div class="line">    <span class="keyword">int32_t</span> m_iISN;              <span class="comment">// random initial sequence number</span></div><div class="line">    <span class="keyword">int32_t</span> m_iMSS;              <span class="comment">// maximum segment size</span></div><div class="line">    <span class="keyword">int32_t</span> m_iFlightFlagSize;   <span class="comment">// flow control window size</span></div><div class="line">    <span class="keyword">int32_t</span> m_iReqType;  <span class="comment">// connection request type: 1: regular connection request, 0: rendezvous connection request, -1/-2: response</span></div><div class="line">    <span class="keyword">int32_t</span> m_iID;		<span class="comment">// socket ID</span></div><div class="line">    <span class="keyword">int32_t</span> m_iCookie;		<span class="comment">// cookie</span></div><div class="line">    <span class="keyword">uint32_t</span> m_piPeerIP[<span class="number">4</span>];	<span class="comment">// The IP address that the peer's UDP port is bound to</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>CHandShake的m_iID为发起端UDT Socket的SocketID，请求类型m_iReqType将被设置为了1，还设置了m_iMSS用于协商MSS值。CHandShake的构造函数会初始化所有的字段(src/packet.cpp)：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CHandShake::CHandShake()</div><div class="line">        : m_iVersion(0),</div><div class="line">          m_iType(0),</div><div class="line">          m_iISN(0),</div><div class="line">          m_iMSS(0),</div><div class="line">          m_iFlightFlagSize(0),</div><div class="line">          m_iReqType(0),</div><div class="line">          m_iID(0),</div><div class="line">          m_iCookie_iCookie(0) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</div><div class="line">        m_piPeerIP[i] = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到m_iCookie被初始化为了0。但注意在这里，CHandShake m_ConnReq的构造过程中，m_iCookie并没有被赋予新值。</p>
<ol>
<li><p>随机初始化序列号Sequence Number。</p>
</li>
<li><p>创建一个CPacket结构request，为它创建大小为m_iPayloadSize的缓冲区，将该缓冲区pack进CPacket结构，并专门把request.m_iID，也就是这个包发送的目的UDT SocketID，设置为0。</p>
</li>
</ol>
<p>m_iPayloadSize的值根据UDT Socket创建者的不同，在不同的地方设置。由应用程序创建的UDT Socket在CUDT::open()中设置，比如Listening的UDT Socket在bind时会执行CUDT::open()，或者连接UDT Server但没有执行过bind操作的UDT Socket会在CUDTUnited::connect()中执行CUDT::open()；UDT Server中由Listening的UDT Socket收到连接请求时创建的UDT Socket，在CUDT::connect(const sockaddr<em> peer, CHandShake</em> hs)中初设置；发起连接的UDT Socket还会在CUDT::connect(const CPacket&amp; response)中再次更新这个值。但这个值总是被设置为m_iPktSize - CPacket::m_iPktHdrSize，CPacket::m_iPktHdrSize为固定的UDT Packet Header大小16。</p>
<p>m_iPktSize总是与m_iPayloadSize在相同的地方设置，被设置为m_iMSS - 28。m_iMSS，MSS（Maximum Segment Size，最大报文长度），这里是UDT协议定义的一个选项，用于在UDT连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。在CUDT对象创建时被初始化为1500，但可以通过UDT::setsockopt()进行设置。</p>
<p>这里先来看一下CPacket的结构(src/packet.h)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CPacket &#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> CChannel;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> CSndQueue;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> CRcvQueue;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int32_t</span>&amp; m_iSeqNo;                   <span class="comment">// alias: sequence number</span></div><div class="line">    <span class="keyword">int32_t</span>&amp; m_iMsgNo;                   <span class="comment">// alias: message number</span></div><div class="line">    <span class="keyword">int32_t</span>&amp; m_iTimeStamp;               <span class="comment">// alias: timestamp</span></div><div class="line">    <span class="keyword">int32_t</span>&amp; m_iID;			<span class="comment">// alias: socket ID</span></div><div class="line">    <span class="keyword">char</span>*&amp; m_pcData;                     <span class="comment">// alias: data/control information</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> m_iPktHdrSize;	<span class="comment">// packet header size</span></div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    CPacket();</div><div class="line">    ~CPacket();</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Get the payload or the control information field length.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    the payload or the control information field length.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Set the payload or the control information field length.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    0) [in] len: the payload or the control information field length.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> len)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Pack a Control packet.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    0) [in] pkttype: packet type filed.</span></div><div class="line">    <span class="comment">//    1) [in] lparam: pointer to the first data structure, explained by the packet type.</span></div><div class="line">    <span class="comment">//    2) [in] rparam: pointer to the second data structure, explained by the packet type.</span></div><div class="line">    <span class="comment">//    3) [in] size: size of rparam, in number of bytes;</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pack</span><span class="params">(<span class="keyword">int</span> pkttype, <span class="keyword">void</span>* lparam = <span class="literal">NULL</span>, <span class="keyword">void</span>* rparam = <span class="literal">NULL</span>, <span class="keyword">int</span> size = <span class="number">0</span>)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Read the packet vector.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    Pointer to the packet vector.</span></div><div class="line"></div><div class="line">    <span class="function">iovec* <span class="title">getPacketVector</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Read the packet flag.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    packet flag (0 or 1).</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFlag</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Read the packet type.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    packet type filed (000 ~ 111).</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Read the extended packet type.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    extended packet type filed (0x000 ~ 0xFFF).</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getExtendedType</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Read the ACK-2 seq. no.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    packet header field (bit 16~31).</span></div><div class="line"></div><div class="line">    <span class="keyword">int32_t</span> getAckSeqNo() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Read the message boundary flag bit.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    packet header field [1] (bit 0~1).</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMsgBoundary</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Read the message inorder delivery flag bit.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    packet header field [1] (bit 2).</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getMsgOrderFlag</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Read the message sequence number.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    packet header field [1] (bit 3~31).</span></div><div class="line"></div><div class="line">    <span class="keyword">int32_t</span> getMsgSeq() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Functionality:</span></div><div class="line">    <span class="comment">//    Clone this packet.</span></div><div class="line">    <span class="comment">// Parameters:</span></div><div class="line">    <span class="comment">//    None.</span></div><div class="line">    <span class="comment">// Returned value:</span></div><div class="line">    <span class="comment">//    Pointer to the new packet.</span></div><div class="line"></div><div class="line">    <span class="function">CPacket* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">uint32_t</span> m_nHeader[<span class="number">4</span>];               <span class="comment">// The 128-bit header field</span></div><div class="line">    iovec m_PacketVector[<span class="number">2</span>];             <span class="comment">// The 2-demension vector of UDT packet [header, data]</span></div><div class="line"></div><div class="line">    <span class="keyword">int32_t</span> __pad;</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">    CPacket&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CPacket&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>它的数据成员是有4个uint32_t元素的数组m_nHeader，描述UDT Packet的Header，和有两个元素的iovec数组m_PacketVector。另外的几个引用则主要是为了方便对这些数据成员的访问，看下CPacket的构造函数就一目了然了(src/packet.cpp)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set up the aliases in the constructure</span></div><div class="line">CPacket::CPacket()</div><div class="line">        : m_iSeqNo((<span class="keyword">int32_t</span>&amp;) (m_nHeader[<span class="number">0</span>])),</div><div class="line">          m_iMsgNo((<span class="keyword">int32_t</span>&amp;) (m_nHeader[<span class="number">1</span>])),</div><div class="line">          m_iTimeStamp((<span class="keyword">int32_t</span>&amp;) (m_nHeader[<span class="number">2</span>])),</div><div class="line">          m_iID((<span class="keyword">int32_t</span>&amp;) (m_nHeader[<span class="number">3</span>])),</div><div class="line">          m_pcData((<span class="keyword">char</span>*&amp;) (m_PacketVector[<span class="number">1</span>].iov_base)),</div><div class="line">          __pad() &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</div><div class="line">        m_nHeader[i] = <span class="number">0</span>;</div><div class="line">    m_PacketVector[<span class="number">0</span>].iov_base = (<span class="keyword">char</span> *) m_nHeader;</div><div class="line">    m_PacketVector[<span class="number">0</span>].iov_len = CPacket::m_iPktHdrSize;</div><div class="line">    m_PacketVector[<span class="number">1</span>].iov_base = <span class="literal">NULL</span>;</div><div class="line">    m_PacketVector[<span class="number">1</span>].iov_len = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意m_PacketVector的第一个元素指向了m_nHeader。</p>
<p>在CPacket::pack()中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CPacket::pack(<span class="keyword">int</span> pkttype, <span class="keyword">void</span>* lparam, <span class="keyword">void</span>* rparam, <span class="keyword">int</span> size) &#123;</div><div class="line">    <span class="comment">// Set (bit-0 = 1) and (bit-1~15 = type)</span></div><div class="line">    m_nHeader[<span class="number">0</span>] = <span class="number">0x80000000</span> | (pkttype &lt;&lt; <span class="number">16</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set additional information and control information field</span></div><div class="line">    <span class="keyword">switch</span> (pkttype) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//0010 - Acknowledgement (ACK)</span></div><div class="line">            <span class="comment">// ACK packet seq. no.</span></div><div class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != lparam)</div><div class="line">                m_nHeader[<span class="number">1</span>] = *(<span class="keyword">int32_t</span> *) lparam;</div><div class="line"></div><div class="line">            <span class="comment">// data ACK seq. no.</span></div><div class="line">            <span class="comment">// optional: RTT (microsends), RTT variance (microseconds) advertised flow window size (packets), and estimated link capacity (packets per second)</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) rparam;</div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_len = size;</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="number">6</span>:  <span class="comment">//0110 - Acknowledgement of Acknowledgement (ACK-2)</span></div><div class="line">            <span class="comment">// ACK packet seq. no.</span></div><div class="line">            m_nHeader[<span class="number">1</span>] = *(<span class="keyword">int32_t</span> *) lparam;</div><div class="line"></div><div class="line">            <span class="comment">// control info field should be none</span></div><div class="line">            <span class="comment">// but "writev" does not allow this</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) &amp;__pad;  <span class="comment">//NULL;</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_len = <span class="number">4</span>;  <span class="comment">//0;</span></div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//0011 - Loss Report (NAK)</span></div><div class="line">            <span class="comment">// loss list</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) rparam;</div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_len = size;</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="number">4</span>:  <span class="comment">//0100 - Congestion Warning</span></div><div class="line">            <span class="comment">// control info field should be none</span></div><div class="line">            <span class="comment">// but "writev" does not allow this</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) &amp;__pad;  <span class="comment">//NULL;</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_len = <span class="number">4</span>;  <span class="comment">//0;</span></div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//0001 - Keep-alive</span></div><div class="line">            <span class="comment">// control info field should be none</span></div><div class="line">            <span class="comment">// but "writev" does not allow this</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) &amp;__pad;  <span class="comment">//NULL;</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_len = <span class="number">4</span>;  <span class="comment">//0;</span></div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//0000 - Handshake</span></div><div class="line">            <span class="comment">// control info filed is handshake info</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) rparam;</div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_len = size;  <span class="comment">//sizeof(CHandShake);</span></div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="number">5</span>:  <span class="comment">//0101 - Shutdown</span></div><div class="line">            <span class="comment">// control info field should be none</span></div><div class="line">            <span class="comment">// but "writev" does not allow this</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) &amp;__pad;  <span class="comment">//NULL;</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_len = <span class="number">4</span>;  <span class="comment">//0;</span></div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="number">7</span>:  <span class="comment">//0111 - Message Drop Request</span></div><div class="line">            <span class="comment">// msg id</span></div><div class="line">            m_nHeader[<span class="number">1</span>] = *(<span class="keyword">int32_t</span> *) lparam;</div><div class="line"></div><div class="line">            <span class="comment">//first seq no, last seq no</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) rparam;</div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_len = size;</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="number">8</span>:  <span class="comment">//1000 - Error Signal from the Peer Side</span></div><div class="line">            <span class="comment">// Error type</span></div><div class="line">            m_nHeader[<span class="number">1</span>] = *(<span class="keyword">int32_t</span> *) lparam;</div><div class="line"></div><div class="line">            <span class="comment">// control info field should be none</span></div><div class="line">            <span class="comment">// but "writev" does not allow this</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) &amp;__pad;  <span class="comment">//NULL;</span></div><div class="line">            m_PacketVector[<span class="number">1</span>].iov_len = <span class="number">4</span>;  <span class="comment">//0;</span></div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="number">32767</span>:  <span class="comment">//0x7FFF - Reserved for user defined control packets</span></div><div class="line">            <span class="comment">// for extended control packet</span></div><div class="line">            <span class="comment">// "lparam" contains the extended type information for bit 16 - 31</span></div><div class="line">            <span class="comment">// "rparam" is the control information</span></div><div class="line">            m_nHeader[<span class="number">0</span>] |= *(<span class="keyword">int32_t</span> *) lparam;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != rparam) &#123;</div><div class="line">                m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) rparam;</div><div class="line">                m_PacketVector[<span class="number">1</span>].iov_len = size;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                m_PacketVector[<span class="number">1</span>].iov_base = (<span class="keyword">char</span> *) &amp;__pad;</div><div class="line">                m_PacketVector[<span class="number">1</span>].iov_len = <span class="number">4</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CPacket::pack()中，首先将m_nHeader[0]，也就是m_iSeqNo的bit-0设为1表示这是一个控制包，将bit-1～15设置为消息的类型，然后根据消息的不同类型进行不同的处理。对于Handshake消息，其pkttype为0，这里主要关注pkttype为0的case。可见它就是让m_PacketVector[1]指向前面创建的缓冲区。</p>
<ol>
<li>将Handshake消息m_ConnReq序列化进前面创建的缓冲区，并正确地设置CPacket request的长度：</li>
</ol>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void CPacket::setLength(int len) &#123;</div><div class="line">    m_PacketVector[<span class="number">1</span>].iov_len = len<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int CHandShake::serialize(char* <span class="keyword">buf, </span>int&amp; size) &#123;</div><div class="line">    if (size &lt; m_iContentSize)</div><div class="line">        return -<span class="number">1</span><span class="comment">;</span></div><div class="line"></div><div class="line">    int32_t* p = (int32_t*) <span class="keyword">buf;</span></div><div class="line">    *p++ = m_iVersion<span class="comment">;</span></div><div class="line">    *p++ = m_iType<span class="comment">;</span></div><div class="line">    *p++ = m_iISN<span class="comment">;</span></div><div class="line">    *p++ = m_iMSS<span class="comment">;</span></div><div class="line">    *p++ = m_iFlightFlagSize<span class="comment">;</span></div><div class="line">    *p++ = m_iReqType<span class="comment">;</span></div><div class="line">    *p++ = m_iID<span class="comment">;</span></div><div class="line">    *p++ = m_iCookie<span class="comment">;</span></div><div class="line">    for (int i = <span class="number">0</span><span class="comment">; i &lt; 4; ++i)</span></div><div class="line">        *p++ = m_piPeerIP[i]<span class="comment">;</span></div><div class="line"></div><div class="line">    size = m_iContentSize<span class="comment">;</span></div><div class="line"></div><div class="line">    return <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>序列化时，会将Handshake消息m_ConnReq全部的内容拷贝进缓冲区。略感奇怪，这个地方竟然完全没有顾及字节序的问题。</p>
<ol>
<li>调用发送队列的sendto()函数，向目标地址发送消息：</li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CSndQueue::sendto(<span class="keyword">const</span> sockaddr* addr, CPacket&amp; packet) &#123;</div><div class="line">    <span class="comment">// send out the packet immediately (high priority), this is a control packet</span></div><div class="line">    m_pChannel-&gt;sendto(addr, packet);</div><div class="line">    <span class="function"><span class="keyword">return</span> packet.<span class="title">getLength</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CSndQueue的sendto()函数直接调用了CChannel::sendto()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CChannel::sendto(<span class="keyword">const</span> sockaddr* addr, CPacket&amp; packet) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CChannel send packet "</span> &lt;&lt; packet.m_iID &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// convert control information into network order</span></div><div class="line">    <span class="keyword">if</span> (packet.getFlag())</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = packet.getLength() / <span class="number">4</span>; i &lt; n; ++i)</div><div class="line">            *((<span class="keyword">uint32_t</span> *) packet.m_pcData + i) = htonl(*((<span class="keyword">uint32_t</span> *) packet.m_pcData + i));</div><div class="line"></div><div class="line">    <span class="comment">// convert packet header into network order</span></div><div class="line">    <span class="comment">//for (int j = 0; j &lt; 4; ++ j)</span></div><div class="line">    <span class="comment">//   packet.m_nHeader[j] = htonl(packet.m_nHeader[j]);</span></div><div class="line">    <span class="keyword">uint32_t</span>* p = packet.m_nHeader;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</div><div class="line">        *p = htonl(*p);</div><div class="line">        ++p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></div><div class="line">    msghdr mh;</div><div class="line">    mh.msg_name = (sockaddr*) addr;</div><div class="line">    mh.msg_namelen = m_iSockAddrSize;</div><div class="line">    mh.msg_iov = (iovec*) packet.m_PacketVector;</div><div class="line">    mh.msg_iovlen = <span class="number">2</span>;</div><div class="line">    mh.msg_control = <span class="literal">NULL</span>;</div><div class="line">    mh.msg_controllen = <span class="number">0</span>;</div><div class="line">    mh.msg_flags = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> res = ::sendmsg(m_iSocket, &amp;mh, <span class="number">0</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    DWORD size = CPacket::m_iPktHdrSize + packet.getLength();</div><div class="line">    <span class="keyword">int</span> addrsize = m_iSockAddrSize;</div><div class="line">    <span class="keyword">int</span> res = ::WSASendTo(m_iSocket, (LPWSABUF)packet.m_PacketVector, <span class="number">2</span>, &amp;size, <span class="number">0</span>, addr, addrsize, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    res = (<span class="number">0</span> == res) ? size : <span class="number">-1</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="comment">// convert back into local host order</span></div><div class="line">    <span class="comment">//for (int k = 0; k &lt; 4; ++ k)</span></div><div class="line">    <span class="comment">//   packet.m_nHeader[k] = ntohl(packet.m_nHeader[k]);</span></div><div class="line">    p = packet.m_nHeader;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</div><div class="line">        *p = ntohl(*p);</div><div class="line">        ++p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (packet.getFlag()) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, n = packet.getLength() / <span class="number">4</span>; l &lt; n; ++l)</div><div class="line">            *((<span class="keyword">uint32_t</span> *) packet.m_pcData + l) = ntohl(*((<span class="keyword">uint32_t</span> *) packet.m_pcData + l));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在CChannel::sendto()中会处理Header的字节序问题。</p>
<p>这里总结一下，UDT Client向UDT Server发送的连接建立请求消息的内容：消息主要分为两个部分一个是消息的Header，一个是消息的Content。Header为4个uint32_t类型变量，从前到后这4个变量的含义分别为sequence number，message number，timestamp和目标SocketID。就Handshake而言，sequence number的最高位，也就是bit-0为1，表示这是一个控制消息，bit-1~15为pkttype 0，其它位为0；message number及timestamp均为0，目标SocketID为0。</p>
<p>Content部分，总共48个字节，主要用于进行连接的协商，如MSS等，具体可以看CHandShake。</p>
<ol>
<li>检查是否是同步接收模式。如果不是的话，则delete掉前面为request CPacket的CHandShake创建的缓冲区并退出。后面与UDT Server端进一步的消息交互会有接收队列等帮忙异步地推动。否则继续执行。值得一提的是，CUDT在其构造函数中，会将m_bSynRecving置为true，但在拷贝构造函数中，则会继承传入的值。但这个值如同MSS值一样，也可以通过UDT::setOpt()设置。也就是说由应用程序创建的UDT Socket默认处于同步接收模式，比如Listening的UDT Socket和发起连接的UDT Socket，但可以自行设置，由Listening的UDT Socket在接收到连接建立请求时创建的UDT Socket，则会继承Listening UDT Socket的对应值。</li>
</ol>
<p>我们暂时先看SynRecving模式，也就是默认模式下的UDT Socket的行为。</p>
<ol>
<li><p>创建一个CPacket response，同样为它创建一个大小为m_iPayloadSize的缓冲区以存放数据，并将缓冲区pack进response中。这个CPacket response会被用来存放从UDT Server发回的相应的信息。</p>
</li>
<li><p>进入一个循环执行后续的握手动作，及消息的超时重传等动作。可以将这个循环看做由3个部分组成。</p>
</li>
</ol>
<p>循环开始的地方是一段发送消息的代码，在这段代码中，其实做了两个事情，或者说可能会发送两种类型的消息，一是第一个握手消息的超时重传，二是第二个握手消息的发送及超时重传。看上去发送的都是CHandShake m_ConnReq，但在接收到第一个握手消息的响应之后，这个结构的某些成员会根据响应而被修改。注意，发送第一个握手消息之后，首次进入循环，将会跳过这个部分。</p>
<p>之后的第二部分，主要用于接收响应，第一个握手消息的响应及第二个握手消息的响应。来看CRcvQueue::recvfrom()(src/queue.cpp)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CRcvQueue::recvfrom(<span class="keyword">int32_t</span> id, CPacket&amp; packet) &#123;</div><div class="line">    <span class="function">CGuard <span class="title">bufferlock</span><span class="params">(m_PassLock)</span></span>;</div><div class="line"></div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int32_t</span>, <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;CPacket*&gt; &gt;::iterator i = m_mBuffer.find(id);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (i == m_mBuffer.end()) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></div><div class="line">        <span class="keyword">uint64_t</span> now = CTimer::getTime();</div><div class="line">        timespec timeout;</div><div class="line"></div><div class="line">        timeout.tv_sec = now / <span class="number">1000000</span> + <span class="number">1</span>;</div><div class="line">        timeout.tv_nsec = (now % <span class="number">1000000</span>) * <span class="number">1000</span>;</div><div class="line"></div><div class="line">        pthread_cond_timedwait(&amp;m_PassCond, &amp;m_PassLock, &amp;timeout);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        ReleaseMutex(m_PassLock);</div><div class="line">        WaitForSingleObject(m_PassCond, <span class="number">1000</span>);</div><div class="line">        WaitForSingleObject(m_PassLock, INFINITE);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        i = m_mBuffer.find(id);</div><div class="line">        <span class="keyword">if</span> (i == m_mBuffer.end()) &#123;</div><div class="line">            packet.setLength(<span class="number">-1</span>);</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// retrieve the earliest packet</span></div><div class="line">    CPacket* newpkt = i-&gt;second.front();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (packet.getLength() &lt; newpkt-&gt;getLength()) &#123;</div><div class="line">        packet.setLength(<span class="number">-1</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// copy packet content</span></div><div class="line">    <span class="built_in">memcpy</span>(packet.m_nHeader, newpkt-&gt;m_nHeader, CPacket::m_iPktHdrSize);</div><div class="line">    <span class="built_in">memcpy</span>(packet.m_pcData, newpkt-&gt;m_pcData, newpkt-&gt;getLength());</div><div class="line">    packet.setLength(newpkt-&gt;getLength());</div><div class="line"></div><div class="line">    <span class="keyword">delete</span>[] newpkt-&gt;m_pcData;</div><div class="line">    <span class="keyword">delete</span> newpkt;</div><div class="line"></div><div class="line">    <span class="comment">// remove this message from queue,</span></div><div class="line">    <span class="comment">// if no more messages left for this socket, release its data structure</span></div><div class="line">    i-&gt;second.pop();</div><div class="line">    <span class="keyword">if</span> (i-&gt;second.empty())</div><div class="line">        m_mBuffer.erase(i);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> packet.getLength();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这也是一个生产者-消费者模型，在这里就如同listen的过程一样，也只能看到这个生产与消费的故事的一半，即消费的那一半。生产者也是RcvQueue的worker线程。这个地方会等待着消息的到来，但也不会无限制的等待，可以看到，这里接收消息的等待时间大概为1s。这里是在等待一个CPacket队列的出现，也就是m_mBuffer中目标UDT Socket的CPacket队列。这里会从这个队列中取出第一个packet返回给调用者。如果队列被取空了，会直接将这个队列从m_mBuffer中移除出去。</p>
<p>循环的第三部分是整个连接建立消息交互过程的超时处理，可以看到，非Rendezvous模式下超时时间为3s，Rendezvous模式下，超时时间则会延长十倍。</p>
<p>CUDT::connect()执行到接收第一个握手消息的相应时，连接建立请求的发起也算是基本完成了。下面来看UDT Server端收到这个消息时是如何处理的。</p>
<h1 id="UDT-Server对首个Handshake消息的处理"><a href="#UDT-Server对首个Handshake消息的处理" class="headerlink" title="UDT Server对首个Handshake消息的处理"></a>UDT Server对首个Handshake消息的处理</h1><p>来看UDT Server端收到这个消息时是如何处理的。如我们前面在 <a href="http://my.oschina.net/wolfcs/blog/503959" target="_blank" rel="external">UDT协议实现分析——bind、listen与accept</a> 一文中了解到的，Listening的UDT Socket会在UDT::accept()中等待连接请求进来，那是一个生产者与消费者的故事，UDT::accept()是生产者，接收队列RcvQueue的worker线程是消费者。</p>
<p>我们这就来仔细地看一下RcvQueue的worker线程，当然重点会关注对于Handshake消息，也就是目标SocketID为0，pkttype为0的packet的处理(src/queue.cpp)：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">#ifndef WIN32</div><div class="line">void* CRcvQueue::worker(void* param)</div><div class="line">#<span class="keyword">else</span></div><div class="line">        DWORD WINAPI CRcvQueue::worker(LPVOID param)</div><div class="line">#endif</div><div class="line">        &#123;</div><div class="line">    CRcvQueue* self = (CRcvQueue*) param;</div><div class="line"></div><div class="line">    sockaddr* addr =</div><div class="line">            (AF_INET == <span class="function"><span class="title">self</span>-&gt;</span>m_UnitQueue.m_iIPversion) ? (sockaddr*) new sockaddr_in : (sockaddr*) new sockaddr_in6;</div><div class="line">    CUDT* u = NULL;</div><div class="line">    int32_t id;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">while</span> (!self-&gt;</span>m_bClosing) &#123;</div><div class="line">#ifdef NO_BUSY_WAITING</div><div class="line">        <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pTimer</span>-&gt;</span>tick();</div><div class="line">#endif</div><div class="line"></div><div class="line">        <span class="comment">// check waiting list, if new socket, insert it to the list</span></div><div class="line">        <span class="function"><span class="title">while</span> (self-&gt;</span>ifNewEntry()) &#123;</div><div class="line">            CUDT* <span class="function"><span class="title">ne</span> = self-&gt;</span>getNewEntry();</div><div class="line">            <span class="keyword">if</span> (NULL != ne) &#123;</div><div class="line">                <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pRcvUList</span>-&gt;</span>insert(ne);</div><div class="line">                <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pHash</span>-&gt;</span><span class="function"><span class="title">insert</span>(ne-&gt;</span>m_SocketID, ne);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// find next available slot for incoming packet</span></div><div class="line">        CU<span class="function"><span class="title">nit</span>* unit = self-&gt;</span>m_UnitQueue.getNextAvailUnit();</div><div class="line">        <span class="keyword">if</span> (NULL == unit) &#123;</div><div class="line">            <span class="comment">// no space, skip this packet</span></div><div class="line">            CPacket temp;</div><div class="line">            <span class="function"><span class="title">temp</span>.m_pcData = new char[self-&gt;</span>m_iPayloadSize];</div><div class="line">            <span class="function"><span class="title">temp</span>.setLength(self-&gt;</span>m_iPayloadSize);</div><div class="line">            <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pChannel</span>-&gt;</span>recvfrom(addr, temp);</div><div class="line">            delete[] temp.m_pcData;</div><div class="line">            goto TIMER_CHECK;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="title">unit</span>-&gt;</span><span class="function"><span class="title">m_Packet</span>.setLength(self-&gt;</span>m_iPayloadSize);</div><div class="line"></div><div class="line">        <span class="comment">// reading next incoming packet, recvfrom returns -1 is nothing has been received</span></div><div class="line">        <span class="function"><span class="title">if</span> (self-&gt;</span><span class="function"><span class="title">m_pChannel</span>-&gt;</span><span class="function"><span class="title">recvfrom</span>(addr, unit-&gt;</span>m_Packet) &lt; <span class="number">0</span>)</div><div class="line">            goto TIMER_CHECK;</div><div class="line"></div><div class="line">        <span class="function"><span class="title">id</span> = unit-&gt;</span>m_Packet.m_iID;</div><div class="line"></div><div class="line">        <span class="comment">// ID 0 is for connection request, which should be passed to the listening socket or rendezvous sockets</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == id) &#123;</div><div class="line">            <span class="function"><span class="title">if</span> (NULL != self-&gt;</span>m_pListener)</div><div class="line">                <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pListener</span>-&gt;</span><span class="function"><span class="title">listen</span>(addr, unit-&gt;</span>m_Packet);</div><div class="line">            <span class="function"><span class="title">else</span> <span class="keyword">if</span> (NULL != (u = self-&gt;</span><span class="function"><span class="title">m_pRendezvousQueue</span>-&gt;</span>retrieve(addr, id))) &#123;</div><div class="line">                <span class="comment">// asynchronous connect: call connect here</span></div><div class="line">                <span class="comment">// otherwise wait for the UDT socket to retrieve this packet</span></div><div class="line">                <span class="function"><span class="title">if</span> (!u-&gt;</span>m_bSynRecving)</div><div class="line">                    <span class="function"><span class="title">u</span>-&gt;</span><span class="function"><span class="title">connect</span>(unit-&gt;</span>m_Packet);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">storePkt</span>(id, unit-&gt;</span>m_Packet.clone());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="function"><span class="title">if</span> (NULL != (u = self-&gt;</span><span class="function"><span class="title">m_pHash</span>-&gt;</span>lookup(id))) &#123;</div><div class="line">                <span class="function"><span class="title">if</span> (CIPAddress::ipcmp(addr, u-&gt;</span><span class="function"><span class="title">m_pPeerAddr</span>, u-&gt;</span>m_iIPversion)) &#123;</div><div class="line">                    <span class="function"><span class="title">if</span> (u-&gt;</span><span class="function"><span class="title">m_bConnected</span> &amp;&amp; !u-&gt;</span><span class="function"><span class="title">m_bBroken</span> &amp;&amp; !u-&gt;</span>m_bClosing) &#123;</div><div class="line">                        <span class="function"><span class="title">if</span> (0 == unit-&gt;</span>m_Packet.getFlag())</div><div class="line">                            <span class="function"><span class="title">u</span>-&gt;</span>processData(unit);</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            <span class="function"><span class="title">u</span>-&gt;</span><span class="function"><span class="title">processCtrl</span>(unit-&gt;</span>m_Packet);</div><div class="line"></div><div class="line">                        <span class="function"><span class="title">u</span>-&gt;</span>checkTimers();</div><div class="line">                        <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pRcvUList</span>-&gt;</span>update(u);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (NULL != (u = self-&gt;</span><span class="function"><span class="title">m_pRendezvousQueue</span>-&gt;</span>retrieve(addr, id))) &#123;</div><div class="line">                <span class="function"><span class="title">if</span> (!u-&gt;</span>m_bSynRecving)</div><div class="line">                    <span class="function"><span class="title">u</span>-&gt;</span><span class="function"><span class="title">connect</span>(unit-&gt;</span>m_Packet);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">storePkt</span>(id, unit-&gt;</span>m_Packet.clone());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        TIMER_CHECK:</div><div class="line">        <span class="comment">// take care of the timing event for all UDT sockets</span></div><div class="line"></div><div class="line">        uint64_t currtime;</div><div class="line">        CTimer::rdtsc(currtime);</div><div class="line"></div><div class="line">        CRN<span class="function"><span class="title">ode</span>* ul = self-&gt;</span><span class="function"><span class="title">m_pRcvUList</span>-&gt;</span>m_pUList;</div><div class="line">        uint64_t ctime = currtime - <span class="number">100000</span> * CTimer::getCPUFrequency();</div><div class="line">        <span class="function"><span class="title">while</span> ((NULL != ul) &amp;&amp; (ul-&gt;</span>m_llTimeStamp &lt; ctime)) &#123;</div><div class="line">            CUDT* <span class="function"><span class="title">u</span> = ul-&gt;</span>m_pUDT;</div><div class="line"></div><div class="line">            <span class="function"><span class="title">if</span> (u-&gt;</span><span class="function"><span class="title">m_bConnected</span> &amp;&amp; !u-&gt;</span><span class="function"><span class="title">m_bBroken</span> &amp;&amp; !u-&gt;</span>m_bClosing) &#123;</div><div class="line">                <span class="function"><span class="title">u</span>-&gt;</span>checkTimers();</div><div class="line">                <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pRcvUList</span>-&gt;</span>update(u);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// the socket must be removed from Hash table first, then RcvUList</span></div><div class="line">                <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pHash</span>-&gt;</span><span class="function"><span class="title">remove</span>(u-&gt;</span>m_SocketID);</div><div class="line">                <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pRcvUList</span>-&gt;</span>remove(u);</div><div class="line">                <span class="function"><span class="title">u</span>-&gt;</span><span class="function"><span class="title">m_pRNode</span>-&gt;</span>m_bOnList = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="title">ul</span> = self-&gt;</span><span class="function"><span class="title">m_pRcvUList</span>-&gt;</span>m_pUList;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Check connection requests status for all sockets in the RendezvousQueue.</span></div><div class="line">        <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pRendezvousQueue</span>-&gt;</span>updateConnStatus();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">if</span> (AF_INET == self-&gt;</span>m_UnitQueue.m_iIPversion)</div><div class="line">        delete (sockaddr_in*) addr;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        delete (sockaddr_in6*) addr;</div><div class="line"></div><div class="line">#ifndef WIN32</div><div class="line">    return NULL;</div><div class="line">#<span class="keyword">else</span></div><div class="line">    S<span class="function"><span class="title">etEvent</span>(self-&gt;</span>m_ExitCond);</div><div class="line">    return <span class="number">0</span>;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数，首先创建了一个sockaddr，用于保存发送端的地址。</p>
<p>然后就进入了一个循环，不断地接收UDP消息。</p>
<p>循环内的第一行是执行Timer的tick()，这个是UDT自己的定时器Timer机制的一部分。</p>
<p>接下来的这个子循环也主要与RcvQueue的worker线程中消息的dispatch机制有关。</p>
<p>然后是取一个CUnit，用来接收其它端点发送过来的消息。如果取不到，则接收UDP包并丢弃。然后跳过后面消息dispatch的过程。这个地方的m_UnitQueue用来做缓存，也用来防止收到过多的包消耗过多的资源。完整的CUnitQueue机制暂时先不去仔细分析。</p>
<p>然后就是取到了CUnit的情况，则先通过CChannel接收一个包，并根据包的内容进行包的dispatch。不能跑偏了，这里主要关注目标SocketID为0，pkttype为0的包的dispatch。可以看到，在Listener存在的情况下，是dispatch给了listener，也就是Listening的UDT Socket的CUDT的listen()函数，否则会dispatch给通道上处于Rendezvous模式的UDT Socket。（在 <a href="http://my.oschina.net/wolfcs/blog/503959" target="_blank" rel="external">UDT协议实现分析——bind、listen与accept</a> 一文中关于listen的部分有具体理过这个listener的设置过程。）可以看到，对于相同的通道CChannel，也就是同一个端口上，Rendezvous模式下的UDT Socket和Listening的UDT Socket不能共存，或者说同时存在时，Rendezvous的行为可能不是预期的，但多个处于Rendezvous模式下的UDT Socket可以共存。</p>
<p>接收队列CRcvQueue的worker()线程做的其它事情，暂时先不去仔细看。这里先来理一下Listening的UDT Socket在接收到Handshake消息的处理过程，也就是CUDT::listen(sockaddr* addr, CPacket&amp; packet)(src/core.cpp)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CUDT::listen(sockaddr* addr, CPacket&amp; packet) &#123;</div><div class="line">    <span class="keyword">if</span> (m_bClosing)</div><div class="line">        <span class="keyword">return</span> <span class="number">1002</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (packet.getLength() != CHandShake::m_iContentSize)</div><div class="line">        <span class="keyword">return</span> <span class="number">1004</span>;</div><div class="line"></div><div class="line">    CHandShake hs;</div><div class="line">    hs.deserialize(packet.m_pcData, packet.getLength());</div><div class="line"></div><div class="line">    <span class="comment">// SYN cookie</span></div><div class="line">    <span class="keyword">char</span> clienthost[NI_MAXHOST];</div><div class="line">    <span class="keyword">char</span> clientport[NI_MAXSERV];</div><div class="line">    getnameinfo(addr, (AF_INET == m_iVersion) ? <span class="keyword">sizeof</span>(sockaddr_in) : <span class="keyword">sizeof</span>(sockaddr_in6), clienthost,</div><div class="line">                <span class="keyword">sizeof</span>(clienthost), clientport, <span class="keyword">sizeof</span>(clientport), NI_NUMERICHOST | NI_NUMERICSERV);</div><div class="line">    int64_t timestamp = (CTimer::getTime() - m_StartTime) / <span class="number">60000000</span>;  <span class="comment">// secret changes every one minute</span></div><div class="line">    stringstream cookiestr;</div><div class="line">    cookiestr &lt;&lt; clienthost &lt;&lt; <span class="string">":"</span> &lt;&lt; clientport &lt;&lt; <span class="string">":"</span> &lt;&lt; timestamp;</div><div class="line">    unsigned <span class="keyword">char</span> cookie[<span class="number">16</span>];</div><div class="line">    CMD5::compute(cookiestr.<span class="keyword">str</span>().c_str(), cookie);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> == hs.m_iReqType) &#123;</div><div class="line">        hs.m_iCookie = *(<span class="keyword">int</span>*) cookie;</div><div class="line">        packet.m_iID = hs.m_iID;</div><div class="line">        <span class="keyword">int</span> size = packet.getLength();</div><div class="line">        hs.serialize(packet.m_pcData, size);</div><div class="line">        m_pSndQueue-&gt;sendto(addr, packet);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (hs.m_iCookie != *(<span class="keyword">int</span>*) cookie) &#123;</div><div class="line">            timestamp--;</div><div class="line">            cookiestr &lt;&lt; clienthost &lt;&lt; <span class="string">":"</span> &lt;&lt; clientport &lt;&lt; <span class="string">":"</span> &lt;&lt; timestamp;</div><div class="line">            CMD5::compute(cookiestr.<span class="keyword">str</span>().c_str(), cookie);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (hs.m_iCookie != *(<span class="keyword">int</span>*) cookie)</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int32_t id = hs.m_iID;</div><div class="line"></div><div class="line">    <span class="comment">// When a peer side connects in...</span></div><div class="line">    <span class="keyword">if</span> ((<span class="number">1</span> == packet.getFlag()) &amp;&amp; (<span class="number">0</span> == packet.getType())) &#123;</div><div class="line">        <span class="keyword">if</span> ((hs.m_iVersion != m_iVersion) || (hs.m_iType != m_iSockType)) &#123;</div><div class="line">            <span class="comment">// mismatch, reject the request</span></div><div class="line">            hs.m_iReqType = <span class="number">1002</span>;</div><div class="line">            <span class="keyword">int</span> size = CHandShake::m_iContentSize;</div><div class="line">            hs.serialize(packet.m_pcData, size);</div><div class="line">            packet.m_iID = id;</div><div class="line">            m_pSndQueue-&gt;sendto(addr, packet);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> result = s_UDTUnited.newConnection(m_SocketID, addr, &amp;hs);</div><div class="line">            <span class="keyword">if</span> (result == -<span class="number">1</span>)</div><div class="line">                hs.m_iReqType = <span class="number">1002</span>;</div><div class="line"></div><div class="line">            <span class="comment">// send back a response if connection failed or connection already existed</span></div><div class="line">            <span class="comment">// new connection response should be sent in connect()</span></div><div class="line">            <span class="keyword">if</span> (result != <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">int</span> size = CHandShake::m_iContentSize;</div><div class="line">                hs.serialize(packet.m_pcData, size);</div><div class="line">                packet.m_iID = id;</div><div class="line">                m_pSndQueue-&gt;sendto(addr, packet);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// a new connection has been created, enable epoll for write</span></div><div class="line">                s_UDTUnited.m_EPoll.update_events(m_SocketID, m_sPollID, UDT_EPOLL_OUT, <span class="literal">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> hs.m_iReqType;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中主要做了这样的一些事情：</p>
<ol>
<li><p>检查UDT Socket的状态，如果处于Closing状态下，就返回，否则继续执行。</p>
</li>
<li><p>检查包的数据部分长度。若长度不为CHandShake::m_iContentSize 48字节，则说明这不是一个有效的Handshake，则返回，否则继续执行。</p>
</li>
<li><p>创建一个CHandShake hs，并将传入的packet的数据部分反序列化进这个CHandShake。这里来扫一眼这个CHandShake::deserialize()(src/packet.cpp)：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int CHandShake::deserialize(const char* <span class="keyword">buf, </span>int size) &#123;</div><div class="line">    if (size &lt; m_iContentSize)</div><div class="line">        return -<span class="number">1</span><span class="comment">;</span></div><div class="line"></div><div class="line">    int32_t* p = (int32_t*) <span class="keyword">buf;</span></div><div class="line">    m_iVersion = *p++<span class="comment">;</span></div><div class="line">    m_iType = *p++<span class="comment">;</span></div><div class="line">    m_iISN = *p++<span class="comment">;</span></div><div class="line">    m_iMSS = *p++<span class="comment">;</span></div><div class="line">    m_iFlightFlagSize = *p++<span class="comment">;</span></div><div class="line">    m_iReqType = *p++<span class="comment">;</span></div><div class="line">    m_iID = *p++<span class="comment">;</span></div><div class="line">    m_iCookie = *p++<span class="comment">;</span></div><div class="line">    for (int i = <span class="number">0</span><span class="comment">; i &lt; 4; ++i)</span></div><div class="line">        m_piPeerIP[i] = *p++<span class="comment">;</span></div><div class="line"></div><div class="line">    return <span class="number">0</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个函数如同它的反函数serialize()一样没有处理字节序的问题。</p>
<ol>
<li><p>计算cookie值。所谓cookie值，即由连接发起端的网络地址(包括IP地址与端口号)及时间戳组成的字符串计算出来的16个字节长度的MD5值。时间戳精确到分钟值。用于计算MD5值的字符串类似127.0.0.1:49033:0。</p>
</li>
<li><p>计算出来cookie值之后的部分，应该被分成两个部分。一部分处理连接发起端发送的地一个握手包，也就是hs.m_iReqType == 1的block，在CUDT::connect()中构造m_ConnReq的部分我们有看到这个值要被设为1的；另一部分则处理连接发起端发送的第二个握手消息。这里我们先来看hs.m_iReqType == 1的block。</p>
</li>
</ol>
<p>它取前一步计算的cookie的前4个字节，直接将其强转为一个int值，赋给前面反序列化的CHandShake的m_iCookie。这个地方竟然顾及字节序的问题，也没有顾及不同平台的差异，即int类型的长度在不同的机器上可能不同，这个地方用int32_t似乎要更安全一点。将CHandShake的m_iID，如我们在CUDT::connect()中构造m_ConnReq的部分我们有看到的，为连接发起端UDT Socket的SocketID，设置给packet的m_iID，也就是包的目标SocketID。再将hs重新序列化进packet。通过发送队列SndQueue发送经过了这一番修改的packet。然后返回。</p>
<p>总结一下UDT Server中Listening的UDT Socket接收到第一个HandShake包时，对于这个包的处理过程：</p>
<p>计算一个cookie值，设置给接收到的HandShake的cookie字段，修改包的目标SocketID字段为发起连接的UDT Socket的SocketID，包的其它部分原封不动，最后将这个包重新发回给连接发起端。</p>
<h1 id="UDT-Client发送第二个HandShake消息"><a href="#UDT-Client发送第二个HandShake消息" class="headerlink" title="UDT Client发送第二个HandShake消息"></a>UDT Client发送第二个HandShake消息</h1><p>UDT Server接收到第一个HandShake消息，回给UDT Client一个HandShake消息。这样球就又被踢回给了UDT Client端。接着来看在UDT Client端接收到首个HandShake包的响应后会做什么样的处理。</p>
<p>我们知道在CUDT::connect(const sockaddr* serv_addr)中，发送首个HandShake包之后，会调用CRcvQueue::recvfrom()来等着接收UDT Server的响应，消费者焦急地等待着食物的到来。在消息到来时，CUDT::connect()会被生产者，也就是CRcvQueue的worker线程唤醒。这里就来具体看一下这个生产与消费的故事的另一半，生产的故事，也就是CRcvQueue的worker线程的消息dispatch。</p>
<p>在CRcvQueue::worker()中包dispatch的部分可以看到：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">NULL</span> != (u = <span class="keyword">self</span>-&gt;m_pHash-&gt;lookup(id))) &#123;</div><div class="line">                <span class="keyword">if</span> (CIPAddress::ipcmp(addr, u-&gt;m_pPeerAddr, u-&gt;m_iIPversion)) &#123;</div><div class="line">                    cout &lt;&lt; <span class="string">"Receive packet by m_pHash table"</span> &lt;&lt; endl;</div><div class="line">                    <span class="keyword">if</span> (u-&gt;m_bConnected &amp;&amp; !u-&gt;m_bBroken &amp;&amp; !u-&gt;m_bClosing) &#123;</div><div class="line">                        <span class="keyword">if</span> (<span class="number">0</span> == unit-&gt;m_Packet.getFlag())</div><div class="line">                            u-&gt;processData(unit);</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            u-&gt;processCtrl(unit-&gt;m_Packet);</div><div class="line"></div><div class="line">                        u-&gt;checkTimers();</div><div class="line">                        <span class="keyword">self</span>-&gt;m_pRcvUList-&gt;update(u);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">NULL</span> != (u = <span class="keyword">self</span>-&gt;m_pRendezvousQueue-&gt;retrieve(addr, id))) &#123;</div><div class="line">                cout &lt;&lt; <span class="string">"Receive packet by m_pRendezvousQueue, u-&gt;m_bSynRecving "</span> &lt;&lt; u-&gt;m_bSynRecving &lt;&lt; endl;</div><div class="line">                <span class="keyword">if</span> (!u-&gt;m_bSynRecving)</div><div class="line">                    u-&gt;connect(unit-&gt;m_Packet);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">self</span>-&gt;storePkt(id, unit-&gt;m_Packet.<span class="keyword">clone</span>());</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>我们知道UDT Server回复的消息中是设置了目标SocketID了的。因而会走id &gt; 0的block。</p>
<p>在CUDT::connect( const sockaddr* serv_addr )中有看到调用m_pRcvQueue-&gt;registerConnector()将CUDT添加进RcvQueue的m_pRendezvousQueue中，因而这里会执行id &gt; 0 block中下面的那个block。</p>
<p>如果前面对于m_bSynRecving的分析，默认情况为true。因而这个地方会执行CRcvQueue::storePkt()来存储包。来看这个函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CRcvQueue::storePkt(<span class="keyword">int32_t</span> id, CPacket* pkt) &#123;</div><div class="line">    <span class="function">CGuard <span class="title">bufferlock</span><span class="params">(m_PassLock)</span></span>;</div><div class="line"></div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int32_t</span>, <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;CPacket*&gt; &gt;::iterator i = m_mBuffer.find(id);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (i == m_mBuffer.end()) &#123;</div><div class="line">        m_mBuffer[id].push(pkt);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></div><div class="line">        pthread_cond_signal(&amp;m_PassCond);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        SetEvent(m_PassCond);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//avoid storing too many packets, in case of malfunction or attack</span></div><div class="line">        <span class="keyword">if</span> (i-&gt;second.size() &gt; <span class="number">16</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        i-&gt;second.push(pkt);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中会保存接收到的packet，并在必要的时候唤醒等待接收消息的线程。(对应CRcvQueue::recvfrom()的逻辑来看。)</p>
<p>然后来看CUDT::connect(const sockaddr* serv_addr)在收到第一个HandShake消息的响应之后会做什么样的处理，也就是CUDT::connect(const CPacket&amp; response)(src/core.cpp)：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">int CUDT::connect(const CPacket&amp; response) <span class="keyword">throw</span> () &#123;</div><div class="line">    <span class="comment">// this is the 2nd half of a connection request. If the connection is setup successfully this returns 0.</span></div><div class="line">    <span class="comment">// returning -1 means there is an error.</span></div><div class="line">    <span class="comment">// returning 1 or 2 means the connection is in process and needs more handshake</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!m_bConnecting)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_bRendezvous &amp;&amp; ((<span class="number">0</span> == response.getFlag()) || (<span class="number">1</span> == response.getType())) &amp;&amp; (<span class="number">0</span> != m_ConnRes.m_iType)) &#123;</div><div class="line">        <span class="comment">//a data packet or a keep-alive packet comes, which means the peer side is already connected</span></div><div class="line">        <span class="comment">// in this situation, the previously recorded response will be used</span></div><div class="line">        goto POST_CONNECT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((<span class="number">1</span> != response.getFlag()) || (<span class="number">0</span> != response.getType()))</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    m_ConnRes.deserialize(response.m_pcData, response.getLength());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_bRendezvous) &#123;</div><div class="line">        <span class="comment">// regular connect should NOT communicate with rendezvous connect</span></div><div class="line">        <span class="comment">// rendezvous connect require 3-way handshake</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_ConnRes.m_iReqType)</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((<span class="number">0</span> == m_ConnReq.m_iReqType) || (<span class="number">0</span> == m_ConnRes.m_iReqType)) &#123;</div><div class="line">            m_ConnReq.m_iReqType = <span class="number">-1</span>;</div><div class="line">            <span class="comment">// the request time must be updated so that the next handshake can be sent out immediately.</span></div><div class="line">            m_llLastReqTime = <span class="number">0</span>;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// set cookie</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_ConnRes.m_iReqType) &#123;</div><div class="line">            m_ConnReq.m_iReqType = <span class="number">-1</span>;</div><div class="line">            m_ConnReq.m_iCookie = m_ConnRes.m_iCookie;</div><div class="line">            m_llLastReqTime = <span class="number">0</span>;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个函数会处理第一个HandShake的响应，也会处理第二个HandShake的响应，这里先来关注第一个HandShake的响应的处理，因而只列出它的一部分的代码。</p>
<p>这个函数先是检查了CUDT的状态，检查了packet的有效性，然后就是将接收到的包的数据部分反序列化至CHandShake m_ConnRes中。我们不关注对于Rendezvous模式的处理。</p>
<p>接着会检查m_ConnRes的m_iReqType，若为1，则设置m_ConnReq.m_iReqType为-1，设置m_ConnReq.m_iCookie为m_ConnRes.m_iCookie用以标识m_ConnReq为一个合法的第二个HandShake packet；同时设置m_llLastReqTime为0，如我们前面对CUDT::connect(const sockaddr* serv_addr)的分析，以便于此刻保存于m_ConnReq中的第二个HandShake能够被发送出去as soon as possible。</p>
<p>这第二个HandShake，与第一个HandShake的差异仅仅在于有了有效的Cookie值，且请求类型ReqType为-1。其它则完全一样。</p>
<h1 id="UDT-Server对第二个HandShake的处理"><a href="#UDT-Server对第二个HandShake的处理" class="headerlink" title="UDT Server对第二个HandShake的处理"></a>UDT Server对第二个HandShake的处理</h1><p>UDT Client对于m_ConnReq的改变并不足以改变接收队列中worker线程对这个包的dispatch规则，因而直接来看CUDT::listen(sockaddr* addr, CPacket&amp; packet)中对于这第二个HandShake消息的处理。</p>
<p>接着前面对于这个函数的分析，接前面的第4步。</p>
<ol>
<li><p>对于这第二个HandShake，它的ReqType自然不再是1了，而是-1。因而在计算完了cookie值之后，它会先验证一下HandShake包中的cookie值是否是有效的，如果无效，则直接返回。根据这个地方的逻辑，可以看到cookie的有效时间最长为2分钟。</p>
</li>
<li><p>检查包的Flag和Type，如果不是HandShake包，则直接返回，否则继续执行。</p>
</li>
<li><p>检查连接发起端IP的版本及Socket类型SockType与本地Listen的UDT Socket是否匹配。若不匹配，则将错误码1002放在发过来的HandShanke的ReqType字段中，设置packet的目标SocketID为发起连接的SocketID，然后将这个包重新发回给UDT Client。</p>
</li>
<li><p>检查之后，发现完全匹配的情况。调用CUDTUnited::newConnection()创建一个新的UDT Socket。若创建过程执行失败，则将错误码1002放在发过来的HandShanke的ReqType字段中。若创建成功，会设置发过来的packet的目标SocketID为适当的值，然后将同一个包再发送回UDT Client。CUDTUnited::newConnection()会适当地修改HandShake packet的一些字段。若失败在执行s_UDTUnited.m_EPoll.update_events()。</p>
</li>
<li><p>返回hs.m_iReqType。</p>
</li>
</ol>
<p>然后来看在CUDTUnited::newConnection()中是如何新建Socket的：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> CUDTUnited::newConnection(<span class="keyword">const</span> UDTSOCKET listen, <span class="keyword">const</span> sockaddr* peer, CHandShake* hs) &#123;</div><div class="line">    CUDTSocket* ns = <span class="keyword">NULL</span>;</div><div class="line">    CUDTSocket* ls = locate(listen);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">NULL</span> == ls)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// if this connection has already been processed</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">NULL</span> != (ns = locate(peer, hs-&gt;m_iID, hs-&gt;m_iISN))) &#123;</div><div class="line">        <span class="keyword">if</span> (ns-&gt;m_pUDT-&gt;m_bBroken) &#123;</div><div class="line">            <span class="comment">// last connection from the "peer" address has been broken</span></div><div class="line">            ns-&gt;m_Status = CLOSED;</div><div class="line">            ns-&gt;m_TimeStamp = CTimer::getTime();</div><div class="line"></div><div class="line">            CGuard::enterCS(ls-&gt;m_AcceptLock);</div><div class="line">            ls-&gt;m_pQueuedSockets-&gt;erase(ns-&gt;m_SocketID);</div><div class="line">            ls-&gt;m_pAcceptSockets-&gt;erase(ns-&gt;m_SocketID);</div><div class="line">            CGuard::leaveCS(ls-&gt;m_AcceptLock);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// connection already exist, this is a repeated connection request</span></div><div class="line">            <span class="comment">// respond with existing HS information</span></div><div class="line"></div><div class="line">            hs-&gt;m_iISN = ns-&gt;m_pUDT-&gt;m_iISN;</div><div class="line">            hs-&gt;m_iMSS = ns-&gt;m_pUDT-&gt;m_iMSS;</div><div class="line">            hs-&gt;m_iFlightFlagSize = ns-&gt;m_pUDT-&gt;m_iFlightFlagSize;</div><div class="line">            hs-&gt;m_iReqType = <span class="number">-1</span>;</div><div class="line">            hs-&gt;m_iID = ns-&gt;m_SocketID;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="comment">//except for this situation a new connection should be started</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// exceeding backlog, refuse the connection request</span></div><div class="line">    <span class="keyword">if</span> (ls-&gt;m_pQueuedSockets-&gt;size() &gt;= ls-&gt;m_uiBackLog)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ns = <span class="keyword">new</span> CUDTSocket;</div><div class="line">        ns-&gt;m_pUDT = <span class="keyword">new</span> CUDT(*(ls-&gt;m_pUDT));</div><div class="line">        <span class="keyword">if</span> (AF_INET == ls-&gt;m_iIPversion) &#123;</div><div class="line">            ns-&gt;m_pSelfAddr = (sockaddr*) (<span class="keyword">new</span> sockaddr_in);</div><div class="line">            ((sockaddr_in*) (ns-&gt;m_pSelfAddr))-&gt;sin_port = <span class="number">0</span>;</div><div class="line">            ns-&gt;m_pPeerAddr = (sockaddr*) (<span class="keyword">new</span> sockaddr_in);</div><div class="line">            memcpy(ns-&gt;m_pPeerAddr, peer, sizeof(sockaddr_in));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ns-&gt;m_pSelfAddr = (sockaddr*) (<span class="keyword">new</span> sockaddr_in6);</div><div class="line">            ((sockaddr_in6*) (ns-&gt;m_pSelfAddr))-&gt;sin6_port = <span class="number">0</span>;</div><div class="line">            ns-&gt;m_pPeerAddr = (sockaddr*) (<span class="keyword">new</span> sockaddr_in6);</div><div class="line">            memcpy(ns-&gt;m_pPeerAddr, peer, sizeof(sockaddr_in6));</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">        delete ns;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    CGuard::enterCS(m_IDLock);</div><div class="line">    ns-&gt;m_SocketID = --m_SocketID;</div><div class="line">    cout &lt;&lt; <span class="string">"new CUDTSocket SocketID is "</span> &lt;&lt; ns-&gt;m_SocketID &lt;&lt; <span class="string">" PeerID "</span> &lt;&lt; hs-&gt;m_iID &lt;&lt; endl;</div><div class="line">    CGuard::leaveCS(m_IDLock);</div><div class="line"></div><div class="line">    ns-&gt;m_ListenSocket = listen;</div><div class="line">    ns-&gt;m_iIPversion = ls-&gt;m_iIPversion;</div><div class="line">    ns-&gt;m_pUDT-&gt;m_SocketID = ns-&gt;m_SocketID;</div><div class="line">    ns-&gt;m_PeerID = hs-&gt;m_iID;</div><div class="line">    ns-&gt;m_iISN = hs-&gt;m_iISN;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// bind to the same addr of listening socket</span></div><div class="line">        ns-&gt;m_pUDT-&gt;open();</div><div class="line">        updateMux(ns, ls);</div><div class="line">        ns-&gt;m_pUDT-&gt;connect(peer, hs);</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">        error = <span class="number">1</span>;</div><div class="line">        <span class="keyword">goto</span> ERR_ROLLBACK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ns-&gt;m_Status = CONNECTED;</div><div class="line"></div><div class="line">    <span class="comment">// copy address information of local node</span></div><div class="line">    ns-&gt;m_pUDT-&gt;m_pSndQueue-&gt;m_pChannel-&gt;getSockAddr(ns-&gt;m_pSelfAddr);</div><div class="line">    CIPAddress::pton(ns-&gt;m_pSelfAddr, ns-&gt;m_pUDT-&gt;m_piSelfIP, ns-&gt;m_iIPversion);</div><div class="line"></div><div class="line">    <span class="comment">// protect the m_Sockets structure.</span></div><div class="line">    CGuard::enterCS(m_ControlLock);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        m_Sockets[ns-&gt;m_SocketID] = ns;</div><div class="line">        m_PeerRec[(ns-&gt;m_PeerID &lt;&lt; <span class="number">30</span>) + ns-&gt;m_iISN].insert(ns-&gt;m_SocketID);</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">        error = <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    CGuard::leaveCS(m_ControlLock);</div><div class="line"></div><div class="line">    CGuard::enterCS(ls-&gt;m_AcceptLock);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ls-&gt;m_pQueuedSockets-&gt;insert(ns-&gt;m_SocketID);</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">        error = <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">    CGuard::leaveCS(ls-&gt;m_AcceptLock);</div><div class="line"></div><div class="line">    <span class="comment">// acknowledge users waiting for new connections on the listening socket</span></div><div class="line">    m_EPoll.update_events(listen, ls-&gt;m_pUDT-&gt;m_sPollID, UDT_EPOLL_IN, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    CTimer::triggerEvent();</div><div class="line"></div><div class="line">    ERR_ROLLBACK: <span class="keyword">if</span> (error &gt; <span class="number">0</span>) &#123;</div><div class="line">        ns-&gt;m_pUDT-&gt;close();</div><div class="line">        ns-&gt;m_Status = CLOSED;</div><div class="line">        ns-&gt;m_TimeStamp = CTimer::getTime();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// wake up a waiting accept() call</span></div><div class="line"><span class="comment">#ifndef WIN32</span></div><div class="line">    pthread_mutex_lock(&amp;(ls-&gt;m_AcceptLock));</div><div class="line">    pthread_cond_signal(&amp;(ls-&gt;m_AcceptCond));</div><div class="line">    pthread_mutex_unlock(&amp;(ls-&gt;m_AcceptLock));</div><div class="line"><span class="comment">#else</span></div><div class="line">    SetEvent(ls-&gt;m_AcceptCond);</div><div class="line"><span class="comment">#endif</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个函数中做了如下这样的一些事情：</p>
<ol>
<li><p>找到listening的UDT Socket的CUDTSocket结构，若找不到则直接返回-1。否则继续执行。</p>
</li>
<li><p>检查相同的连接请求是否已经处理过了。在CUDTUnited有一个专门的缓冲区m_PeerRec，用来存放由Listening的Socket创建的UDT Socket，这里主要是通过在这个缓冲区中查找是否已经有connection请求对应的socket来判断：</p>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">CUDTSocket* CUDTUnited::locate(<span class="keyword">const</span> sockaddr* peer, <span class="keyword">const</span> UDTSOCKET id, int32_t isn) &#123;</div><div class="line">    CGuard cg(m_ControlLock);</div><div class="line"></div><div class="line">    map&lt;int64_t, set&lt;UDTSOCKET&gt; &gt;::iterator i = m_PeerRec.find((id &lt;&lt; <span class="number">30</span>) + isn);</div><div class="line">    <span class="keyword">if</span> (i == m_PeerRec.end())</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (set&lt;UDTSOCKET&gt;::iterator j = i-&gt;second.begin(); j != i-&gt;second.end(); ++j) &#123;</div><div class="line">        map&lt;UDTSOCKET, CUDTSocket*&gt;::iterator k = m_Sockets.find(*j);</div><div class="line">        <span class="comment">// this socket might have been closed and moved m_ClosedSockets</span></div><div class="line">        <span class="keyword">if</span> (k == m_Sockets.end())</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (CIPAddress::ipcmp(peer, k-&gt;second-&gt;m_pPeerAddr, k-&gt;second-&gt;m_iIPversion))</div><div class="line">            <span class="keyword">return</span> k-&gt;second;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果已经为这个connection请求创建了UDT Socket，又分为两种情况：</p>
<p>(1). 为connection请求创建的UDT Socket还是好的，可用的，则根据之前创建的UDT Socket的一些字段设置接收到的HandShake，m_iReqType会被设置为-1，m_iID会被设置为UDT Socket的SocketID。然后返回0。如我们前面在CUDTUnited::newConnection()中看到的，这样返回之后，CUDTUnited::newConnection()会发送一个响应消息给UDT Client。</p>
<p>(2). 为connection请求创建的UDT Socket已经烂掉了，不可用了，此时则主要会将其状态设置为CLOSED，设置时间戳，将其从m_pQueuedSockets和m_pAcceptSockets中移除出去。然后执行后续的新建UDT Socket的流程。</p>
<p>但对于一个由Listening Socket创建的UDT Socket而言，又会是什么原因导致它处于broken状态呢？此处这样的检查是否真有必要呢？后面会再来研究。</p>
<ol>
<li><p>检查m_pQueuedSockets的大小是否超出了为Listening的UDT Socket设置的backlog大小，若超出，则返回-1，否则继续执行。</p>
</li>
<li><p>创建一个CUDTSocket对象。创建一个CUDT对象，这里创建的CUDT对象会继承Listening的UDT Socket的许多属性(src/api.cpp)：</p>
</li>
</ol>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">CUDT::CUDT(const CUDT&amp; ancestor) &#123;</div><div class="line">    <span class="attr">m_pSndBuffer</span> = NULL;</div><div class="line">    <span class="attr">m_pRcvBuffer</span> = NULL;</div><div class="line">    <span class="attr">m_pSndLossList</span> = NULL;</div><div class="line">    <span class="attr">m_pRcvLossList</span> = NULL;</div><div class="line">    <span class="attr">m_pACKWindow</span> = NULL;</div><div class="line">    <span class="attr">m_pSndTimeWindow</span> = NULL;</div><div class="line">    <span class="attr">m_pRcvTimeWindow</span> = NULL;</div><div class="line"></div><div class="line">    <span class="attr">m_pSndQueue</span> = NULL;</div><div class="line">    <span class="attr">m_pRcvQueue</span> = NULL;</div><div class="line">    <span class="attr">m_pPeerAddr</span> = NULL;</div><div class="line">    <span class="attr">m_pSNode</span> = NULL;</div><div class="line">    <span class="attr">m_pRNode</span> = NULL;</div><div class="line"></div><div class="line">    // Initilize mutex <span class="literal">and</span> condition variables</div><div class="line">    initSynch();</div><div class="line"></div><div class="line">    // Default UDT configurations</div><div class="line">    <span class="attr">m_iMSS</span> = ancestor.m_iMSS;</div><div class="line">    <span class="attr">m_bSynSending</span> = ancestor.m_bSynSending;</div><div class="line">    <span class="attr">m_bSynRecving</span> = ancestor.m_bSynRecving;</div><div class="line">    <span class="attr">m_iFlightFlagSize</span> = ancestor.m_iFlightFlagSize;</div><div class="line">    <span class="attr">m_iSndBufSize</span> = ancestor.m_iSndBufSize;</div><div class="line">    <span class="attr">m_iRcvBufSize</span> = ancestor.m_iRcvBufSize;</div><div class="line">    <span class="attr">m_Linger</span> = ancestor.m_Linger;</div><div class="line">    <span class="attr">m_iUDPSndBufSize</span> = ancestor.m_iUDPSndBufSize;</div><div class="line">    <span class="attr">m_iUDPRcvBufSize</span> = ancestor.m_iUDPRcvBufSize;</div><div class="line">    <span class="attr">m_iSockType</span> = ancestor.m_iSockType;</div><div class="line">    <span class="attr">m_iIPversion</span> = ancestor.m_iIPversion;</div><div class="line">    <span class="attr">m_bRendezvous</span> = ancestor.m_bRendezvous;</div><div class="line">    <span class="attr">m_iSndTimeOut</span> = ancestor.m_iSndTimeOut;</div><div class="line">    <span class="attr">m_iRcvTimeOut</span> = ancestor.m_iRcvTimeOut;</div><div class="line">    <span class="attr">m_bReuseAddr</span> = <span class="literal">true</span>;  // this must be <span class="literal">true</span>, because all accepted sockets shared the same port <span class="keyword">with</span> the listener</div><div class="line">    <span class="attr">m_llMaxBW</span> = ancestor.m_llMaxBW;</div><div class="line"></div><div class="line">    <span class="attr">m_pCCFactory</span> = ancestor.m_pCCFactory-&gt;clone();</div><div class="line">    <span class="attr">m_pCC</span> = NULL;</div><div class="line">    <span class="attr">m_pCache</span> = ancestor.m_pCache;</div><div class="line"></div><div class="line">    // Initial status</div><div class="line">    <span class="attr">m_bOpened</span> = <span class="literal">false</span>;</div><div class="line">    <span class="attr">m_bListening</span> = <span class="literal">false</span>;</div><div class="line">    <span class="attr">m_bConnecting</span> = <span class="literal">false</span>;</div><div class="line">    <span class="attr">m_bConnected</span> = <span class="literal">false</span>;</div><div class="line">    <span class="attr">m_bClosing</span> = <span class="literal">false</span>;</div><div class="line">    <span class="attr">m_bShutdown</span> = <span class="literal">false</span>;</div><div class="line">    <span class="attr">m_bBroken</span> = <span class="literal">false</span>;</div><div class="line">    <span class="attr">m_bPeerHealth</span> = <span class="literal">true</span>;</div><div class="line">    <span class="attr">m_ullLingerExpiration</span> = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为SelfAddr分配内存。</p>
<p>为PeerAddr分配内存。</p>
<p>拷贝发送端地址到PeerAddr。</p>
<p>设置SocketID。等等。</p>
<ol>
<li>执行ns-&gt;m_pUDT-&gt;open()完成打开动作。然后执行updateMux(ns, ls)，将新建的这个UDT Socket绑定到Listening的UDT Socket所绑定的多路复用器：</li>
</ol>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void CUDTUnited::updateMux(CUDTSocket* s, const CUDTSocket* ls) &#123;</div><div class="line">    CGuard cg(m_ControlLock);</div><div class="line"></div><div class="line">    <span class="function"><span class="title">int</span> port = (AF_INET == ls-&gt;</span>m_iIPversion) ?</div><div class="line">                    <span class="function"><span class="title">ntohs</span>(((sockaddr_in*) ls-&gt;</span><span class="function"><span class="title">m_pSelfAddr</span>)-&gt;</span>sin_port) :</div><div class="line">                    <span class="function"><span class="title">ntohs</span>(((sockaddr_in6*) ls-&gt;</span><span class="function"><span class="title">m_pSelfAddr</span>)-&gt;</span>sin6_port);</div><div class="line"></div><div class="line">    <span class="comment">// find the listener's address</span></div><div class="line">    <span class="keyword">for</span> (map&lt;int, CMultiplexer&gt;::iterator i = m_mMultiplexer.begin(); i != m_mMultiplexer.end(); ++i) &#123;</div><div class="line">        <span class="function"><span class="title">if</span> (i-&gt;</span>second.m_iPort == port) &#123;</div><div class="line">            <span class="comment">// reuse the existing multiplexer</span></div><div class="line">            ++<span class="function"><span class="title">i</span>-&gt;</span>second.m_iRefCount;</div><div class="line">            <span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">m_pUDT</span>-&gt;</span><span class="function"><span class="title">m_pSndQueue</span> = i-&gt;</span>second.m_pSndQueue;</div><div class="line">            <span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">m_pUDT</span>-&gt;</span><span class="function"><span class="title">m_pRcvQueue</span> = i-&gt;</span>second.m_pRcvQueue;</div><div class="line">            <span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">m_iMuxID</span> = i-&gt;</span>second.m_iID;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>执行 ns-&gt;m_pUDT-&gt;connect(peer, hs)：</li>
</ol>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">void CUDT::connect(const sockaddr* peer, CHandShake* hs) &#123;</div><div class="line">    CGuard cg(m_ConnectionLock);</div><div class="line"></div><div class="line">    <span class="comment">// Uses the smaller MSS between the peers</span></div><div class="line">    <span class="function"><span class="title">if</span> (hs-&gt;</span>m_iMSS &gt; m_iMSS)</div><div class="line">        <span class="function"><span class="title">hs</span>-&gt;</span>m_iMSS = m_iMSS;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="function"><span class="title">m_iMSS</span> = hs-&gt;</span>m_iMSS;</div><div class="line"></div><div class="line">    <span class="comment">// exchange info for maximum flow window size</span></div><div class="line">    <span class="function"><span class="title">m_iFlowWindowSize</span> = hs-&gt;</span>m_iFlightFlagSize;</div><div class="line">    <span class="function"><span class="title">hs</span>-&gt;</span>m_iFlightFlagSize = (m_iRcvBufSize &lt; m_iFlightFlagSize) ? m_iRcvBufSize : m_iFlightFlagSize;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">m_iPeerISN</span> = hs-&gt;</span>m_iISN;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">m_iRcvLastAck</span> = hs-&gt;</span>m_iISN;</div><div class="line">    <span class="function"><span class="title">m_iRcvLastAckAck</span> = hs-&gt;</span>m_iISN;</div><div class="line">    <span class="function"><span class="title">m_iRcvCurrSeqNo</span> = hs-&gt;</span>m_iISN - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">m_PeerID</span> = hs-&gt;</span>m_iID;</div><div class="line">    <span class="function"><span class="title">hs</span>-&gt;</span>m_iID = m_SocketID;</div><div class="line"></div><div class="line">    <span class="comment">// use peer's ISN and send it back for security check</span></div><div class="line">    <span class="function"><span class="title">m_iISN</span> = hs-&gt;</span>m_iISN;</div><div class="line"></div><div class="line">    m_iLastDecSeq = m_iISN - <span class="number">1</span>;</div><div class="line">    m_iSndLastAck = m_iISN;</div><div class="line">    m_iSndLastDataAck = m_iISN;</div><div class="line">    m_iSndCurrSeqNo = m_iISN - <span class="number">1</span>;</div><div class="line">    m_iSndLastAck2 = m_iISN;</div><div class="line">    m_ullSndLastAck2Time = CTimer::getTime();</div><div class="line"></div><div class="line">    <span class="comment">// this is a reponse handshake</span></div><div class="line">    <span class="function"><span class="title">hs</span>-&gt;</span>m_iReqType = -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// get local IP address and send the peer its IP address (because UDP cannot get local IP address)</span></div><div class="line">    <span class="function"><span class="title">memcpy</span>(m_piSelfIP, hs-&gt;</span>m_piPeerIP, <span class="number">16</span>);</div><div class="line">    CIPA<span class="function"><span class="title">ddress</span>::ntop(peer, hs-&gt;</span>m_piPeerIP, m_iIPversion);</div><div class="line"></div><div class="line">    m_iPktSize = m_iMSS - <span class="number">28</span>;</div><div class="line">    m_iPayloadSize = m_iPktSize - CPacket::m_iPktHdrSize;</div><div class="line"></div><div class="line">    <span class="comment">// Prepare all structures</span></div><div class="line">    try &#123;</div><div class="line">        m_pSndBuffer = new CSndBuffer(<span class="number">32</span>, m_iPayloadSize);</div><div class="line">        <span class="function"><span class="title">m_pRcvBuffer</span> = new CRcvBuffer(&amp;(m_pRcvQueue-&gt;</span>m_UnitQueue), m_iRcvBufSize);</div><div class="line">        m_pSndLossList = new CSndLossList(m_iFlowWindowSize * <span class="number">2</span>);</div><div class="line">        m_pRcvLossList = new CRcvLossList(m_iFlightFlagSize);</div><div class="line">        m_pACKWindow = new CACKWindow(<span class="number">1024</span>);</div><div class="line">        m_pRcvTimeWindow = new CPktTimeWindow(<span class="number">16</span>, <span class="number">64</span>);</div><div class="line">        m_pSndTimeWindow = new CPktTimeWindow();</div><div class="line">    &#125; catch (...) &#123;</div><div class="line">        throw CUDTException(<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    CInfoBlock ib;</div><div class="line">    ib.m_iIPversion = m_iIPversion;</div><div class="line">    CInfoBlock::convert(peer, m_iIPversion, ib.m_piIP);</div><div class="line">    <span class="function"><span class="title">if</span> (m_pCache-&gt;</span>lookup(&amp;ib) &gt;= <span class="number">0</span>) &#123;</div><div class="line">        m_iRTT = ib.m_iRTT;</div><div class="line">        m_iBandwidth = ib.m_iBandwidth;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">m_pCC</span> = m_pCCFactory-&gt;</span>create();</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>m_UDT = m_SocketID;</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setMSS(m_iMSS);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setMaxCWndSize(m_iFlowWindowSize);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setSndCurrSeqNo(m_iSndCurrSeqNo);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setRcvRate(m_iDeliveryRate);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setRTT(m_iRTT);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setBandwidth(m_iBandwidth);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>init();</div><div class="line"></div><div class="line">    <span class="function"><span class="title">m_ullInterval</span> = (uint64_t) (m_pCC-&gt;</span>m_dPktSndPeriod * m_ullCPUFrequency);</div><div class="line">    <span class="function"><span class="title">m_dCongestionWindow</span> = m_pCC-&gt;</span>m_dCWndSize;</div><div class="line"></div><div class="line">    m_pPeerAddr = (AF_INET == m_iIPversion) ? (sockaddr*) new sockaddr_in : (sockaddr*) new sockaddr_in6;</div><div class="line">    memcpy(m_pPeerAddr, peer, (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6));</div><div class="line"></div><div class="line">    <span class="comment">// And of course, it is connected.</span></div><div class="line">    m_bConnected = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">// register this socket for receiving data packets</span></div><div class="line">    <span class="function"><span class="title">m_pRNode</span>-&gt;</span>m_bOnList = <span class="literal">true</span>;</div><div class="line">    <span class="function"><span class="title">m_pRcvQueue</span>-&gt;</span>setNewEntry(this);</div><div class="line"></div><div class="line">    <span class="comment">//send the response to the peer, see listen() for more discussions about this</span></div><div class="line">    CPacket response;</div><div class="line">    int size = CHandShake::m_iContentSize;</div><div class="line">    char* buffer = new char[size];</div><div class="line">    <span class="function"><span class="title">hs</span>-&gt;</span>serialize(buffer, size);</div><div class="line">    response.pack(<span class="number">0</span>, NULL, buffer, size);</div><div class="line">    response.m_iID = m_PeerID;</div><div class="line">    <span class="function"><span class="title">m_pSndQueue</span>-&gt;</span>sendto(peer, response);</div><div class="line">    delete[] buffer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数里会根据HandShake包设置非常多的成员。但主要来关注m_pRcvQueue-&gt;setNewEntry(this)，这个调用也是与RcvQueue的worker线程的消息dispatch机制有关。后面我们会再来仔细地了解这个函数。</p>
<p>这个函数会在最后发送响应给UDT Client。</p>
<ol>
<li><p>将UDT Socket的状态置为CONNECTED。拷贝Channel的地址到PeerAddr。</p>
</li>
<li><p>将创建的CUDTSocket放进m_Sockets中，同时放进m_PeerRec中。</p>
</li>
<li><p>将创建的UDT Socket放进m_pQueuedSockets中。这正是Listening UDT Socket accept那个生产-消费故事的另一半，这里是生产者。</p>
</li>
<li><p>将等待在accept()的线程唤醒。至此在UDT Server端，accept()返回一个UDT Socket，UDT Server认为一个连接成功建立。</p>
</li>
</ol>
<h1 id="UDT-Client从UDT-connect-返回"><a href="#UDT-Client从UDT-connect-返回" class="headerlink" title="UDT Client从UDT::connect()返回"></a>UDT Client从UDT::connect()返回</h1><p>如我们前面看到的，CUDT::connect(const sockaddr* serv_addr)在发送了第二个Handshake消息之后，它就会开是等待UDT Server的第二次响应。UDT Server发送第二个Handshake消息的相应之后，UDT Client端将会返回并处理它。这个消息的dispatch过程与第一个HandShake的响应消息的处理过程一致，这里不再赘述。这里来看这第二个HandShake的响应消息的处理，同样是在CUDT::connect(const CPacket&amp; response)中：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// set cookie</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_ConnRes.m_iReqType) &#123;</div><div class="line">            m_ConnReq.m_iReqType = -<span class="number">1</span>;</div><div class="line">            m_ConnReq.m_iCookie = m_ConnRes.m_iCookie;</div><div class="line">            m_llLastReqTime = <span class="number">0</span>;</div><div class="line">            return <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    POST_CONNECT:</div><div class="line">    <span class="comment">// Remove from rendezvous queue</span></div><div class="line">    <span class="function"><span class="title">m_pRcvQueue</span>-&gt;</span>removeConnector(m_SocketID);</div><div class="line"></div><div class="line">    <span class="comment">// Re-configure according to the negotiated values.</span></div><div class="line">    m_iMSS = m_ConnRes.m_iMSS;</div><div class="line">    m_iFlowWindowSize = m_ConnRes.m_iFlightFlagSize;</div><div class="line">    m_iPktSize = m_iMSS - <span class="number">28</span>;</div><div class="line">    m_iPayloadSize = m_iPktSize - CPacket::m_iPktHdrSize;</div><div class="line">    m_iPeerISN = m_ConnRes.m_iISN;</div><div class="line">    m_iRcvLastAck = m_ConnRes.m_iISN;</div><div class="line">    m_iRcvLastAckAck = m_ConnRes.m_iISN;</div><div class="line">    m_iRcvCurrSeqNo = m_ConnRes.m_iISN - <span class="number">1</span>;</div><div class="line">    m_PeerID = m_ConnRes.m_iID;</div><div class="line">    memcpy(m_piSelfIP, m_ConnRes.m_piPeerIP, <span class="number">16</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Prepare all data structures</span></div><div class="line">    try &#123;</div><div class="line">        m_pSndBuffer = new CSndBuffer(<span class="number">32</span>, m_iPayloadSize);</div><div class="line">        <span class="function"><span class="title">m_pRcvBuffer</span> = new CRcvBuffer(&amp;(m_pRcvQueue-&gt;</span>m_UnitQueue), m_iRcvBufSize);</div><div class="line">        <span class="comment">// after introducing lite ACK, the sndlosslist may not be cleared in time, so it requires twice space.</span></div><div class="line">        m_pSndLossList = new CSndLossList(m_iFlowWindowSize * <span class="number">2</span>);</div><div class="line">        m_pRcvLossList = new CRcvLossList(m_iFlightFlagSize);</div><div class="line">        m_pACKWindow = new CACKWindow(<span class="number">1024</span>);</div><div class="line">        m_pRcvTimeWindow = new CPktTimeWindow(<span class="number">16</span>, <span class="number">64</span>);</div><div class="line">        m_pSndTimeWindow = new CPktTimeWindow();</div><div class="line">    &#125; catch (...) &#123;</div><div class="line">        throw CUDTException(<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    CInfoBlock ib;</div><div class="line">    ib.m_iIPversion = m_iIPversion;</div><div class="line">    CInfoBlock::convert(m_pPeerAddr, m_iIPversion, ib.m_piIP);</div><div class="line">    <span class="function"><span class="title">if</span> (m_pCache-&gt;</span>lookup(&amp;ib) &gt;= <span class="number">0</span>) &#123;</div><div class="line">        m_iRTT = ib.m_iRTT;</div><div class="line">        m_iBandwidth = ib.m_iBandwidth;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">m_pCC</span> = m_pCCFactory-&gt;</span>create();</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>m_UDT = m_SocketID;</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setMSS(m_iMSS);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setMaxCWndSize(m_iFlowWindowSize);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setSndCurrSeqNo(m_iSndCurrSeqNo);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setRcvRate(m_iDeliveryRate);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setRTT(m_iRTT);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>setBandwidth(m_iBandwidth);</div><div class="line">    <span class="function"><span class="title">m_pCC</span>-&gt;</span>init();</div><div class="line"></div><div class="line">    <span class="function"><span class="title">m_ullInterval</span> = (uint64_t) (m_pCC-&gt;</span>m_dPktSndPeriod * m_ullCPUFrequency);</div><div class="line">    <span class="function"><span class="title">m_dCongestionWindow</span> = m_pCC-&gt;</span>m_dCWndSize;</div><div class="line"></div><div class="line">    <span class="comment">// And, I am connected too.</span></div><div class="line">    m_bConnecting = <span class="literal">false</span>;</div><div class="line">    m_bConnected = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">// register this socket for receiving data packets</span></div><div class="line">    <span class="function"><span class="title">m_pRNode</span>-&gt;</span>m_bOnList = <span class="literal">true</span>;</div><div class="line">    <span class="function"><span class="title">m_pRcvQueue</span>-&gt;</span>setNewEntry(this);</div><div class="line"></div><div class="line">    <span class="comment">// acknowledge the management module.</span></div><div class="line">    s_UDTUnited.connect_complete(m_SocketID);</div><div class="line"></div><div class="line">    <span class="comment">// acknowledde any waiting epolls to write</span></div><div class="line">    s_UDTUnited.m_EPoll.update_events(m_SocketID, m_sPollID, UDT_EPOLL_OUT, <span class="literal">true</span>);</div><div class="line"></div><div class="line">    return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>这里做的第一件事就是调用m_pRcvQueue-&gt;removeConnector(m_SocketID)将自己从RevQueue的RendezvousQueue中移除，以表示自己将不再接收Rendezvous消息(src/queue.cpp)：<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void <span class="symbol">CRcvQueue:</span><span class="symbol">:removeConnector</span>(const UDTSOCKET&amp; id) &#123;</div><div class="line">    m_pRendezvousQueue-&gt;remove(id);</div><div class="line"></div><div class="line">    CGuard bufferlock(m_PassLock);</div><div class="line"></div><div class="line">    map&lt;int32_t, <span class="symbol">std:</span><span class="symbol">:queue&lt;CPacket*&gt;</span> &gt;<span class="symbol">:</span><span class="symbol">:iterator</span> i = m_mBuffer.find(id);</div><div class="line">    if (i != m_mBuffer.<span class="keyword">end</span>()) &#123;</div><div class="line">        <span class="keyword">while</span> (!i-&gt;second.empty()) &#123;</div><div class="line">            delete[] i-&gt;second.front()-&gt;m_pcData;</div><div class="line">            delete i-&gt;second.front();</div><div class="line">            i-&gt;second.pop();</div><div class="line">        &#125;</div><div class="line">        m_mBuffer.erase(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个函数执行完之后，RcvQueue暂时将无法向UDT Socket dispatch包。</p>
<ol>
<li><p>根据协商的值重新做配置。这里我们可以再来看一下UDT的协商指的是什么。纵览连接建立的整个过程，我们并没有看到针对这些需要协商的值UDT本身有什么特殊的算法来计算，因而所谓的协商则主要是UDT Client端和UDT Server端，针对这些选项，不同应用程序层不同设置的同步协调。</p>
</li>
<li><p>准备所有的数据缓冲区。</p>
</li>
<li><p>设置CUDT的状态，m_bConnecting为false，m_bConnected为true。</p>
</li>
<li><p>执行m_pRcvQueue-&gt;setNewEntry(this)，注册socket来接收数据包。这里来看一下CRcvQueue::setNewEntry(CUDT* u)：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CRcvQueue::setNewEntry(CUDT* u) &#123;</div><div class="line">    <span class="function">CGuard <span class="title">listguard</span><span class="params">(m_IDLock)</span></span>;</div><div class="line">    m_vNewEntry.push_back(u);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个操作本身非常简单。但把CUDT结构放进CRcvQueue之后，又会发生什么呢？回忆我们前面看到的CRcvQueue::worker(void* param)函数中循环开始部分的这段代码：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// check waiting list, if new socket, insert it to the list</span></div><div class="line">        <span class="function"><span class="title">while</span> (self-&gt;</span>ifNewEntry()) &#123;</div><div class="line">            CUDT* <span class="function"><span class="title">ne</span> = self-&gt;</span>getNewEntry();</div><div class="line">            <span class="keyword">if</span> (NULL != ne) &#123;</div><div class="line">                <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pRcvUList</span>-&gt;</span>insert(ne);</div><div class="line">                <span class="function"><span class="title">self</span>-&gt;</span><span class="function"><span class="title">m_pHash</span>-&gt;</span><span class="function"><span class="title">insert</span>(ne-&gt;</span>m_SocketID, ne);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>对照这段代码中用到的几个函数的实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> CRcvQueue::ifNewEntry() &#123;</div><div class="line">    <span class="keyword">return</span> !(m_vNewEntry.<span class="keyword">empty</span>());</div><div class="line">&#125;</div><div class="line"></div><div class="line">CUDT* CRcvQueue::getNewEntry() &#123;</div><div class="line">    CGuard listguard(m_IDLock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_vNewEntry.<span class="keyword">empty</span>())</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">    CUDT* u = (CUDT*) *(m_vNewEntry.begin());</div><div class="line">    m_vNewEntry.erase(m_vNewEntry.begin());</div><div class="line"></div><div class="line">    <span class="keyword">return</span> u;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以了解到，在 执行m_pRcvQueue-&gt;setNewEntry(this)，注册socket之后，CRcvQueue的worker线程会将这个CUDT结构从它的m_vNewEntry中移到另外的两个容器m_pRcvUList和m_pHash中。那然后呢？在CRcvQueue::worker(void* param)中不是还有下面这段吗：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">NULL</span> != (u = <span class="keyword">self</span>-&gt;m_pHash-&gt;lookup(id))) &#123;</div><div class="line">    <span class="keyword">if</span> (CIPAddress::ipcmp(addr, u-&gt;m_pPeerAddr, u-&gt;m_iIPversion)) &#123;</div><div class="line">        cout &lt;&lt; <span class="string">"Receive packet by m_pHash table"</span> &lt;&lt; endl;</div><div class="line">        <span class="keyword">if</span> (u-&gt;m_bConnected &amp;&amp; !u-&gt;m_bBroken &amp;&amp; !u-&gt;m_bClosing) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="number">0</span> == unit-&gt;m_Packet.getFlag())</div><div class="line">                u-&gt;processData(unit);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                u-&gt;processCtrl(unit-&gt;m_Packet);</div><div class="line"></div><div class="line">            u-&gt;checkTimers();</div><div class="line">            <span class="keyword">self</span>-&gt;m_pRcvUList-&gt;update(u);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">NULL</span> != (u = <span class="keyword">self</span>-&gt;m_pRendezvousQueue-&gt;retrieve(addr, id))) &#123;</div></pre></td></tr></table></figure></p>
<p>就是这样，可以说，在CUDT::connect(const CPacket&amp; response)中是完成了一次UDT Socket消息接收方式的转变。</p>
<ol>
<li>执行s_UDTUnited.connect_complete(m_SocketID)结束整个的connect()过程：</li>
</ol>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void CUDTUnited::connect_complete(const UDTSOCKET u) &#123;</div><div class="line">    CUDTSocket* s = locate(u);</div><div class="line">    <span class="keyword">if</span> (NULL == s)</div><div class="line">        throw CUDTException(<span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// copy address information of local node</span></div><div class="line">    <span class="comment">// the local port must be correctly assigned BEFORE CUDT::connect(),</span></div><div class="line">    <span class="comment">// otherwise if connect() fails, the multiplexer cannot be located by garbage collection and will cause leak</span></div><div class="line">    <span class="function"><span class="title">s</span>-&gt;</span><span class="function"><span class="title">m_pUDT</span>-&gt;</span><span class="function"><span class="title">m_pSndQueue</span>-&gt;</span><span class="function"><span class="title">m_pChannel</span>-&gt;</span><span class="function"><span class="title">getSockAddr</span>(s-&gt;</span>m_pSelfAddr);</div><div class="line">    CIPA<span class="function"><span class="title">ddress</span>::pton(s-&gt;</span><span class="function"><span class="title">m_pSelfAddr</span>, s-&gt;</span><span class="function"><span class="title">m_pUDT</span>-&gt;</span><span class="function"><span class="title">m_piSelfIP</span>, s-&gt;</span>m_iIPversion);</div><div class="line"></div><div class="line">    <span class="function"><span class="title">s</span>-&gt;</span>m_Status = CONNECTED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>UDT Socket至此进入CONNECTED状态。</p>
<p>Done。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wxpay.png" alt="Han Pengfei 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Han Pengfei 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/网络协议/" rel="tag"># 网络协议</a>
          
            <a href="/tags/源码分析/" rel="tag"># 源码分析</a>
          
            <a href="/tags/UDT/" rel="tag"># UDT</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/09/09/UDT协议实现分析——bind、listen与accept/" rel="next" title="UDT协议实现分析——bind、listen与accept">
                <i class="fa fa-chevron-left"></i> UDT协议实现分析——bind、listen与accept
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/09/14/UDT协议实现分析——数据的发送/" rel="prev" title="UDT协议实现分析——数据的发送">
                UDT协议实现分析——数据的发送 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/freesoft.jpg"
                alt="Han Pengfei" />
            
              <p class="site-author-name" itemprop="name">Han Pengfei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">207</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hanpfei" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.douban.com/people/3681478/" target="_blank" title="豆瓣"><i class="fa fa-fw fa-globe"></i>豆瓣</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/han-peng-fei-49" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hanpfei@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://source.android.com/" title="Android Open Source Project" target="_blank">Android Open Source Project</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.vants.org/" title="蚂蚁网" target="_blank">蚂蚁网</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#连接的发起"><span class="nav-number">1.</span> <span class="nav-text">连接的发起</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UDT-Server对首个Handshake消息的处理"><span class="nav-number">2.</span> <span class="nav-text">UDT Server对首个Handshake消息的处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UDT-Client发送第二个HandShake消息"><span class="nav-number">3.</span> <span class="nav-text">UDT Client发送第二个HandShake消息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UDT-Server对第二个HandShake的处理"><span class="nav-number">4.</span> <span class="nav-text">UDT Server对第二个HandShake的处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UDT-Client从UDT-connect-返回"><span class="nav-number">5.</span> <span class="nav-text">UDT Client从UDT::connect()返回</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016.09.16 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Han Pengfei</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  









<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 's9sbM9ODdusCzKcm5JcIj6t8-gzGzoHsz',
    appKey: 'UoO9ia1DLNwOXRUsTBQ6QXxm',
    placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn'
  });
</script>


  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  

  

  

</body>
</html>
