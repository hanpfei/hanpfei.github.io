<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>android下运行时动态链接dlopen()和dlsym()的实现 | WolfcsTech</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.2.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.2.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">android下运行时动态链接dlopen()和dlsym()的实现</h1><a id="logo" href="/.">WolfcsTech</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">android下运行时动态链接dlopen()和dlsym()的实现</h1><div class="post-meta">Jul 13, 2013<span> | </span><span class="category"><a href="/categories/C-C-开发/">C/C++开发</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2013/07/13/dlopen_and_dlsym/" href="/2013/07/13/dlopen_and_dlsym/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>﻿在android中，就如同在Linux下一样，我们也可以在app中，运行时动态加载一些动态链接库，执行调用其中的函数等操作。实现这一切最终依靠的就是dlopen()等几个函数。关于这几个函数的原型机这些API的用法，可以参考 LINUX下动态链接库的使用-dlopen dlsym dlclose dlerror这一篇。而此处我们就来看一下，在android c标准库的bionic中，这些函数究竟是如何实现的。</p>
<a id="more"></a>
<h1 id="dlopen-函数"><a href="#dlopen-函数" class="headerlink" title="dlopen()函数"></a>dlopen()函数</h1><p>首先是dlopen()函数。我们给这个函数传递一个动态连接库的文件名或路径，及一些flag，这个函数返回给我们一个动态链接库的句柄，以方便我们后续执行查找symbol等操作。这个函数的代码在android codebase中的路径为bionic/linker/dlfcn.c。我们来看一下它的实现：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void *dlopen(<span class="name">const</span> char *filename, int flag)</div><div class="line">&#123;</div><div class="line">    soinfo *ret<span class="comment">;</span></div><div class="line"></div><div class="line">    pthread_mutex_lock(<span class="name">&amp;dl_lock</span>)<span class="comment">;</span></div><div class="line">    ret = find_library(<span class="name">filename</span>)<span class="comment">;</span></div><div class="line">    if (<span class="name">unlikely</span>(<span class="name">ret</span> == NULL)) &#123;</div><div class="line">        set_dlerror(<span class="name">DL_ERR_CANNOT_LOAD_LIBRARY</span>)<span class="comment">;</span></div><div class="line">    &#125; else &#123;</div><div class="line">        soinfo_call_constructors(<span class="name">ret</span>)<span class="comment">;</span></div><div class="line">        ret-&gt;refcount++<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(<span class="name">&amp;dl_lock</span>)<span class="comment">;</span></div><div class="line">    return ret<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，这个函数本身的结构都还蛮清晰的。它主要完成几个事情：</p>
<ol>
<li>获取到一个互斥量。这个互斥量用于保护动态连接库的链表。</li>
<li>根据动态连接库的路径名或文件名，查找一个动态链接库。这个过程实际上可能会返回一个已经加载了的动态连接库的句柄，但也可能会去新加载一个动态连接库，并返回其句柄。</li>
<li>如果上一步查找动态连接库的操作成功完成，即找到了一个已经加载的动态连接库或者是成功的新加载了一个动态连接库。则它会去执行该动态连接库的初始化部分代码，并增加动态连接库的引用计数。而如果上一步的查找没有成功，则此处会设置出错信息，以便于user可以通过dlerror()了解到执行出错的情况。</li>
<li>最后就是释放互斥量，并将结果返回给调用者。</li>
</ol>
<p>此处我们可以看一下，那个所谓的动态连接库的句柄究竟是个什么东西。可以看到，它是一个soinfo的对象。</p>
<p>接下来我们先偏个楼，来看一下linker提供给user用的了解error信息的接口。</p>
<h1 id="dlerror-和set-dlerror"><a href="#dlerror-和set-dlerror" class="headerlink" title="dlerror()和set_dlerror()"></a>dlerror()和set_dlerror()</h1><p>当open一个动态链接库出错时，dl族函数的调用者可以通过dlerror()函数来对出错的原因有更多的了解，这个函数返回一个关于出错状况的error message。在linker open一个动态连接库出错时，它会自动的设置相关的error message。我们来看一下dlerror()函数和set_dlerror()函数的实现。</p>
<p>首先是dlerror()的code：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tmp = dl_err_str;</div><div class="line">    dl_err_str = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">const</span> <span class="keyword">char</span> *)tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到这个函数的实现非常简单，就只是返回一条error message dl_err_str而已。但这个error message究竟是如何设置的呢？它当然是set_dlerror()函数设置的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This file hijacks the symbols stubbed out in libdl.so. */</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DL_SUCCESS                    0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DL_ERR_CANNOT_LOAD_LIBRARY    1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DL_ERR_INVALID_LIBRARY_HANDLE 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DL_ERR_BAD_SYMBOL_NAME        3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DL_ERR_SYMBOL_NOT_FOUND       4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DL_ERR_SYMBOL_NOT_GLOBAL      5</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> dl_err_buf[<span class="number">1024</span>];</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *dl_err_str;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *dl_errors[] = &#123;</div><div class="line">    [DL_ERR_CANNOT_LOAD_LIBRARY] = <span class="string">"Cannot load library"</span>,</div><div class="line">    [DL_ERR_INVALID_LIBRARY_HANDLE] = <span class="string">"Invalid library handle"</span>,</div><div class="line">    [DL_ERR_BAD_SYMBOL_NAME] = <span class="string">"Invalid symbol name"</span>,</div><div class="line">    [DL_ERR_SYMBOL_NOT_FOUND] = <span class="string">"Symbol not found"</span>,</div><div class="line">    [DL_ERR_SYMBOL_NOT_GLOBAL] = <span class="string">"Symbol is not global"</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(expr)   __builtin_expect (expr, 1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(expr) __builtin_expect (expr, 0)</span></div><div class="line"></div><div class="line"><span class="keyword">pthread_mutex_t</span> dl_lock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_dlerror</span><span class="params">(<span class="keyword">int</span> err)</span></span></div><div class="line">&#123;</div><div class="line">    format_buffer(dl_err_buf, <span class="keyword">sizeof</span>(dl_err_buf), <span class="string">"%s: %s"</span>, dl_errors[err],</div><div class="line">             linker_get_error());</div><div class="line">    dl_err_str = (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;dl_err_buf[<span class="number">0</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>set_dlerror()这个函数所完成的事情就是向一个缓冲区中格式化输出一条error message，并设置dl_err_str。可以看到这条error message将主要由两部分组成，一部分来自于dl_errors数组，set_dlerror()函数会依据错误类型来选择数组的成员，从而这个部分将是关于出错的类型的信息。另一部分则来自于linker_get_error()函数。接下来我们就来看一下linker_get_error()函数到底返回了一个什么鸟东西：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> tmp_err_buf[<span class="number">768</span>];</div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> __linker_dl_err_buf[<span class="number">768</span>];</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BASENAME(s) (strrchr(s, '/') != NULL ? strrchr(s, '/') + 1 : s)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DL_ERR(fmt, x...) \</span></div><div class="line">    <span class="keyword">do</span> &#123; \</div><div class="line">        format_buffer(__linker_dl_err_buf, <span class="keyword">sizeof</span>(__linker_dl_err_buf), \</div><div class="line">                      <span class="string">"%s(%s:%d): "</span> fmt, \</div><div class="line">                      __FUNCTION__, BASENAME(__FILE__), __LINE__, <span class="meta">##x); \</span></div><div class="line">        ERROR(fmt <span class="string">"\n"</span>, <span class="meta">##x); \</span></div><div class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *linker_get_error(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;__linker_dl_err_buf[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数倒也简单，返回了一个字串而已<strong>linker_dl_err_buf。那这个</strong>linker_dl_err_buf又是从哪儿来的呢？可以看上面的那个宏DL_ERR，它正来自于这个宏。在加载动态链接库过程出错的那个点上，宏DL_ERR会被调用，由这个宏的实现，我们可以看到，__linker_dl_err_buf将会包含出错点的函数名，文件名，行号等信息，即error message的这个部分，主要给调用者提供一些关于出错点的详细的信息。</p>
<h1 id="查找一个动态链接库"><a href="#查找一个动态链接库" class="headerlink" title="查找一个动态链接库"></a>查找一个动态链接库</h1><p>回归主题，来看linker到底是如何查找一个动态链接库的。首先来看一下find_library()函数是怎么实现的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function">soinfo *<span class="title">find_library</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></div><div class="line">&#123;</div><div class="line">    soinfo *si;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOW_SYMBOLS_FROM_MAIN</span></div><div class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> somain;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    si = find_loaded_library(name);</div><div class="line">    <span class="keyword">if</span> (si != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(si-&gt;flags &amp; FLAG_ERROR) &#123;</div><div class="line">            DL_ERR(<span class="string">"\"%s\" failed to load previously"</span>, name);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(si-&gt;flags &amp; FLAG_LINKED) <span class="keyword">return</span> si;</div><div class="line">        DL_ERR(<span class="string">"OOPS: recursive link to \"%s\""</span>, si-&gt;name);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    TRACE(<span class="string">"[ %5d '%s' has not been loaded yet.  Locating...]\n"</span>, pid, name);</div><div class="line">    si = load_library(name);</div><div class="line">    <span class="keyword">if</span>(si == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> init_library(si);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先不去关心那些错误处理的部分，即假设传入的动态连接库文件名为一个有效的文件名，而各个函数的返回值在预期范围内的情况。这个函数的执行流程大致为：</p>
<ol>
<li>在已经加载的动态连接库链表里面找一个动态连接库。如果找到了，并且没有错误情况发生，则将找到的动态连接库返回给调用者。否则，执行下面的第2个步骤。</li>
<li>此时，即意味着用户请求的动态连接库还没有被加载。则此处会调用load_library()来加载一个动态连接库，调用init_library()函数来完成对于动态连接库句柄的初始化，并将结果返回给调用者。</li>
</ol>
<p>此处还有一点值得我们关注的就是，<strong><em>当传入的name参数为空的情况，可以看到在bionic中，是会返回somain动态连接库的句柄，根据code中，对于这个对象的注释，该对象指向main process，而并不是一个全局的符号表</em></strong> ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOW_SYMBOLS_FROM_MAIN</span></div><div class="line"><span class="keyword">static</span> soinfo *somain; <span class="comment">/* main process, always the one after libdl_info */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>接下来我们来看一下，linker到底是如何在一加载动态连接库中来查找一个动态连接库的。来看find_loaded_library()函数的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> soinfo *<span class="title">find_loaded_library</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></div><div class="line">&#123;</div><div class="line">    soinfo *si;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bname;</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> don't use basename only for determining libraries</span></div><div class="line">    <span class="comment">// http://code.google.com/p/android/issues/detail?id=6670</span></div><div class="line"></div><div class="line">    bname = <span class="built_in">strrchr</span>(name, <span class="string">'/'</span>);</div><div class="line">    bname = bname ? bname + <span class="number">1</span> : name;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(si = solist; si != <span class="literal">NULL</span>; si = si-&gt;next)&#123;</div><div class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(bname, si-&gt;name)) &#123;</div><div class="line">            <span class="keyword">return</span> si;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此我们也可以非常准确的了解到， <strong><em>在系统中，linker是用一个链表来组织各个动态连接库句柄的</em></strong>。并且，可以看到，<strong><em>linker就只是依据于动态连接库文件的文件名来查找一个动态链接库而已</em></strong>，尽管由注释看起来写这个code的人也觉得这样不是很合理。</p>
<p>接下来我们来看一下，新加载一个动态连接库，即创建动态连接库句柄的更详细的执行过程，来看load_library()函数的实现：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> soinfo* load_library(<span class="keyword">const</span> <span class="keyword">char</span>* name)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Open the file.</span></div><div class="line">    scoped_fd fd;</div><div class="line">    fd.fd = open_library(name);</div><div class="line">    <span class="keyword">if</span> (fd.fd == <span class="number">-1</span>) &#123;</div><div class="line">        DL_ERR(<span class="string">"library \"%s\" not found"</span>, name);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Read the ELF header.</span></div><div class="line">    Elf32_Ehdr header[<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> ret = TEMP_FAILURE_RETRY(read(fd.fd, (void*)header, sizeof(header)));</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">        DL_ERR(<span class="string">"can't read file \"%s\": %s"</span>, name, strerror(errno));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (ret != (<span class="keyword">int</span>)sizeof(header)) &#123;</div><div class="line">        DL_ERR(<span class="string">"too small to be an ELF executable: %s"</span>, name);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (verify_elf_header(header) &lt; <span class="number">0</span>) &#123;</div><div class="line">        DL_ERR(<span class="string">"not a valid ELF executable: %s"</span>, name);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Read the program header table.</span></div><div class="line">    <span class="keyword">const</span> Elf32_Phdr* phdr_table;</div><div class="line">    phdr_ptr phdr_holder;</div><div class="line">    ret = phdr_table_load(fd.fd, header-&gt;e_phoff, header-&gt;e_phnum,</div><div class="line">                          &amp;phdr_holder.phdr_mmap, &amp;phdr_holder.phdr_size, &amp;phdr_table);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">        DL_ERR(<span class="string">"can't load program header table: %s: %s"</span>, name, strerror(errno));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    size_t phdr_count = header-&gt;e_phnum;</div><div class="line"></div><div class="line">    <span class="comment">// Get the load extents.</span></div><div class="line">    Elf32_Addr ext_sz = phdr_table_get_load_size(phdr_table, phdr_count);</div><div class="line">    TRACE(<span class="string">"[ %5d - '%s' wants sz=0x%08x ]\n"</span>, pid, name, ext_sz);</div><div class="line">    <span class="keyword">if</span> (ext_sz == <span class="number">0</span>) &#123;</div><div class="line">        DL_ERR(<span class="string">"no loadable segments in file: %s"</span>, name);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// We no longer support pre-linked libraries.</span></div><div class="line">    <span class="keyword">if</span> (is_prelinked(fd.fd, name)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Reserve address space for all loadable segments.</span></div><div class="line">    void* load_start = <span class="keyword">NULL</span>;</div><div class="line">    Elf32_Addr load_size = <span class="number">0</span>;</div><div class="line">    Elf32_Addr load_bias = <span class="number">0</span>;</div><div class="line">    ret = phdr_table_reserve_memory(phdr_table,</div><div class="line">                                    phdr_count,</div><div class="line">                                    &amp;load_start,</div><div class="line">                                    &amp;load_size,</div><div class="line">                                    &amp;load_bias);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">        DL_ERR(<span class="string">"can't reserve %d bytes in address space for \"%s\": %s"</span>,</div><div class="line">               ext_sz, name, strerror(errno));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    TRACE(<span class="string">"[ %5d allocated memory for %s @ %p (0x%08x) ]\n"</span>,</div><div class="line">          pid, name, load_start, load_size);</div><div class="line"></div><div class="line">    <span class="comment">/* Map all the segments in our address space with default protections */</span></div><div class="line">    ret = phdr_table_load_segments(phdr_table,</div><div class="line">                                   phdr_count,</div><div class="line">                                   load_bias,</div><div class="line">                                   fd.fd);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">        DL_ERR(<span class="string">"can't map loadable segments for \"%s\": %s"</span>,</div><div class="line">               name, strerror(errno));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    soinfo_ptr si(name);</div><div class="line">    <span class="keyword">if</span> (si.ptr == <span class="keyword">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    si.ptr-&gt;base = (Elf32_Addr) load_start;</div><div class="line">    si.ptr-&gt;size = load_size;</div><div class="line">    si.ptr-&gt;load_bias = load_bias;</div><div class="line">    si.ptr-&gt;flags = <span class="number">0</span>;</div><div class="line">    si.ptr-&gt;entry = <span class="number">0</span>;</div><div class="line">    si.ptr-&gt;dynamic = (unsigned *)<span class="number">-1</span>;</div><div class="line">    si.ptr-&gt;phnum = phdr_count;</div><div class="line">    si.ptr-&gt;phdr = phdr_table_get_loaded_phdr(phdr_table, phdr_count, load_bias);</div><div class="line">    <span class="keyword">if</span> (si.ptr-&gt;phdr == <span class="keyword">NULL</span>) &#123;</div><div class="line">        DL_ERR(<span class="string">"can't find loaded PHDR for \"%s\""</span>, name);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> si.release();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本上即是依据于ELF文件格式，来load一个动态连接库。更详细信息，此处先不做过多讨论。</p>
<h1 id="dlsym-函数"><a href="#dlsym-函数" class="headerlink" title="dlsym()函数"></a>dlsym()函数</h1><p>然后来看一下dlsym()函数，通过一个动态连接库句柄，来查找一个symbol的过程。dlsym()函数的实现如下：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">void *dlsym(void *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</div><div class="line">&#123;</div><div class="line">    soinfo *found;</div><div class="line">    Elf32_Sym *sym;</div><div class="line">    unsigned bind;</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;dl_lock);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">unlikely</span>(handle == <span class="number">0</span>)) &#123;</div><div class="line">        set_dlerror(DL_ERR_INVALID_LIBRARY_HANDLE);</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">unlikely</span>(symbol == <span class="number">0</span>)) &#123;</div><div class="line">        set_dlerror(DL_ERR_BAD_SYMBOL_NAME);</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(handle == RTLD_DEFAULT) &#123;</div><div class="line">        sym = lookup(symbol, &amp;found, <span class="keyword">NULL</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(handle == RTLD_NEXT) &#123;</div><div class="line">        void *ret_addr = __builtin_return_address(<span class="number">0</span>);</div><div class="line">        soinfo *si = find_containing_library(ret_addr);</div><div class="line"></div><div class="line">        sym = <span class="keyword">NULL</span>;</div><div class="line">        <span class="keyword">if</span>(si &amp;&amp; si-&gt;next) &#123;</div><div class="line">            sym = lookup(symbol, &amp;found, si-&gt;next);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        found = (soinfo*)handle;</div><div class="line">        sym = soinfo_lookup(found, symbol);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(likely(sym != <span class="number">0</span>)) &#123;</div><div class="line">        bind = ELF32_ST_BIND(sym-&gt;st_info);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(likely((bind == STB_GLOBAL) &amp;&amp; (sym-&gt;st_shndx != <span class="number">0</span>))) &#123;</div><div class="line">            unsigned ret = sym-&gt;st_value + found-&gt;base;</div><div class="line">            pthread_mutex_unlock(&amp;dl_lock);</div><div class="line">            <span class="keyword">return</span> (void*)ret;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        set_dlerror(DL_ERR_SYMBOL_NOT_GLOBAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        set_dlerror(DL_ERR_SYMBOL_NOT_FOUND);</div><div class="line"></div><div class="line">err:</div><div class="line">    pthread_mutex_unlock(&amp;dl_lock);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整体而言，这个函数做了几件事情：</p>
<ol>
<li>获取到一个互斥量。这个互斥量用于保护动态连接库的链表。</li>
<li>在指定的动态连接库上，为特定的符号查找一个Elf32_Sym对象，及包含此Elf32_Sym对象的动态连接库的句柄。</li>
<li>通过获取到的动态连接库的句柄，即soinfo对象，及Elf32_Sym对象及算出符号的地址。</li>
<li>释放互斥量。并将计算出来的符号的地址返回给调用者。</li>
</ol>
<p>接下来我们看一下，为特定的符号查找一个Elf32_Sym对象和包含此Elf32_Sym对象的动态连接库句柄及计算符号地址的过程。</p>
<h2 id="为一个特定的符号查找Elf32-Sym对象"><a href="#为一个特定的符号查找Elf32-Sym对象" class="headerlink" title="为一个特定的符号查找Elf32_Sym对象"></a>为一个特定的符号查找Elf32_Sym对象</h2><p>首先我们先来看一下为特定的符号查找一个Elf32_Sym对象及包含此Elf32_Sym对象的动态连接库句柄的过程。由前面dlsym()函数的code，可以看到这个过程是依据于handle的类型而分为3种情况来执行的，即handle为RTLD_DEFAULT，RTLD_NEXT及其他。</p>
<p>首先是handle为RTLD_DEFAULT的情况，可以看到它就仅仅是简单调用了lookup()函数来完成这整个搜索过程而已。我们来看一下lookup()函数的定义：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This is used by dl_sym().  It performs a global symbol lookup.</span></div><div class="line"> */</div><div class="line">Elf32_Sym *lookup(<span class="keyword">const</span> <span class="keyword">char</span> *name, soinfo **found, soinfo *start)</div><div class="line">&#123;</div><div class="line">    unsigned elf_hash = elfhash(name);</div><div class="line">    Elf32_Sym *s = <span class="keyword">NULL</span>;</div><div class="line">    soinfo *si;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(start == <span class="keyword">NULL</span>) &#123;</div><div class="line">        start = solist;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(si = start; (s == <span class="keyword">NULL</span>) &amp;&amp; (si != <span class="keyword">NULL</span>); si = si-&gt;next)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(si-&gt;flags &amp; FLAG_ERROR)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        s = soinfo_elf_lookup(si, elf_hash, name);</div><div class="line">        <span class="keyword">if</span> (s != <span class="keyword">NULL</span>) &#123;</div><div class="line">            *found = si;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(s != <span class="keyword">NULL</span>) &#123;</div><div class="line">        TRACE_TYPE(LOOKUP, <span class="string">"%5d %s s-&gt;st_value = 0x%08x, "</span></div><div class="line">                   <span class="string">"si-&gt;base = 0x%08x\n"</span>, pid, name, s-&gt;st_value, si-&gt;base);</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们知道，在handle为RTLD_DEFAULT的情况中，调用lookup()时，其start soinfo是一个NULL值。由上面的code来看，则意味着，在这种情况下，linker将遍历系统中已经加载的所有动态链接库，即系统的soinfo对象链表，并通过调soinfo_elf_lookup()函数来在每一个动态连接库里查找那个符号(关于soinfo_elf_lookup()函数更详细的信息，会在后面讨论)。</p>
<p>也就是说，<strong><em>当我们想要从全局符号表中查找一个符号时，我们给dlsym()函数传递的handle参数应该为RTLD_DEFAULT，而不是用NULL filename来调用dlopen()函数而得到的那个返回的handle</em></strong>。</p>
<p>接下来，我们来看handle为RTLD_NEXT的情况。不过那个<strong>builtin_return_address(0)到底是一个什么东西呢？它其实是一个gcc的内置函数，用于帮助获取给定函数的调用地址，此处即是要获取dlsym()函数的调用地址。</strong>builtin_return_address()接收一个称为 level 的参数。这个参数定义希望获取 返回地址的调用堆栈级别。例如，如果指定 level 为 0，那么就是请求当前函数的返回地址。如果指定 level 为 1，那么就是请求 调用了当前函数 的函数的返回地址，依此类推。(关于的更多信息，请参考IBM developer works上的一份文档， <a href="www.ibm.com/developerworks/cn/linux/l-gcc-hacks/">Linux 内核中的 GCC 特性</a> )。</p>
<p>那获取到的dysym()函数的返回地址又有什么用呢？接下来来看一下find_containing_library(ret_addr)函数又做些了什么事情：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">soinfo *<span class="title">find_containing_library</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span></div><div class="line">&#123;</div><div class="line">    soinfo *si;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(si = solist; si != <span class="literal">NULL</span>; si = si-&gt;next)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>((<span class="keyword">unsigned</span>)addr &gt;= si-&gt;base &amp;&amp; (<span class="keyword">unsigned</span>)addr - si-&gt;base &lt; si-&gt;size) &#123;</div><div class="line">            <span class="keyword">return</span> si;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，这个函数所完成的事情即是查找到dlsym()函数的调用者所属的那个动态连接库的句柄。接下来，handle为RTLD_NEXT的情况下查找特定的符号的一个Elf32_Sym对象及包含此Elf32_Sym对象的动态连接库句柄的过程即是，同样调用lookup()函数来在链表里搜索。即 <strong><em>handle为RTLD_NEXT的情况下，会从dlsym()函数的调用者所属的动态连接库的下一个开始，在动态连接库链表中来查找特定的符号的一个Elf32_Sym对象及包含此Elf32_Sym对象的动态连接库句柄</em></strong>。</p>
<p>然后是第三种情况，即handle来自于一个dlopen()函数调用的返回值的情况，或者说其他情况。此种情况下，则会直接调用soinfo_lookup()函数来在一个特定动态连接库句柄上查找一个特定的符号。我们来看soinfo_lookup()函数的实现：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">static Elf32_Sym *soinfo_elf_lookup(soinfo *si, unsigned hash, const char *<span class="keyword">name</span>)</div><div class="line">&#123;</div><div class="line">    Elf32_Sym *s;</div><div class="line">    E<span class="function"><span class="title">lf32_Sym</span> *symtab = si-&gt;</span>symtab;</div><div class="line">    <span class="function"><span class="title">const</span> char *strtab = si-&gt;</span>strtab;</div><div class="line">    unsigned n;</div><div class="line"></div><div class="line">    TRACE_TYPE(LOOKUP, <span class="string">"%5d SEARCH %s in %s@0x%08x %08x %d\n"</span>, pid,</div><div class="line">               <span class="function"><span class="title">name</span>, si-&gt;</span><span class="function"><span class="title">name</span>, si-&gt;</span><span class="function"><span class="title">base</span>, hash, hash % si-&gt;</span>nbucket);</div><div class="line">    <span class="function"><span class="title">n</span> = hash % si-&gt;</span>nbucket;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">for</span>(n = si-&gt;</span><span class="function"><span class="title">bucket</span>[hash % si-&gt;</span><span class="function"><span class="title">nbucket</span>]; n != 0; n = si-&gt;</span>chain[n])&#123;</div><div class="line">        s = symtab + n;</div><div class="line">        <span class="function"><span class="title">if</span>(strcmp(strtab + s-&gt;</span>st_name, <span class="keyword">name</span>)) continue;</div><div class="line"></div><div class="line">            <span class="comment">/* only concern ourselves with global and weak symbol definitions */</span></div><div class="line">        <span class="function"><span class="title">switch</span>(ELF32_ST_BIND(s-&gt;</span>st_info))&#123;</div><div class="line">        case STB_GLOBAL:</div><div class="line">        case STB_WEAK:</div><div class="line">            <span class="function"><span class="title">if</span>(s-&gt;</span>st_shndx == SHN_UNDEF)</div><div class="line">                continue;</div><div class="line"></div><div class="line">            TRACE_TYPE(LOOKUP, <span class="string">"%5d FOUND %s in %s (%08x) %d\n"</span>, pid,</div><div class="line">                       <span class="function"><span class="title">name</span>, si-&gt;</span><span class="function"><span class="title">name</span>, s-&gt;</span><span class="function"><span class="title">st_value</span>, s-&gt;</span>st_size);</div><div class="line">            return s;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* This is used by dl_sym().  It performs symbol lookup only within the</span></div><div class="line">   specified soinfo object and not in any of its dependencies.</div><div class="line"> */</div><div class="line">Elf32_Sym *soinfo_lookup(soinfo *si, const char *<span class="keyword">name</span>)</div><div class="line">&#123;</div><div class="line">    return soinfo_elf_lookup(si, elfhash(<span class="keyword">name</span>), <span class="keyword">name</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>soinfo_lookup()函数本身则是直接调用soinfo_elf_lookup()函数来完成整个的查找的过程。而在soinfo_elf_lookup()函数中，则是依据于soinfo对象中存储Elf32_Sym对象的这种特殊的方式，来遍历查找。</p>
<h2 id="计算符号的地址"><a href="#计算符号的地址" class="headerlink" title="计算符号的地址"></a>计算符号的地址</h2><p>dlsym()返回的符号的地址，是算出来的，而不是直接从什么地方读出来的。可以看到这种计算的方法，即symbol_address = (sym-&gt;st_value + found-&gt;base)。符号的地址即为动态连接库的基地址 + 该符号的Elf32_Sym对象的st_value值。</p>
<p>Done。</p>
</div><div class="tags"><a href="/tags/Android开发/">Android开发</a><a href="/tags/源码分析/">源码分析</a><a href="/tags/C-C-开发/">C/C++开发</a></div><div class="post-nav"><a href="/2013/09/11/messagequeue_in_android/" class="pre">android的消息队列机制</a><a href="/2013/05/11/Java_System_loadLibrary/" class="next">Java中System.loadLibrary() 的执行过程</a></div><div id="disqus_thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-图形系统/">Android 图形系统</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发/">Android开发</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-开发/">C/C++开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java开发/">Java开发</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核/">Linux内核</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/live555/">live555</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/业界趣闻/">业界趣闻</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台开发/">后台开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络调试/">网络调试</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随想杂谈/">随想杂谈</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频开发/">音视频开发</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/Android开发/" style="font-size: 15px;">Android开发</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/chromium/" style="font-size: 15px;">chromium</a> <a href="/tags/后台开发/" style="font-size: 15px;">后台开发</a> <a href="/tags/Java开发/" style="font-size: 15px;">Java开发</a> <a href="/tags/QUIC/" style="font-size: 15px;">QUIC</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/网络调试/" style="font-size: 15px;">网络调试</a> <a href="/tags/HTTP2/" style="font-size: 15px;">HTTP2</a> <a href="/tags/UDT/" style="font-size: 15px;">UDT</a> <a href="/tags/图形图像/" style="font-size: 15px;">图形图像</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/C-C-开发/" style="font-size: 15px;">C/C++开发</a> <a href="/tags/音视频开发/" style="font-size: 15px;">音视频开发</a> <a href="/tags/Linux内核/" style="font-size: 15px;">Linux内核</a> <a href="/tags/live555/" style="font-size: 15px;">live555</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/Go-语言/" style="font-size: 15px;">Go 语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">二月 2013</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/15/egl_context_creation/">EGL Context 创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/14/egl_init_drivers/">Android 图形驱动初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/opengl_on_android_with_sv/">在 Android 中使用 OpenGL</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/12/android_debug_gdb/">使用 GDB 调试 Android 应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/11/android_emulator_dev/">Android 模拟器下载、编译及调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/live555_src_analysis_start_streaming/">live555 源码分析：播放启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/live555_src_analysis_subsession_setup/">live555 源码分析：子会话 SETUP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/07/live555_src_analysis_subsession_sdp/">live555 源码分析：子会话 SDP 行生成</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/07/live555_src_analysis_servermediasession/">live555 源码分析：ServerMediaSession</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/live555_src_analysis_rtspserver_arch/">live555 源码分析：RTSPServer 组件结构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="https://source.android.com/" title="Android Open Source Project" target="_blank">Android Open Source Project</a><ul></ul><a href="http://www.vants.org/" title="蚂蚁网" target="_blank">蚂蚁网</a></div><div class="widget"><div class="widget-title"><i class="fa fa-commt"> 最近评论</i></div><script type="text/javascript" src="//wolfcstech.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.2.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:hanpfei@gmail.com" target="_blank" class="fa fa-email"> </a><a href="undefined" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/hanpfei" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">Han Pengfei</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var disqus_shortname = 'wolfcstech';
var disqus_identifier = '2013/07/13/dlopen_and_dlsym/';
var disqus_title = 'android下运行时动态链接dlopen()和dlsym()的实现';
var disqus_url = 'https://www.wolfcstech.com/2013/07/13/dlopen_and_dlsym/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wolfcstech.disqus.com/count.js" async></script><script type="text/javascript" src="/js/search.json.js?v=1.2.0"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3c736b12c32c019fd9ff6c825b6b9b44";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></body></html>