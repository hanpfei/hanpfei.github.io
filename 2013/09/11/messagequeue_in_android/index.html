<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>android的消息队列机制 | WolfcsTech</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.2.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.2.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">android的消息队列机制</h1><a id="logo" href="/.">WolfcsTech</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">android的消息队列机制</h1><div class="post-meta">Sep 11, 2013<span> | </span><span class="category"><a href="/categories/Android开发/">Android开发</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2013/09/11/messagequeue_in_android/" href="/2013/09/11/messagequeue_in_android/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>﻿android下的线程，Looper线程，MessageQueue，Handler，Message等之间的关系，以及Message的send/post及Message dispatch的过程。</p>
<a id="more"></a>
<h1 id="Looper线程"><a href="#Looper线程" class="headerlink" title="Looper线程"></a>Looper线程</h1><p>我们知道，线程是进程中某个单一顺序的控制流，它是内核做CPU调度的单位。那何为Looper线程呢？所谓Looper线程，即是借助于Looper和MessageQueue来管理控制流的一类线程。在android系统中，app的主线程即是借助于Looper和MessageQueue来管理控制流的，因而主线就是一个特殊的Looper线程。其实，不仅仅只有主线程可以用Looper和MessageQueue来管理控制流，其它的线程也一样可以。我们可以先看一下android源代码(Looper类，位置为frameworks/base/core/java/android/os/Looper.java)的注释中给出的一种Looper线程的实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.messagequeuedemo;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.os.Handler;</div><div class="line"><span class="keyword">import</span> android.os.Looper;</div><div class="line"><span class="keyword">import</span> android.util.Log;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MainActivity.TAG;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CompTAG = <span class="string">"LooperThread"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Handler mHandler;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.d(TAG, CompTAG + <span class="string">": LooperThread=&gt;run"</span>);</div><div class="line">        Looper.prepare();</div><div class="line"></div><div class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(android.os.Message msg)</span> </span>&#123;</div><div class="line">                Log.d(TAG, CompTAG + <span class="string">": LooperThread=&gt;Handler=&gt;handleMessage"</span>);</div><div class="line">                <span class="comment">// process incoming message here</span></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Looper.loop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，就是在线程的run()方法中，调用Looper.prepare()做一些初始化，然后创建一个Handler对象，最后执行Looper.loop()启动整个的事件循环。就是这么简单的几行代码，一个可以使用消息队列来管理线程执行流程的Looper 线程就创建好了。</p>
<p>那么上面的每一行代码，具体又都做了些什么呢？接着我们就先来看下，神秘的Looper.prepare()到底都干了些什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></div><div class="line">     <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/** Initialize the current thread as a looper.</span></div><div class="line">      * This gives you a chance to create handlers that then reference</div><div class="line">      * this looper, before actually starting the loop. Be sure to call</div><div class="line">      * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</div><div class="line">      * &#123;<span class="doctag">@link</span> #quit()&#125;.</div><div class="line">      */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">        mRun = <span class="keyword">true</span>;</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>由这段代码可知，Looper.prepare()是一个静态方法，它做的事情就是简单地为当前的线程创建一个Looper对象，并存储在一个静态的线程局部存储变量中。在Looper的构造函数中又创建了一个MessageQueue对象。同时Looper会引用到当前的线程，并将一个表示执行状态的变量mRun设置为true。对于此处的线程局部存储变量sThreadLocal，可以简单地理解为一个HashMap，该HashMap中存放的数据其类型为Looper，key则为Thread，而每个线程又都只能获得特定于这个线程的key，从而访问到专属于这个线程的数据。</p>
<p>启动Looper线程就和启动普通的线程一样，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessageQueueDemo"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CompTAG = <span class="string">"MainActivity"</span>;</div><div class="line">    <span class="keyword">private</span> LooperThread mLooperThread;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        Log.d(TAG, CompTAG + <span class="string">": MainActivity=&gt;onCreate"</span>);</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        mLooperThread = <span class="keyword">new</span> LooperThread();</div><div class="line">        mLooperThread.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>同样是new一个对象，然后调用该对象的start()方法。</p>
<p>Android SDK本身也提供了一个class来实现LooperThread那样的机制，以方便在app中创建一个执行事件处理循环的后台线程，但提供的功能要完善得多，这个class就是HandlerThread。我们可以看一下这个class的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> android.os;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Handy class for starting a new thread that has a looper. The looper can then be </div><div class="line"> * used to create handler classes. Note that start() must still be called.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> mPriority;</div><div class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</div><div class="line">    Looper mLooper;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Constructs a HandlerThread.</div><div class="line">     * <span class="doctag">@param</span> name</div><div class="line">     * <span class="doctag">@param</span> priority The priority to run the thread at. The value supplied must be from </div><div class="line">     * &#123;<span class="doctag">@link</span> android.os.Process&#125; and not from java.lang.Thread.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">        mPriority = priority;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Call back method that can be explicitly overridden if needed to execute some</div><div class="line">     * setup before Looper loops.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        mTid = Process.myTid();</div><div class="line">        Looper.prepare();</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            mLooper = Looper.myLooper();</div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">        Process.setThreadPriority(mPriority);</div><div class="line">        onLooperPrepared();</div><div class="line">        Looper.loop();</div><div class="line">        mTid = -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This method returns the Looper associated with this thread. If this thread not been started</div><div class="line">     * or for any reason is isAlive() returns false, this method will return null. If this thread </div><div class="line">     * has been started, this method will block until the looper has been initialized.  </div><div class="line">     * <span class="doctag">@return</span> The looper.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    wait();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mLooper;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Quits the handler thread's looper.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Causes the handler thread's looper to terminate without processing any</div><div class="line">     * more messages in the message queue.</div><div class="line">     * &lt;/p&gt;&lt;p&gt;</div><div class="line">     * Any attempt to post messages to the queue after the looper is asked to quit will fail.</div><div class="line">     * For example, the &#123;<span class="doctag">@link</span> Handler#sendMessage(Message)&#125; method will return false.</div><div class="line">     * &lt;/p&gt;&lt;p class="note"&gt;</div><div class="line">     * Using this method may be unsafe because some messages may not be delivered</div><div class="line">     * before the looper terminates.  Consider using &#123;<span class="doctag">@link</span> #quitSafely&#125; instead to ensure</div><div class="line">     * that all pending work is completed in an orderly manner.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> True if the looper looper has been asked to quit or false if the</div><div class="line">     * thread had not yet started running.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span> #quitSafely</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</div><div class="line">        Looper looper = getLooper();</div><div class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</div><div class="line">            looper.quit();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Quits the handler thread's looper safely.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Causes the handler thread's looper to terminate as soon as all remaining messages</div><div class="line">     * in the message queue that are already due to be delivered have been handled.</div><div class="line">     * Pending delayed messages with due times in the future will not be delivered.</div><div class="line">     * &lt;/p&gt;&lt;p&gt;</div><div class="line">     * Any attempt to post messages to the queue after the looper is asked to quit will fail.</div><div class="line">     * For example, the &#123;<span class="doctag">@link</span> Handler#sendMessage(Message)&#125; method will return false.</div><div class="line">     * &lt;/p&gt;&lt;p&gt;</div><div class="line">     * If the thread has not been started or has finished (that is if</div><div class="line">     * &#123;<span class="doctag">@link</span> #getLooper&#125; returns null), then false is returned.</div><div class="line">     * Otherwise the looper is asked to quit and true is returned.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> True if the looper looper has been asked to quit or false if the</div><div class="line">     * thread had not yet started running.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</div><div class="line">        Looper looper = getLooper();</div><div class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</div><div class="line">            looper.quitSafely();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the identifier of this thread. See Process.myTid().</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mTid;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它不仅有事件处理循环，还给app提供了灵活地设置HandlerThread的线程优先级的方法；事件循环实际启动前的回调(onLooperPrepared())；获取HandlerThread的Looper的方法(这个方法对于Handler比较重要)；以及多种停掉HandlerThread的方法——quit()和quitSafely()——以避免资源的leak。</p>
<p>Looper线程有两种，一种是我们上面看到的那种由app自己创建，并在后台运行的类型；另外一种则是android Java应用的主线程。创建前者的Looper对象需要使用Looper.prepare()方法，而创建后者的，则需使用Looper.prepareMainLooper()方法。我们可以看一下Looper.prepareMainLooper()的实现：<br><figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * Initialize the current thread as a looper, marking it as an</div><div class="line">     * application's main looper. The main looper for your application</div><div class="line">     * is created by the Android environment, so you should never need</div><div class="line">     * to call this function yourself.  See also: &#123;@link #prepare()&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> prepareMainLooper() &#123;</div><div class="line">        prepare(<span class="literal">false</span>);</div><div class="line">        <span class="keyword">synchronized</span> (Looper.<span class="keyword">class</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">            &#125;</div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>比较特别的地方即在于，此处调用prepare()方法传进去的quitAllowed参数为false，即表示这个Looper不能够被quit掉。其他倒是基本一样。整个android系统中，调用到prepareMainLooper()方法的地方有两个：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta-keyword">/frameworks/</span>base<span class="meta-keyword">/services/</span>java<span class="meta-keyword">/com/</span>android<span class="meta-keyword">/server/</span></div><div class="line">H A D	SystemServer.java	<span class="number">94</span> Looper.prepareMainLooper();</div><div class="line"><span class="meta-keyword">/frameworks/</span>base<span class="meta-keyword">/core/</span>java<span class="meta-keyword">/android/</span>app/</div><div class="line">H A D	ActivityThread.java	<span class="number">5087</span> Looper.prepareMainLooper();</div></pre></td></tr></table></figure></p>
<p>一处在SystemServer——system_server的主线程——的run()方法中，用于为system_server主线程初始化消息处理队列；另外一处在ActivityThread的run()方法中，自然即是创建android app主线程的消息处理队列了。</p>
<h1 id="通过消息与Looper线程交互"><a href="#通过消息与Looper线程交互" class="headerlink" title="通过消息与Looper线程交互"></a>通过消息与Looper线程交互</h1><p>那Looper线程的特别之处究竟在哪里呢？如前所述，这种线程有一个Looper与之关联，会使用消息队列，或者称为事件循环来管理执行的流程。那这种特别之处又如何体现呢？答案即是其它线程可以向此类线程中丢消息进来（当然此类线程本身也可以往自己的消息队列里面丢消息），然后在事件处理循环中，这些事件会得到处理。那究竟要如何往Looper线程的消息队列中发送消息呢？</p>
<p>回忆前面我们创建Looper线程的那段代码，不是有创建一个Handler出来嘛。没错，就是通过Handler来向Looper线程的MessageQueue中发送消息的。可以看一下使用Handler向Looper线程发送消息的方法。LooperThread的代码与上面的一样，向Looper线程发送消息的部分的写法：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.intel.helloworld;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.os.Bundle;</div><div class="line"><span class="keyword">import</span> android.os.Handler;</div><div class="line"><span class="keyword">import</span> android.os.Message;</div><div class="line"><span class="keyword">import</span> android.app.Activity;</div><div class="line"><span class="keyword">import</span> android.util.Log;</div><div class="line"><span class="keyword">import</span> android.view.Menu;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"LifecycleDemoApp"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CompTAG = <span class="string">"MainActivity"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_WHAT_CREATE = <span class="number">1</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_WHAT_START = <span class="number">2</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_WHAT_RESUME = <span class="number">3</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_WHAT_PAUSE = <span class="number">4</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_WHAT_STOP = <span class="number">5</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_WHAT_DESTROY = <span class="number">6</span>;</div><div class="line"></div><div class="line">    LooperThread mThread;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        Log.d(TAG, CompTAG + <span class="string">": "</span> + <span class="string">"Activity--&gt;onCreate"</span>);</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        mThread = <span class="keyword">new</span> LooperThread();</div><div class="line">        mThread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> onStart() &#123;</div><div class="line">        Log.d(TAG, CompTAG + <span class="string">": "</span> + <span class="string">"Activity--&gt;onStart"</span>);</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line"></div><div class="line">        Handler <span class="keyword">handler</span> = mThread.mHandler;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = MESSAGE_WHAT_START;</div><div class="line">        <span class="keyword">handler</span>.sendMessage(msg);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> onResume() &#123;</div><div class="line">        Log.d(TAG, CompTAG + <span class="string">": "</span> + <span class="string">"Activity--&gt;onResume"</span>);</div><div class="line">        <span class="keyword">super</span>.onResume();</div><div class="line"></div><div class="line">        Handler <span class="keyword">handler</span> = mThread.mHandler;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = MESSAGE_WHAT_RESUME;</div><div class="line">        <span class="keyword">handler</span>.sendMessage(msg);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> onPause() &#123;</div><div class="line">        Log.d(TAG, CompTAG + <span class="string">": "</span> + <span class="string">"Activity--&gt;onPause"</span>);</div><div class="line">        <span class="keyword">super</span>.onPause();</div><div class="line"></div><div class="line">        Handler <span class="keyword">handler</span> = mThread.mHandler;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = MESSAGE_WHAT_PAUSE;</div><div class="line">        <span class="keyword">handler</span>.sendMessage(msg);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> onStop() &#123;</div><div class="line">        Log.d(TAG, CompTAG + <span class="string">": "</span> + <span class="string">"Activity--&gt;onStop"</span>);</div><div class="line">        <span class="keyword">super</span>.onStop();</div><div class="line"></div><div class="line">        Handler <span class="keyword">handler</span> = mThread.mHandler;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = MESSAGE_WHAT_STOP;</div><div class="line">        <span class="keyword">handler</span>.sendMessage(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> onDestroy() &#123;</div><div class="line">        Log.d(TAG, CompTAG + <span class="string">": "</span> + <span class="string">"Activity--&gt;onDestroy"</span>);</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line"></div><div class="line">        Handler <span class="keyword">handler</span> = mThread.mHandler;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = MESSAGE_WHAT_DESTROY;</div><div class="line">        <span class="keyword">handler</span>.sendMessage(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">boolean</span> onCreateOptionsMenu(Menu menu) &#123;</div><div class="line">        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></div><div class="line">        getMenuInflater().inflate(R.menu.main, menu);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> onSaveInstanceState(Bundle outState) &#123;</div><div class="line">        Log.d(TAG, CompTAG + <span class="string">": "</span> + <span class="string">"Activity--&gt;onSaveInstanceState"</span>);</div><div class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用Handler向一个Looper线程发送消息的过程，基本上即是，调用Message.obtain()或Handler.obtainMessage()获取一个Message对象-&gt;设置Message对象-&gt;调用 <strong><em>在Looper线程中创建的Handler对象的方法发送消息</em></strong>。</p>
<p>Handler究竟是如何知道要向哪个MessageQueue发送消息的呢？从前面的代码中，我们似乎看不到任何Handler与MessageQueue能关联起来的迹象。这究竟是怎么回事呢？这也是我们特别强调 <strong><em>要使用Looper线程中创建的Handler对象</em></strong> 来向该Looper线程中发送消息的原因。我们可以看一下Handler对象构造的过程：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line">    /**</div><div class="line">     * Default constructor associates this handler <span class="keyword">with</span> <span class="keyword">the</span> &#123;@link Looper&#125; <span class="keyword">for</span> <span class="keyword">the</span></div><div class="line">     * current thread.</div><div class="line">     *</div><div class="line">     * If this thread <span class="keyword">does</span> <span class="keyword">not</span> have a looper, this handler won't be able <span class="keyword">to</span> receive messages</div><div class="line">     * so an exception <span class="keyword">is</span> thrown.</div><div class="line">     */</div><div class="line">    public Handler() &#123;</div><div class="line">        this(null, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Constructor associates this handler <span class="keyword">with</span> <span class="keyword">the</span> &#123;@link Looper&#125; <span class="keyword">for</span> <span class="keyword">the</span></div><div class="line">     * current thread <span class="keyword">and</span> takes a callback interface <span class="keyword">in</span> which you can handle</div><div class="line">     * messages.</div><div class="line">     *</div><div class="line">     * If this thread <span class="keyword">does</span> <span class="keyword">not</span> have a looper, this handler won't be able <span class="keyword">to</span> receive messages</div><div class="line">     * so an exception <span class="keyword">is</span> thrown.</div><div class="line">     *</div><div class="line">     * @param callback The callback interface <span class="keyword">in</span> which <span class="keyword">to</span> handle messages, <span class="keyword">or</span> null.</div><div class="line">     */</div><div class="line">    public Handler(Callback callback) &#123;</div><div class="line">        this(callback, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Use <span class="keyword">the</span> provided &#123;@link Looper&#125; instead <span class="keyword">of</span> <span class="keyword">the</span> default one.</div><div class="line">     *</div><div class="line">     * @param looper The looper, must <span class="keyword">not</span> be null.</div><div class="line">     */</div><div class="line">    public Handler(Looper looper) &#123;</div><div class="line">        this(looper, null, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Use <span class="keyword">the</span> provided &#123;@link Looper&#125; instead <span class="keyword">of</span> <span class="keyword">the</span> default one <span class="keyword">and</span> take a callback</div><div class="line">     * interface <span class="keyword">in</span> which <span class="keyword">to</span> handle messages.</div><div class="line">     *</div><div class="line">     * @param looper The looper, must <span class="keyword">not</span> be null.</div><div class="line">     * @param callback The callback interface <span class="keyword">in</span> which <span class="keyword">to</span> handle messages, <span class="keyword">or</span> null.</div><div class="line">     */</div><div class="line">    public Handler(Looper looper, Callback callback) &#123;</div><div class="line">        this(looper, callback, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Use <span class="keyword">the</span> &#123;@link Looper&#125; <span class="keyword">for</span> <span class="keyword">the</span> current thread</div><div class="line">     * <span class="keyword">and</span> <span class="keyword">set</span> whether <span class="keyword">the</span> handler should be asynchronous.</div><div class="line">     *</div><div class="line">     * Handlers are synchronous <span class="keyword">by</span> default unless this constructor <span class="keyword">is</span> used <span class="keyword">to</span> make</div><div class="line">     * one <span class="keyword">that</span> <span class="keyword">is</span> strictly asynchronous.</div><div class="line">     *</div><div class="line">     * Asynchronous messages represent interrupts <span class="keyword">or</span> events <span class="keyword">that</span> do <span class="keyword">not</span> require <span class="keyword">global</span> ordering</div><div class="line">     * <span class="keyword">with</span> represent <span class="keyword">to</span> synchronous messages.  Asynchronous messages are <span class="keyword">not</span> subject <span class="keyword">to</span></div><div class="line">     * <span class="keyword">the</span> synchronization barriers introduced <span class="keyword">by</span> &#123;@link MessageQueue<span class="comment">#enqueueSyncBarrier long)&#125;.</span></div><div class="line">     *</div><div class="line">     * @param async If <span class="literal">true</span>, <span class="keyword">the</span> handler calls &#123;@link Message<span class="comment">#setAsynchronous(boolean)&#125; for</span></div><div class="line">     * each &#123;@link Message&#125; <span class="keyword">that</span> <span class="keyword">is</span> sent <span class="keyword">to</span> <span class="keyword">it</span> <span class="keyword">or</span> &#123;@link Runnable&#125; <span class="keyword">that</span> <span class="keyword">is</span> posted <span class="keyword">to</span> <span class="keyword">it</span>.</div><div class="line">     *</div><div class="line">     * @hide</div><div class="line">     */</div><div class="line">    public Handler(<span class="built_in">boolean</span> async) &#123;</div><div class="line">        this(null, async);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Use <span class="keyword">the</span> &#123;@link Looper&#125; <span class="keyword">for</span> <span class="keyword">the</span> current thread <span class="keyword">with</span> <span class="keyword">the</span> specified callback interface</div><div class="line">     * <span class="keyword">and</span> <span class="keyword">set</span> whether <span class="keyword">the</span> handler should be asynchronous.</div><div class="line">     *</div><div class="line">     * Handlers are synchronous <span class="keyword">by</span> default unless this constructor <span class="keyword">is</span> used <span class="keyword">to</span> make</div><div class="line">     * one <span class="keyword">that</span> <span class="keyword">is</span> strictly asynchronous.</div><div class="line">     *</div><div class="line">     * Asynchronous messages represent interrupts <span class="keyword">or</span> events <span class="keyword">that</span> do <span class="keyword">not</span> require <span class="keyword">global</span> ordering</div><div class="line">     * <span class="keyword">with</span> represent <span class="keyword">to</span> synchronous messages.  Asynchronous messages are <span class="keyword">not</span> subject <span class="keyword">to</span></div><div class="line">     * <span class="keyword">the</span> synchronization barriers introduced <span class="keyword">by</span> &#123;@link MessageQueue<span class="comment">#enqueueSyncBarrier long)&#125;.</span></div><div class="line">     *</div><div class="line">     * @param callback The callback interface <span class="keyword">in</span> which <span class="keyword">to</span> handle messages, <span class="keyword">or</span> null.</div><div class="line">     * @param async If <span class="literal">true</span>, <span class="keyword">the</span> handler calls &#123;@link Message<span class="comment">#setAsynchronous(boolean)&#125; for</span></div><div class="line">     * each &#123;@link Message&#125; <span class="keyword">that</span> <span class="keyword">is</span> sent <span class="keyword">to</span> <span class="keyword">it</span> <span class="keyword">or</span> &#123;@link Runnable&#125; <span class="keyword">that</span> <span class="keyword">is</span> posted <span class="keyword">to</span> <span class="keyword">it</span>.</div><div class="line">     *</div><div class="line">     * @hide</div><div class="line">     */</div><div class="line">    public Handler(Callback callback, <span class="built_in">boolean</span> async) &#123;</div><div class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">            final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                    klass.getCanonicalName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="keyword">if</span> (mLooper == null) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">        &#125;</div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Use <span class="keyword">the</span> provided &#123;@link Looper&#125; instead <span class="keyword">of</span> <span class="keyword">the</span> default one <span class="keyword">and</span> take a callback</div><div class="line">     * interface <span class="keyword">in</span> which <span class="keyword">to</span> handle messages.  Also <span class="keyword">set</span> whether <span class="keyword">the</span> handler</div><div class="line">     * should be asynchronous.</div><div class="line">     *</div><div class="line">     * Handlers are synchronous <span class="keyword">by</span> default unless this constructor <span class="keyword">is</span> used <span class="keyword">to</span> make</div><div class="line">     * one <span class="keyword">that</span> <span class="keyword">is</span> strictly asynchronous.</div><div class="line">     *</div><div class="line">     * Asynchronous messages represent interrupts <span class="keyword">or</span> events <span class="keyword">that</span> do <span class="keyword">not</span> require <span class="keyword">global</span> ordering</div><div class="line">     * <span class="keyword">with</span> respect <span class="keyword">to</span> synchronous messages.  Asynchronous messages are <span class="keyword">not</span> subject <span class="keyword">to</span></div><div class="line">     * <span class="keyword">the</span> synchronization barriers introduced <span class="keyword">by</span> &#123;@link MessageQueue<span class="comment">#enqueueSyncBarrier(long)&#125;.</span></div><div class="line">     *</div><div class="line">     * @param looper The looper, must <span class="keyword">not</span> be null.</div><div class="line">     * @param callback The callback interface <span class="keyword">in</span> which <span class="keyword">to</span> handle messages, <span class="keyword">or</span> null.</div><div class="line">     * @param async If <span class="literal">true</span>, <span class="keyword">the</span> handler calls &#123;@link Message<span class="comment">#setAsynchronous(boolean)&#125; for</span></div><div class="line">     * each &#123;@link Message&#125; <span class="keyword">that</span> <span class="keyword">is</span> sent <span class="keyword">to</span> <span class="keyword">it</span> <span class="keyword">or</span> &#123;@link Runnable&#125; <span class="keyword">that</span> <span class="keyword">is</span> posted <span class="keyword">to</span> <span class="keyword">it</span>.</div><div class="line">     *</div><div class="line">     * @hide</div><div class="line">     */</div><div class="line">    public Handler(Looper looper, Callback callback, <span class="built_in">boolean</span> async) &#123;</div><div class="line">        mLooper = looper;</div><div class="line">        mQueue = looper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Handler的构造函数共有7个，其中4个不需要传递Looper参数，3个需要。前面我们用的是不需要传递Looper对象的构造函数，因而现在我们主要关注那4个不需要传递Looper参数的。它们都是Handler(Callback callback, boolean async)不同形式的封装，而在这个构造函数中是通过Looper.myLooper()获取到当前线程的Looper对象，并与相关的MessageQueue关联起来的。这也是前面我们在实现Looper线程时，要在其run方法中创建一个public Handler的依据。</p>
<p>当然我们也可以使用那些能够手动传递Looper对象的构造函数，在构造Handler对象时，显式地使其与特定的Looper/消息队列关联起来。比如配合HandlerThread.getLooper()方法来用。</p>
<p>（这个地方我们看到， <strong><em>创建Handler对象时，可以传递另外两个参数，一个是Callback，另一个是async，那这两个参数在这套消息队列机制中，又起到一个什么样的作用呢？</em></strong> 后面我们在来解答这个问题。）</p>
<p>Handler提供了两组函数用于向一个Looper线程的MessageQueue中发送消息，分别是postXXX()族和sendXXX()族，这两组函数的调用关系大体如下所示：</p>
<p><img src="https://www.wolfcstech.com/images/085042_SlZe_919237.jpg" alt="此处输入图片的描述"></p>
<p>我们可以先看一下sendXXX()族消息发送方法：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line">    /**</div><div class="line">     * Pushes a message <span class="keyword">onto</span> <span class="keyword">the</span> <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">the</span> message queue <span class="keyword">after</span> all pending messages</div><div class="line">     * <span class="keyword">before</span> <span class="keyword">the</span> current <span class="built_in">time</span>. It will be received <span class="keyword">in</span> &#123;@link <span class="comment">#handleMessage&#125;,</span></div><div class="line">     * <span class="keyword">in</span> <span class="keyword">the</span> thread attached <span class="keyword">to</span> this handler.</div><div class="line">     *  </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> message was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.</div><div class="line">     */</div><div class="line">    public final <span class="built_in">boolean</span> sendMessage(Message msg)</div><div class="line">    &#123;</div><div class="line"><span class="built_in">        return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Sends a Message containing only <span class="keyword">the</span> what value.</div><div class="line">     *  </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> message was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.</div><div class="line">     */</div><div class="line">    public final <span class="built_in">boolean</span> sendEmptyMessage(int what)</div><div class="line">    &#123;</div><div class="line"><span class="built_in">        return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Sends a Message containing only <span class="keyword">the</span> what value, <span class="keyword">to</span> be delivered</div><div class="line">     * <span class="keyword">after</span> <span class="keyword">the</span> specified amount <span class="keyword">of</span> <span class="built_in">time</span> elapses.</div><div class="line">     * @see <span class="comment">#sendMessageDelayed(android.os.Message, long) </span></div><div class="line">     * </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> message was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.</div><div class="line">     */</div><div class="line">    public final <span class="built_in">boolean</span> sendEmptyMessageDelayed(int what, long delayMillis) &#123;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = what;</div><div class="line"><span class="built_in">        return</span> sendMessageDelayed(msg, delayMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Sends a Message containing only <span class="keyword">the</span> what value, <span class="keyword">to</span> be delivered </div><div class="line">     * <span class="keyword">at</span> a specific <span class="built_in">time</span>.</div><div class="line">     * @see <span class="comment">#sendMessageAtTime(android.os.Message, long)</span></div><div class="line">     *  </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> message was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.</div><div class="line">     */</div><div class="line"></div><div class="line">    public final <span class="built_in">boolean</span> sendEmptyMessageAtTime(int what, long uptimeMillis) &#123;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = what;</div><div class="line"><span class="built_in">        return</span> sendMessageAtTime(msg, uptimeMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Enqueue a message <span class="keyword">into</span> <span class="keyword">the</span> message queue <span class="keyword">after</span> all pending messages</div><div class="line">     * <span class="keyword">before</span> (current <span class="built_in">time</span> + delayMillis). You will receive <span class="keyword">it</span> <span class="keyword">in</span></div><div class="line">     * &#123;@link <span class="comment">#handleMessage&#125;, in the thread attached to this handler.</span></div><div class="line">     *  </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> message was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.  Note <span class="keyword">that</span> a</div><div class="line">     *         <span class="literal">result</span> <span class="keyword">of</span> <span class="literal">true</span> <span class="keyword">does</span> <span class="keyword">not</span> mean <span class="keyword">the</span> message will be processed <span class="comment">-- if</span></div><div class="line">     *         <span class="keyword">the</span> looper <span class="keyword">is</span> quit <span class="keyword">before</span> <span class="keyword">the</span> delivery <span class="built_in">time</span> <span class="keyword">of</span> <span class="keyword">the</span> message</div><div class="line">     *         occurs <span class="keyword">then</span> <span class="keyword">the</span> message will be dropped.</div><div class="line">     */</div><div class="line">    public final <span class="built_in">boolean</span> sendMessageDelayed(Message msg, long delayMillis)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">            delayMillis = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"><span class="built_in">        return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Enqueue a message <span class="keyword">into</span> <span class="keyword">the</span> message queue <span class="keyword">after</span> all pending messages</div><div class="line">     * <span class="keyword">before</span> <span class="keyword">the</span> absolute <span class="built_in">time</span> (<span class="keyword">in</span> milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</div><div class="line">     * &lt;b&gt;The <span class="built_in">time</span>-base <span class="keyword">is</span> &#123;@link android.os.SystemClock<span class="comment">#uptimeMillis&#125;.&lt;/b&gt;</span></div><div class="line">     * You will receive <span class="keyword">it</span> <span class="keyword">in</span> &#123;@link <span class="comment">#handleMessage&#125;, in the thread attached</span></div><div class="line">     * <span class="keyword">to</span> this handler.</div><div class="line">     * </div><div class="line">     * @param uptimeMillis The absolute <span class="built_in">time</span> <span class="keyword">at</span> which <span class="keyword">the</span> message should be</div><div class="line">     *         delivered, using <span class="keyword">the</span></div><div class="line">     *         &#123;@link android.os.SystemClock<span class="comment">#uptimeMillis&#125; time-base.</span></div><div class="line">     *         </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> message was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.  Note <span class="keyword">that</span> a</div><div class="line">     *         <span class="literal">result</span> <span class="keyword">of</span> <span class="literal">true</span> <span class="keyword">does</span> <span class="keyword">not</span> mean <span class="keyword">the</span> message will be processed <span class="comment">-- if</span></div><div class="line">     *         <span class="keyword">the</span> looper <span class="keyword">is</span> quit <span class="keyword">before</span> <span class="keyword">the</span> delivery <span class="built_in">time</span> <span class="keyword">of</span> <span class="keyword">the</span> message</div><div class="line">     *         occurs <span class="keyword">then</span> <span class="keyword">the</span> message will be dropped.</div><div class="line">     */</div><div class="line">    public <span class="built_in">boolean</span> sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        <span class="keyword">if</span> (queue == null) &#123;</div><div class="line">            RuntimeException e = new RuntimeException(</div><div class="line">                    this + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line"><span class="built_in">            return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"><span class="built_in">        return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Enqueue a message <span class="keyword">at</span> <span class="keyword">the</span> <span class="keyword">front</span> <span class="keyword">of</span> <span class="keyword">the</span> message queue, <span class="keyword">to</span> be processed <span class="keyword">on</span></div><div class="line">     * <span class="keyword">the</span> next iteration <span class="keyword">of</span> <span class="keyword">the</span> message loop.  You will receive <span class="keyword">it</span> <span class="keyword">in</span></div><div class="line">     * &#123;@link <span class="comment">#handleMessage&#125;, in the thread attached to this handler.</span></div><div class="line">     * &lt;b&gt;This method <span class="keyword">is</span> only <span class="keyword">for</span> use <span class="keyword">in</span> very special circumstances <span class="comment">-- it</span></div><div class="line">     * can easily starve <span class="keyword">the</span> message queue, cause ordering problems, <span class="keyword">or</span> have</div><div class="line">     * other unexpected side-effects.&lt;/b&gt;</div><div class="line">     *  </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> message was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.</div><div class="line">     */</div><div class="line">    public final <span class="built_in">boolean</span> sendMessageAtFrontOfQueue(Message msg) &#123;</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        <span class="keyword">if</span> (queue == null) &#123;</div><div class="line">            RuntimeException e = new RuntimeException(</div><div class="line">                this + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line"><span class="built_in">            return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"><span class="built_in">        return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private <span class="built_in">boolean</span> enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">        msg.target = this;</div><div class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">            msg.setAsynchronous(<span class="literal">true</span>);</div><div class="line">        &#125;</div><div class="line"><span class="built_in">        return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这些方法之间大多只有一些细微的差别，它们最终都调用Handler.enqueueMessage()/MessageQueue.enqueueMessage()方法。（<strong>哈哈，这个地方，被我们逮到一个Handler类某贡献者所犯的copy-paste错误：仔细看一下sendMessageAtTime()和sendMessageAtFrontOfQueue()这两个方法，创建RuntimeException的部分，消息中都是”sendMessageAtTime()”。</strong> ）Handler实际的职责，并不完全如它的名称所示，在处理message外，它还要负责发送Message到MessageQueue。</p>
<p>注意，在Handler.enqueueMessage()中，会将 <strong><em>Message的target设为this，而且是不加检查，强制覆盖原来的值</em></strong> 。后面我们将会看到，Message的target就是Message被dispatched到的Handler，也是将会处理这条Message的Handler。这个地方强制覆盖的逻辑表明，我们用哪个Handler来发送一条消息，那么这条消息就将会被dispatched给哪个Handler来处理，消息的发送者即接收者。这使得 <strong><em>Handler那些obtainMessage()方法，及Message需要Handler参数的那些obtain()方法显得非常多余。通过这些方法会在获取Message时设置它的target，但这些设置又总是会在后面被无条件地覆盖掉</em></strong> 。</p>
<p>再来看一下MessageQueue.enqueueMessage()方法：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">    boolean enqueueMessage(Message msg, long <span class="keyword">when</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">            <span class="keyword">throw</span> new AndroidRuntimeException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> new AndroidRuntimeException(<span class="string">"Message must have a target."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        boolean needWake;</div><div class="line">        synchronized (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mQuiting) &#123;</div><div class="line">                RuntimeException e = new RuntimeException(</div><div class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">                Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.<span class="keyword">when</span> = <span class="keyword">when</span>;</div><div class="line">            Message p = mMessages;</div><div class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span> || <span class="keyword">when</span> == <span class="number">0</span> || <span class="keyword">when</span> &lt; p.<span class="keyword">when</span>) &#123;</div><div class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">                msg.next = p;</div><div class="line">                mMessages = msg;</div><div class="line">                needWake = mBlocked;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></div><div class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></div><div class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></div><div class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">                Message prev;</div><div class="line">                <span class="keyword">for</span> (;;) &#123;</div><div class="line">                    prev = p;</div><div class="line">                    p = p.next;</div><div class="line">                    <span class="keyword">if</span> (p == <span class="literal">null</span> || <span class="keyword">when</span> &lt; p.<span class="keyword">when</span>) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                        needWake = <span class="literal">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">                prev.next = msg;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>此处我们看到，MessageQueue用一个单向链表来保存所有的Messages，在链表中各个Message按照其请求执行的时间先后来排序。将Message插入MessageQueue的算法也还算清晰简洁，不必赘述。但此处， <strong><em>MessageQueue/Message的author为什么要自己实现一个单向链表，而没有用Java标准库提供的容器组件呢？是为了插入一条新的Message方便，还是仅仅为了练习怎么用Java实现单向链表？wake的逻辑后面我们会再来研究</em></strong> 。</p>
<p>向MessageQueue中发送消息的postXXX()方法：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">    /**</div><div class="line">     * Causes <span class="keyword">the</span> Runnable r <span class="keyword">to</span> be added <span class="keyword">to</span> <span class="keyword">the</span> message queue.</div><div class="line">     * The runnable will be <span class="built_in">run</span> <span class="keyword">on</span> <span class="keyword">the</span> thread <span class="keyword">to</span> which this handler <span class="keyword">is</span></div><div class="line">     * attached.</div><div class="line">     *</div><div class="line">     * @param r The Runnable <span class="keyword">that</span> will be executed.</div><div class="line">     *</div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> Runnable was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span></div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.</div><div class="line">     */</div><div class="line">    public final <span class="built_in">boolean</span> post(Runnable r)</div><div class="line">    &#123;</div><div class="line"><span class="built_in">       return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Causes <span class="keyword">the</span> Runnable r <span class="keyword">to</span> be added <span class="keyword">to</span> <span class="keyword">the</span> message queue, <span class="keyword">to</span> be <span class="built_in">run</span></div><div class="line">     * <span class="keyword">at</span> a specific <span class="built_in">time</span> <span class="keyword">given</span> <span class="keyword">by</span> &lt;var&gt;uptimeMillis&lt;/var&gt;.</div><div class="line">     * &lt;b&gt;The <span class="built_in">time</span>-base <span class="keyword">is</span> &#123;@link android.os.SystemClock<span class="comment">#uptimeMillis&#125;.&lt;/b&gt;</span></div><div class="line">     * Time spent <span class="keyword">in</span> deep sleep will add an additional <span class="built_in">delay</span> <span class="keyword">to</span> execution.</div><div class="line">     * The runnable will be <span class="built_in">run</span> <span class="keyword">on</span> <span class="keyword">the</span> thread <span class="keyword">to</span> which this handler <span class="keyword">is</span> attached.</div><div class="line">     *</div><div class="line">     * @param r The Runnable <span class="keyword">that</span> will be executed.</div><div class="line">     * @param uptimeMillis The absolute <span class="built_in">time</span> <span class="keyword">at</span> which <span class="keyword">the</span> callback should <span class="built_in">run</span>,</div><div class="line">     *         using <span class="keyword">the</span> &#123;@link android.os.SystemClock<span class="comment">#uptimeMillis&#125; time-base.</span></div><div class="line">     *  </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> Runnable was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.  Note <span class="keyword">that</span> a</div><div class="line">     *         <span class="literal">result</span> <span class="keyword">of</span> <span class="literal">true</span> <span class="keyword">does</span> <span class="keyword">not</span> mean <span class="keyword">the</span> Runnable will be processed <span class="comment">-- if</span></div><div class="line">     *         <span class="keyword">the</span> looper <span class="keyword">is</span> quit <span class="keyword">before</span> <span class="keyword">the</span> delivery <span class="built_in">time</span> <span class="keyword">of</span> <span class="keyword">the</span> message</div><div class="line">     *         occurs <span class="keyword">then</span> <span class="keyword">the</span> message will be dropped.</div><div class="line">     */</div><div class="line">    public final <span class="built_in">boolean</span> postAtTime(Runnable r, long uptimeMillis)</div><div class="line">    &#123;</div><div class="line"><span class="built_in">        return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Causes <span class="keyword">the</span> Runnable r <span class="keyword">to</span> be added <span class="keyword">to</span> <span class="keyword">the</span> message queue, <span class="keyword">to</span> be <span class="built_in">run</span></div><div class="line">     * <span class="keyword">at</span> a specific <span class="built_in">time</span> <span class="keyword">given</span> <span class="keyword">by</span> &lt;var&gt;uptimeMillis&lt;/var&gt;.</div><div class="line">     * &lt;b&gt;The <span class="built_in">time</span>-base <span class="keyword">is</span> &#123;@link android.os.SystemClock<span class="comment">#uptimeMillis&#125;.&lt;/b&gt;</span></div><div class="line">     * Time spent <span class="keyword">in</span> deep sleep will add an additional <span class="built_in">delay</span> <span class="keyword">to</span> execution.</div><div class="line">     * The runnable will be <span class="built_in">run</span> <span class="keyword">on</span> <span class="keyword">the</span> thread <span class="keyword">to</span> which this handler <span class="keyword">is</span> attached.</div><div class="line">     *</div><div class="line">     * @param r The Runnable <span class="keyword">that</span> will be executed.</div><div class="line">     * @param uptimeMillis The absolute <span class="built_in">time</span> <span class="keyword">at</span> which <span class="keyword">the</span> callback should <span class="built_in">run</span>,</div><div class="line">     *         using <span class="keyword">the</span> &#123;@link android.os.SystemClock<span class="comment">#uptimeMillis&#125; time-base.</span></div><div class="line">     * </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> Runnable was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.  Note <span class="keyword">that</span> a</div><div class="line">     *         <span class="literal">result</span> <span class="keyword">of</span> <span class="literal">true</span> <span class="keyword">does</span> <span class="keyword">not</span> mean <span class="keyword">the</span> Runnable will be processed <span class="comment">-- if</span></div><div class="line">     *         <span class="keyword">the</span> looper <span class="keyword">is</span> quit <span class="keyword">before</span> <span class="keyword">the</span> delivery <span class="built_in">time</span> <span class="keyword">of</span> <span class="keyword">the</span> message</div><div class="line">     *         occurs <span class="keyword">then</span> <span class="keyword">the</span> message will be dropped.</div><div class="line">     *         </div><div class="line">     * @see android.os.SystemClock<span class="comment">#uptimeMillis</span></div><div class="line">     */</div><div class="line">    public final <span class="built_in">boolean</span> postAtTime(Runnable r, Object token, long uptimeMillis)</div><div class="line">    &#123;</div><div class="line"><span class="built_in">        return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Causes <span class="keyword">the</span> Runnable r <span class="keyword">to</span> be added <span class="keyword">to</span> <span class="keyword">the</span> message queue, <span class="keyword">to</span> be <span class="built_in">run</span></div><div class="line">     * <span class="keyword">after</span> <span class="keyword">the</span> specified amount <span class="keyword">of</span> <span class="built_in">time</span> elapses.</div><div class="line">     * The runnable will be <span class="built_in">run</span> <span class="keyword">on</span> <span class="keyword">the</span> thread <span class="keyword">to</span> which this handler</div><div class="line">     * <span class="keyword">is</span> attached.</div><div class="line">     * &lt;b&gt;The <span class="built_in">time</span>-base <span class="keyword">is</span> &#123;@link android.os.SystemClock<span class="comment">#uptimeMillis&#125;.&lt;/b&gt;</span></div><div class="line">     * Time spent <span class="keyword">in</span> deep sleep will add an additional <span class="built_in">delay</span> <span class="keyword">to</span> execution.</div><div class="line">     *  </div><div class="line">     * @param r The Runnable <span class="keyword">that</span> will be executed.</div><div class="line">     * @param delayMillis The <span class="built_in">delay</span> (<span class="keyword">in</span> milliseconds) <span class="keyword">until</span> <span class="keyword">the</span> Runnable</div><div class="line">     *        will be executed.</div><div class="line">     *        </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> Runnable was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.  Note <span class="keyword">that</span> a</div><div class="line">     *         <span class="literal">result</span> <span class="keyword">of</span> <span class="literal">true</span> <span class="keyword">does</span> <span class="keyword">not</span> mean <span class="keyword">the</span> Runnable will be processed <span class="comment">--</span></div><div class="line">     *         <span class="keyword">if</span> <span class="keyword">the</span> looper <span class="keyword">is</span> quit <span class="keyword">before</span> <span class="keyword">the</span> delivery <span class="built_in">time</span> <span class="keyword">of</span> <span class="keyword">the</span> message</div><div class="line">     *         occurs <span class="keyword">then</span> <span class="keyword">the</span> message will be dropped.</div><div class="line">     */</div><div class="line">    public final <span class="built_in">boolean</span> postDelayed(Runnable r, long delayMillis)</div><div class="line">    &#123;</div><div class="line"><span class="built_in">        return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Posts a message <span class="keyword">to</span> an object <span class="keyword">that</span> implements Runnable.</div><div class="line">     * Causes <span class="keyword">the</span> Runnable r <span class="keyword">to</span> executed <span class="keyword">on</span> <span class="keyword">the</span> next iteration <span class="keyword">through</span> <span class="keyword">the</span></div><div class="line">     * message queue. The runnable will be <span class="built_in">run</span> <span class="keyword">on</span> <span class="keyword">the</span> thread <span class="keyword">to</span> which this</div><div class="line">     * handler <span class="keyword">is</span> attached.</div><div class="line">     * &lt;b&gt;This method <span class="keyword">is</span> only <span class="keyword">for</span> use <span class="keyword">in</span> very special circumstances <span class="comment">-- it</span></div><div class="line">     * can easily starve <span class="keyword">the</span> message queue, cause ordering problems, <span class="keyword">or</span> have</div><div class="line">     * other unexpected side-effects.&lt;/b&gt;</div><div class="line">     *  </div><div class="line">     * @param r The Runnable <span class="keyword">that</span> will be executed.</div><div class="line">     * </div><div class="line">     * @<span class="literal">return</span> Returns <span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> message was successfully placed <span class="keyword">in</span> <span class="keyword">to</span> <span class="keyword">the</span> </div><div class="line">     *         message queue.  Returns <span class="literal">false</span> <span class="keyword">on</span> failure, usually because <span class="keyword">the</span></div><div class="line">     *         looper processing <span class="keyword">the</span> message queue <span class="keyword">is</span> exiting.</div><div class="line">     */</div><div class="line">    public final <span class="built_in">boolean</span> postAtFrontOfQueue(Runnable r)</div><div class="line">    &#123;</div><div class="line"><span class="built_in">        return</span> sendMessageAtFrontOfQueue(getPostMessage(r));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static Message getPostMessage(Runnable r) &#123;</div><div class="line">        Message m = Message.obtain();</div><div class="line">        m.callback = r;</div><div class="line"><span class="built_in">        return</span> m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static Message getPostMessage(Runnable r, Object token) &#123;</div><div class="line">        Message m = Message.obtain();</div><div class="line">        m.obj = token;</div><div class="line">        m.callback = r;</div><div class="line"><span class="built_in">        return</span> m;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这组方法相对于前面的sendXXX()族方法而言，其特殊之处在于，它们都需要传入一个Runnable参数，post的消息，其特殊之处也正在于，Message的callback将是传入的Runnable对象。这些特别的地方将影响这些消息在dispatch时的行为。</p>
<h1 id="消息队列中消息的处理"><a href="#消息队列中消息的处理" class="headerlink" title="消息队列中消息的处理"></a>消息队列中消息的处理</h1><p>消息队列中的消息是在Looper.loop()中被取出处理的：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * Run the message queue in this thread. Be sure to call</div><div class="line">     * &#123;@link #quit()&#125; to end the loop.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> loop() &#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Message msg = queue.<span class="keyword">next</span>(); <span class="comment">// might block</span></div><div class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">            Printer logging = me.mLogging;</div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.<span class="keyword">println</span>(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">                logging.<span class="keyword">println</span>(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                        + <span class="keyword">Long</span>.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                        + <span class="keyword">Long</span>.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">            msg.recycle();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在取出的msg为NULL之前，消息处理循环都一直运行。为NULL的msg表明消息队列被停掉了。在这个循环中，被取出的消息会被dispatch给一个Handler处理，即是msg.target，执行Handler.dispatchMessage()方法。</p>
<p>注意：Looper.loop()循环体的末尾，调用了从消息队列中取出且已经被dispatched处理的Message的recycle()方法，这表明Looper会帮我们自动回收发送到它的消息队列的消息。在我们将一条消息发送给Looper线程的消息队列之后，我们就不需要再担心消息的回收问题了，Looper自会帮我们很好的处理</p>
<p>接着来看Handler.dispatchMessage()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * Callback interface you can use when instantiating a Handler to avoid</div><div class="line">     * having to implement your own subclass of Handler.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</div><div class="line">     * <span class="doctag">@return</span> True if no further handling is desired</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Subclasses must implement this to receive messages.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Handle system messages here.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        message.callback.run();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以认为有三种对象可能会实际处理一条消息，分别是消息的Runnable callback，Handler的Callback mCallback和Handler对象本身。但这三种对象在获取消息的处理权方面有一定的优先级，消息的Runnable callback优先级最高，在它不为空时，只执行这个callback；优先级次高的是Handler的Callback mCallback，在它不为空时，Handler会先把消息丢给它处理，如果它不处理返回了false，Handler才会调用自己的handleMessage()来处理。</p>
<p>通常，Handler的handleMessage()方法通常需要override，来实现消息处理的主要逻辑。Handler的mCallback，使得开发者可以比较方便的将消息处理的逻辑和发送消息的Handler完全分开。</p>
<p>此处也可见post消息的特殊之处，此类消息将完全绕过Handler中用于处理消息的handleMessage() 方法，而只会执行消息的sender所实现的Runnable。</p>
<h1 id="Sleep-Wakeup机制"><a href="#Sleep-Wakeup机制" class="headerlink" title="Sleep-Wakeup机制"></a>Sleep-Wakeup机制</h1><p>还有一个问题，当MessageQueue中没有Messages时，Looper线程会做什么呢？它会不停地轮询，并检查消息队列中是否有消息吗？计算机科学发展到现在，闭上眼睛我们都能猜到，Looper线程一定不会去轮询的。Looper线程也确实没有去轮询消息队列。在消息队列为空时，Looper线程会去休眠，然后在消息队列中有了消息之后，再被唤醒。但这样的机制又是如何实现的呢？</p>
<h2 id="Sleep-Wakeup机制所需设施的建立"><a href="#Sleep-Wakeup机制所需设施的建立" class="headerlink" title="Sleep-Wakeup机制所需设施的建立"></a>Sleep-Wakeup机制所需设施的建立</h2><p>我们从Sleep-Wakeup机制所需设施的建立开始。回忆前面的Looper构造函数，它会创建一个MessageQueue对象，而Sleep-Wakeup机制所需设施正是在MessageQueue对象的创建过程中创建出来的。（在android消息队列机制中，消息取出和压入的主要逻辑都在MessageQueue中完成，MessageQueue实现一个定制的阻塞队列，将等待-唤醒的逻辑都放在这个类里想必也没什么让人吃惊的地方吧。）我们来看MessageQueue的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</div><div class="line">        mQuitAllowed = quitAllowed;</div><div class="line">        mPtr = nativeInit();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个方法调用nativeInit()方法来创建Sleep-Wakeup机制所需设施。来看nativeInit()的实现(在frameworks/base/core/jni/android_os_MessageQueue.cpp)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">NativeMessageQueue::NativeMessageQueue() : mInCallback(<span class="literal">false</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</div><div class="line">    mLooper = Looper::getForThread();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</div><div class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</div><div class="line">        Looper::setForThread(mLooper);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</div><div class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</div><div class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</div><div class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    nativeMessageQueue-&gt;incStrong(env);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jint&gt;(nativeMessageQueue);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> JNINativeMethod gMessageQueueMethods[] = &#123;</div><div class="line">    <span class="comment">/* name, signature, funcPtr */</span></div><div class="line">    &#123; <span class="string">"nativeInit"</span>, <span class="string">"()I"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeInit &#125;,</div><div class="line">    &#123; <span class="string">"nativeDestroy"</span>, <span class="string">"(I)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeDestroy &#125;,</div><div class="line">    &#123; <span class="string">"nativePollOnce"</span>, <span class="string">"(II)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativePollOnce &#125;,</div><div class="line">    &#123; <span class="string">"nativeWake"</span>, <span class="string">"(I)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeWake &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看到，nativeInit()所做的事情，就是创建一个NativeMessageQueue对象，在NativeMessageQueue的构造函数中，会来创建一个Looper对象。与Java层的Looper对象类似，native层的这种Looper对象也是保存在线程局部存储变量中的，每个线程一个。接着我们来看Looper类的构造函数和Looper::getForThread()函数，来了解一下，native层的线程局部存储API的用法(Looper类的实现在frameworks/native/libs/utils/Looper.cpp)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Hint for number of file descriptors to be associated with the epoll instance.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> EPOLL_SIZE_HINT = <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="comment">// Maximum number of file descriptors for which to retrieve poll events each iteration.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> EPOLL_MAX_EVENTS = <span class="number">16</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> gTLSOnce = PTHREAD_ONCE_INIT;</div><div class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> gTLSKey = <span class="number">0</span>;</div><div class="line"></div><div class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</div><div class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</div><div class="line">        mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX) &#123;</div><div class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> result = pipe(wakeFds);</div><div class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</div><div class="line"></div><div class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</div><div class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</div><div class="line"></div><div class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</div><div class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</div><div class="line">            errno);</div><div class="line"></div><div class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</div><div class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</div><div class="line">            errno);</div><div class="line"></div><div class="line">    <span class="comment">// Allocate the epoll instance and register the wake pipe.</span></div><div class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</div><div class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> epoll_event eventItem;</div><div class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></div><div class="line">    eventItem.events = EPOLLIN;</div><div class="line">    eventItem.data.fd = mWakeReadPipeFd;</div><div class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);</div><div class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,</div><div class="line">            errno);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Looper::initTLSKey() &#123;</div><div class="line">    <span class="keyword">int</span> result = pthread_key_create(&amp; gTLSKey, threadDestructor);</div><div class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not allocate TLS key."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Looper::threadDestructor(<span class="keyword">void</span> *st) &#123;</div><div class="line">    Looper* <span class="keyword">const</span> self = <span class="keyword">static_cast</span>&lt;Looper*&gt;(st);</div><div class="line">    <span class="keyword">if</span> (self != <span class="literal">NULL</span>) &#123;</div><div class="line">        self-&gt;decStrong((<span class="keyword">void</span>*)threadDestructor);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Looper::setForThread(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) &#123;</div><div class="line">    sp&lt;Looper&gt; old = getForThread(); <span class="comment">// also has side-effect of initializing TLS</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (looper != <span class="literal">NULL</span>) &#123;</div><div class="line">        looper-&gt;incStrong((<span class="keyword">void</span>*)threadDestructor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pthread_setspecific(gTLSKey, looper.get());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (old != <span class="literal">NULL</span>) &#123;</div><div class="line">        old-&gt;decStrong((<span class="keyword">void</span>*)threadDestructor);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">sp&lt;Looper&gt; Looper::getForThread() &#123;</div><div class="line">    <span class="keyword">int</span> result = pthread_once(&amp; gTLSOnce, initTLSKey);</div><div class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"pthread_once failed"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (Looper*)pthread_getspecific(gTLSKey);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于pthread库提供的线程局部存储API的用法，可以看到，每个线程局部存储对象，都需要一个key，通过pthread_key_create()函数创建，随后各个线程就可以通过这个key并借助于pthread_setspecific()和pthread_getspecific()函数来保存或者获取相应的线程局部存储的变量了。再来看Looper的构造函数。它创建了一个pipe，两个文件描述符。然后设置管道的两个文件描述属性为非阻塞I/O。接着是创建并设置epoll实例。由此我们了解到，android的消息队列是通过epoll机制来实现其Sleep-Wakeup机制的。</p>
<h2 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h2><p>然后来看当其他线程向Looper线程的MessageQueue中插入了消息时，Looper线程是如何被叫醒的。回忆我们前面看到的MessageQueue类的enqueueMessage()方法，它在最后插入消息之后，有调用一个nativeWake()方法。没错，正是这个nativeWake()方法执行了叫醒Looper线程的动作。那它又是如何叫醒Looper线程的呢？来看它的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jint ptr)</span> </span>&#123;</div><div class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</div><div class="line">    <span class="keyword">return</span> nativeMessageQueue-&gt;wake();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ----------------------------------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> JNINativeMethod gMessageQueueMethods[] = &#123;</div><div class="line">    <span class="comment">/* name, signature, funcPtr */</span></div><div class="line">    &#123; <span class="string">"nativeInit"</span>, <span class="string">"()I"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeInit &#125;,</div><div class="line">    &#123; <span class="string">"nativeDestroy"</span>, <span class="string">"(I)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeDestroy &#125;,</div><div class="line">    &#123; <span class="string">"nativePollOnce"</span>, <span class="string">"(II)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativePollOnce &#125;,</div><div class="line">    &#123; <span class="string">"nativeWake"</span>, <span class="string">"(I)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeWake &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>它只是调用了native层的Looper对象的wake()函数。接着再来看native Looper的wake()函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Looper::wake() &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></div><div class="line">    ALOGD(<span class="string">"%p ~ wake"</span>, <span class="keyword">this</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">ssize_t</span> nWrite;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        nWrite = write(mWakeWritePipeFd, <span class="string">"W"</span>, <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (nWrite != <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</div><div class="line">            ALOGW(<span class="string">"Could not write wake signal, errno=%d"</span>, errno);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它所做的事情，就是向管道的用于写的那个文件中写入一个“W”字符。</p>
<h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2><p>Looper线程休眠的过程。我们知道，Looper线程在Looper.loop()方法中，不断地从MessageQueue中取出消息，然后处理，如此循环往复，永不止息。不难想象，休眠的时机应该是在取出消息的时候。Looper.loop()通过MessageQueue.next()从消息队列中取出消息。来看MessageQueue.next()方法：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">    Message <span class="keyword">next</span>() &#123;</div><div class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125;</div><div class="line">            nativePollOnce(mPtr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                Message prevMsg = <span class="keyword">null</span>;</div><div class="line">                Message msg = mMessages;</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        prevMsg = msg;</div><div class="line">                        msg = msg.<span class="keyword">next</span>;</div><div class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// Got a message.</span></div><div class="line">                        mBlocked = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                            prevMsg.<span class="keyword">next</span> = msg.<span class="keyword">next</span>;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            mMessages = msg.<span class="keyword">next</span>;</div><div class="line">                        &#125;</div><div class="line">                        msg.<span class="keyword">next</span> = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                        msg.markInUse();</div><div class="line">                        <span class="keyword">return</span> msg;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// No more messages.</span></div><div class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></div><div class="line">                <span class="keyword">if</span> (mQuiting) &#123;</div><div class="line">                    dispose();</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></div><div class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></div><div class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></div><div class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                    pendingIdleHandlerCount = mIdleHandlers.<span class="keyword">size</span>();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></div><div class="line">                    mBlocked = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">                &#125;</div><div class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Run the idle handlers.</span></div><div class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line"></div><div class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    keep = idler.queueIdle();</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                    Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!keep) &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                        mIdleHandlers.remove(idler);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>值得注意的是上面那个对于nativePollOnce()的调用。wait机制的实现正在于此。来看这个方法的实现，在native的JNI code里面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MessageQueue : <span class="keyword">public</span> RefBase &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/* Gets the message queue's looper. */</span></div><div class="line">    <span class="keyword">inline</span> sp&lt;Looper&gt; getLooper() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> mLooper;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Checks whether the JNI environment has a pending exception.</span></div><div class="line">     *</div><div class="line">     * If an exception occurred, logs it together with the specified message,</div><div class="line">     * and calls raiseException() to ensure the exception will be raised when</div><div class="line">     * the callback returns, clears the pending exception from the environment,</div><div class="line">     * then returns true.</div><div class="line">     *</div><div class="line">     * If no exception occurred, returns false.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">raiseAndClearException</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Raises an exception from within a callback function.</span></div><div class="line">     * The exception will be rethrown when control returns to the message queue which</div><div class="line">     * will typically cause the application to crash.</div><div class="line">     *</div><div class="line">     * This message can only be called from within a callback function.  If it is called</div><div class="line">     * at any other time, the process will simply be killed.</div><div class="line">     *</div><div class="line">     * Does nothing if exception is NULL.</div><div class="line">     *</div><div class="line">     * (This method does not take ownership of the exception object reference.</div><div class="line">     * The caller is responsible for releasing its reference when it is done.)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">raiseException</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* msg, jthrowable exceptionObj)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    MessageQueue();</div><div class="line">    <span class="keyword">virtual</span> ~MessageQueue();</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    sp&lt;Looper&gt; mLooper;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> NativeMessageQueue : <span class="keyword">public</span> MessageQueue &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    NativeMessageQueue();</div><div class="line">    <span class="keyword">virtual</span> ~NativeMessageQueue();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">raiseException</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* msg, jthrowable exceptionObj)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pollOnce</span><span class="params">(JNIEnv* env, <span class="keyword">int</span> timeoutMillis)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wake</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">bool</span> mInCallback;</div><div class="line">    jthrowable mExceptionObj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, <span class="keyword">int</span> timeoutMillis) &#123;</div><div class="line">    mInCallback = <span class="literal">true</span>;</div><div class="line">    mLooper-&gt;pollOnce(timeoutMillis);</div><div class="line">    mInCallback = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</div><div class="line">        env-&gt;Throw(mExceptionObj);</div><div class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</div><div class="line">        mExceptionObj = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></div><div class="line">        jint ptr, jint timeoutMillis) &#123;</div><div class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</div><div class="line">    nativeMessageQueue-&gt;pollOnce(env, timeoutMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续追Looper::pollOnce()的实现(在frameworks/native/libs/utils/Looper.cpp)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.size()) &#123;</div><div class="line">            <span class="keyword">const</span> Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class="line">            <span class="keyword">int</span> ident = response.request.ident;</div><div class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> fd = response.request.fd;</div><div class="line">                <span class="keyword">int</span> events = response.events;</div><div class="line">                <span class="keyword">void</span>* data = response.request.data;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></div><div class="line">                ALOGD(<span class="string">"%p ~ pollOnce - returning signalled identifier %d: "</span></div><div class="line">                        <span class="string">"fd=%d, events=0x%x, data=%p"</span>,</div><div class="line">                        <span class="keyword">this</span>, ident, fd, events, data);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">                <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = fd;</div><div class="line">                <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = events;</div><div class="line">                <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = data;</div><div class="line">                <span class="keyword">return</span> ident;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></div><div class="line">            ALOGD(<span class="string">"%p ~ pollOnce - returning result %d"</span>, <span class="keyword">this</span>, result);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">            <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        result = pollInner(timeoutMillis);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></div><div class="line">    ALOGD(<span class="string">"%p ~ pollOnce - waiting: timeoutMillis=%d"</span>, <span class="keyword">this</span>, timeoutMillis);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="comment">// Adjust the timeout based on when the next message is due.</span></div><div class="line">    <span class="keyword">if</span> (timeoutMillis != <span class="number">0</span> &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</div><div class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class="line">        <span class="keyword">int</span> messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);</div><div class="line">        <span class="keyword">if</span> (messageTimeoutMillis &gt;= <span class="number">0</span></div><div class="line">                &amp;&amp; (timeoutMillis &lt; <span class="number">0</span> || messageTimeoutMillis &lt; timeoutMillis)) &#123;</div><div class="line">            timeoutMillis = messageTimeoutMillis;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></div><div class="line">        ALOGD(<span class="string">"%p ~ pollOnce - next message in %lldns, adjusted timeout: timeoutMillis=%d"</span>,</div><div class="line">                <span class="keyword">this</span>, mNextMessageUptime - now, timeoutMillis);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Poll.</span></div><div class="line">    <span class="keyword">int</span> result = ALOOPER_POLL_WAKE;</div><div class="line">    mResponses.clear();</div><div class="line">    mResponseIndex = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> epoll_event eventItems[EPOLL_MAX_EVENTS];</div><div class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</div><div class="line"></div><div class="line">    <span class="comment">// Acquire lock.</span></div><div class="line">    mLock.lock();</div><div class="line"></div><div class="line">    <span class="comment">// Check for poll error.</span></div><div class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</div><div class="line">            <span class="keyword">goto</span> Done;</div><div class="line">        &#125;</div><div class="line">        ALOGW(<span class="string">"Poll failed with an unexpected error, errno=%d"</span>, errno);</div><div class="line">        result = ALOOPER_POLL_ERROR;</div><div class="line">        <span class="keyword">goto</span> Done;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Check for poll timeout.</span></div><div class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></div><div class="line">        ALOGD(<span class="string">"%p ~ pollOnce - timeout"</span>, <span class="keyword">this</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        result = ALOOPER_POLL_TIMEOUT;</div><div class="line">        <span class="keyword">goto</span> Done;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Handle all events.</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></div><div class="line">    ALOGD(<span class="string">"%p ~ pollOnce - handling events from %d fds"</span>, <span class="keyword">this</span>, eventCount);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</div><div class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</div><div class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</div><div class="line">        <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;</div><div class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</div><div class="line">                awoken();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</div><div class="line">            <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> events = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT;</div><div class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;</div><div class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR;</div><div class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;</div><div class="line">                pushResponse(events, mRequests.valueAt(requestIndex));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on fd %d that is "</span></div><div class="line">                        <span class="string">"no longer registered."</span>, epollEvents, fd);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">Done: ;</div><div class="line"></div><div class="line">    <span class="comment">// Invoke pending message callbacks.</span></div><div class="line">    mNextMessageUptime = LLONG_MAX;</div><div class="line">    <span class="keyword">while</span> (mMessageEnvelopes.size() != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class="line">        <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</div><div class="line">            <span class="comment">// Remove the envelope from the list.</span></div><div class="line">            <span class="comment">// We keep a strong reference to the handler until the call to handleMessage</span></div><div class="line">            <span class="comment">// finishes.  Then we drop it so that the handler can be deleted *before*</span></div><div class="line">            <span class="comment">// we reacquire our lock.</span></div><div class="line">            &#123; <span class="comment">// obtain handler</span></div><div class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</div><div class="line">                Message message = messageEnvelope.message;</div><div class="line">                mMessageEnvelopes.removeAt(<span class="number">0</span>);</div><div class="line">                mSendingMessage = <span class="literal">true</span>;</div><div class="line">                mLock.unlock();</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span></div><div class="line">                ALOGD(<span class="string">"%p ~ pollOnce - sending message: handler=%p, what=%d"</span>,</div><div class="line">                        <span class="keyword">this</span>, handler.get(), message.what);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">                handler-&gt;handleMessage(message);</div><div class="line">            &#125; <span class="comment">// release handler</span></div><div class="line"></div><div class="line">            mLock.lock();</div><div class="line">            mSendingMessage = <span class="literal">false</span>;</div><div class="line">            result = ALOOPER_POLL_CALLBACK;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// The last message left at the head of the queue determines the next wakeup time.</span></div><div class="line">            mNextMessageUptime = messageEnvelope.uptime;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Release lock.</span></div><div class="line">    mLock.unlock();</div><div class="line"></div><div class="line">    <span class="comment">// Invoke all response callbacks.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.size(); i++) &#123;</div><div class="line">        Response&amp; response = mResponses.editItemAt(i);</div><div class="line">        <span class="keyword">if</span> (response.request.ident == ALOOPER_POLL_CALLBACK) &#123;</div><div class="line">            <span class="keyword">int</span> fd = response.request.fd;</div><div class="line">            <span class="keyword">int</span> events = response.events;</div><div class="line">            <span class="keyword">void</span>* data = response.request.data;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS</span></div><div class="line">            ALOGD(<span class="string">"%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p"</span>,</div><div class="line">                    <span class="keyword">this</span>, response.request.callback.get(), fd, events, data);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">            <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</div><div class="line">            <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</div><div class="line">                removeFd(fd);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// Clear the callback reference in the response structure promptly because we</span></div><div class="line">            <span class="comment">// will not clear the response vector itself until the next poll.</span></div><div class="line">            response.request.callback.clear();</div><div class="line">            result = ALOOPER_POLL_CALLBACK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它通过调用epoll_wait()函数来等待消息的到来。</p>
<h1 id="HandlerThread的退出"><a href="#HandlerThread的退出" class="headerlink" title="HandlerThread的退出"></a>HandlerThread的退出</h1><p>HandlerThread或使用Looper/MessageQueue自定义的类似东西，必须在不需要时被停掉。如前所见，每次创建MessageQueue，都会占用好几个描述符，但在Linux/Android上，一个进程所能打开的文件描述符的最大个数是有限制的，大多为1024个。如果一个app打开的文件描述符达到了这个上限，则将会出现许多各式各样的古怪问题，像进程间通信，socket，输入系统等很多机制，都会依赖于类文件的东西。同时，HandlerThread也总会占用一个线程。这些资源都是只有在显式地停掉之后才会被释放的。</p>
<p>我们来看一下HandlerThread的退出机制。先来看一个使用了HandlerThread，并适时地退出的例子，代码在frameworks/base/core/java/android/app/IntentService.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></div><div class="line">        <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></div><div class="line">        <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></div><div class="line"></div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">        thread.start();</div><div class="line"></div><div class="line">        mServiceLooper = thread.getLooper();</div><div class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        Message msg = mServiceHandler.obtainMessage();</div><div class="line">        msg.arg1 = startId;</div><div class="line">        msg.obj = intent;</div><div class="line">        mServiceHandler.sendMessage(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * You should not override this method for your IntentService. Instead,</div><div class="line">     * override &#123;<span class="doctag">@link</span> #onHandleIntent&#125;, which the system calls when the IntentService</div><div class="line">     * receives a start request.</div><div class="line">     * <span class="doctag">@see</span> android.app.Service#onStartCommand</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        onStart(intent, startId);</div><div class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        mServiceLooper.quit();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，Service的onCreate()方法创建了HandlerThread，保存了HandlerThread的Looper，然后在Service的onDestroy()方法中停掉了Looper，实际上也即是退出了HandlerThread。</p>
<p>来看一下Looper停止方法具体的实现：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">    /**</div><div class="line">     * Quits <span class="keyword">the</span> looper.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Causes <span class="keyword">the</span> &#123;@link <span class="comment">#loop&#125; method to terminate without processing any</span></div><div class="line">     * more messages <span class="keyword">in</span> <span class="keyword">the</span> message queue.</div><div class="line">     * &lt;/p&gt;&lt;p&gt;</div><div class="line">     * Any attempt <span class="keyword">to</span> post messages <span class="keyword">to</span> <span class="keyword">the</span> queue <span class="keyword">after</span> <span class="keyword">the</span> looper <span class="keyword">is</span> asked <span class="keyword">to</span> quit will fail.</div><div class="line">     * For example, <span class="keyword">the</span> &#123;@link Handler<span class="comment">#sendMessage(Message)&#125; method will return false.</span></div><div class="line">     * &lt;/p&gt;&lt;p <span class="built_in">class</span>=<span class="string">"note"</span>&gt;</div><div class="line">     * Using this method may be unsafe because <span class="keyword">some</span> messages may <span class="keyword">not</span> be delivered</div><div class="line">     * <span class="keyword">before</span> <span class="keyword">the</span> looper terminates.  Consider using &#123;@link <span class="comment">#quitSafely&#125; instead to ensure</span></div><div class="line">     * <span class="keyword">that</span> all pending work <span class="keyword">is</span> completed <span class="keyword">in</span> an orderly manner.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @see <span class="comment">#quitSafely</span></div><div class="line">     */</div><div class="line">    public void quit() &#123;</div><div class="line">        mQueue.quit(<span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Quits <span class="keyword">the</span> looper safely.</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Causes <span class="keyword">the</span> &#123;@link <span class="comment">#loop&#125; method to terminate as soon as all remaining messages</span></div><div class="line">     * <span class="keyword">in</span> <span class="keyword">the</span> message queue <span class="keyword">that</span> are already due <span class="keyword">to</span> be delivered have been handled.</div><div class="line">     * However pending delayed messages <span class="keyword">with</span> due <span class="keyword">times</span> <span class="keyword">in</span> <span class="keyword">the</span> future will <span class="keyword">not</span> be</div><div class="line">     * delivered <span class="keyword">before</span> <span class="keyword">the</span> loop terminates.</div><div class="line">     * &lt;/p&gt;&lt;p&gt;</div><div class="line">     * Any attempt <span class="keyword">to</span> post messages <span class="keyword">to</span> <span class="keyword">the</span> queue <span class="keyword">after</span> <span class="keyword">the</span> looper <span class="keyword">is</span> asked <span class="keyword">to</span> quit will fail.</div><div class="line">     * For example, <span class="keyword">the</span> &#123;@link Handler<span class="comment">#sendMessage(Message)&#125; method will return false.</span></div><div class="line">     * &lt;/p&gt;</div><div class="line">     */</div><div class="line">    public void quitSafely() &#123;</div><div class="line">        mQueue.quit(<span class="literal">true</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Looper有提供两个退出方法，quit()和quitSafely()，这两个方法都会阻止再向消息队列中发送消息。但它们的主要区别在于，前者不会再处理消息队列中还没有被处理的所有消息，而后者则会在处理完那些已经到期的消息之后才真的退出。</p>
<p>由前面我们对Looper.loop()方法的分析，也不难理解，MessageQueue退出即Looper退出。此处也是直接调用了MessageQueue.quit()方法。那我们就来看一下MessageQueue的quit()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread not allowed to quit."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            mQuitting = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (safe) &#123;</div><div class="line">                removeAllFutureMessagesLocked();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                removeAllMessagesLocked();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>主要做了几个事情：</p>
<ul>
<li>第一，设置标记mQuitting为true，以表明HandlerThread要退出了；</li>
<li>第二，根据传入的参数safe，删除队列里面适当类型的消息；</li>
<li>第三，调用nativeWake(mPtr)，将HandlerThread线程唤醒。</li>
</ul>
<p>我们都知道，Java里面是没有办法直接终止另外一个线程的，同时强制中止一个线程也是很不安全的，所以，这里也是只设置一个标记，然后在MessageQueue.next()中获取消息时检查此标记，以在适当的时候退出。MessageQueue.next()里中止消息处理循环的，主要是下面这几行：<br> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></div><div class="line">                <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                    dispose();</div><div class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p>
<p>然后在 MessageQueue.dispose()方法中完成最终的退出，及资源清理的工作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mPtr != <span class="number">0</span>) &#123;</div><div class="line">            nativeDestroy(mPtr);</div><div class="line">            mPtr = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>android中消息队列机制，大体如此。</p>
<p>Done。</p>
</div><div class="tags"><a href="/tags/Android开发/">Android开发</a></div><div class="post-nav"><a href="/2015/07/04/Android_app_native代码性能分析/" class="pre">Android app native代码性能分析</a><a href="/2013/07/13/dlopen_and_dlsym/" class="next">android下运行时动态链接dlopen()和dlsym()的实现</a></div><div id="disqus_thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-图形系统/">Android 图形系统</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发/">Android开发</a><span class="category-list-count">26</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-开发/">C/C++开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java开发/">Java开发</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核/">Linux内核</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/live555/">live555</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/业界趣闻/">业界趣闻</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台开发/">后台开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络调试/">网络调试</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随想杂谈/">随想杂谈</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频开发/">音视频开发</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/Android开发/" style="font-size: 15px;">Android开发</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/chromium/" style="font-size: 15px;">chromium</a> <a href="/tags/后台开发/" style="font-size: 15px;">后台开发</a> <a href="/tags/Java开发/" style="font-size: 15px;">Java开发</a> <a href="/tags/QUIC/" style="font-size: 15px;">QUIC</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/网络调试/" style="font-size: 15px;">网络调试</a> <a href="/tags/HTTP2/" style="font-size: 15px;">HTTP2</a> <a href="/tags/UDT/" style="font-size: 15px;">UDT</a> <a href="/tags/图形图像/" style="font-size: 15px;">图形图像</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/C-C-开发/" style="font-size: 15px;">C/C++开发</a> <a href="/tags/音视频开发/" style="font-size: 15px;">音视频开发</a> <a href="/tags/Linux内核/" style="font-size: 15px;">Linux内核</a> <a href="/tags/live555/" style="font-size: 15px;">live555</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/Go-语言/" style="font-size: 15px;">Go 语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">二月 2013</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/12/android_debug_gdb/">使用 GDB 调试 Android 应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/11/android_emulator_dev/">Android 模拟器下载、编译及调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/live555_src_analysis_start_streaming/">live555 源码分析：播放启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/live555_src_analysis_subsession_setup/">live555 源码分析：子会话 SETUP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/07/live555_src_analysis_subsession_sdp/">live555 源码分析：子会话 SDP 行生成</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/07/live555_src_analysis_servermediasession/">live555 源码分析：ServerMediaSession</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/live555_src_analysis_rtspserver_arch/">live555 源码分析：RTSPServer 组件结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/live555_src_analysis_play/">live555 源码分析： PLAY 的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/live555_src_analysis_setup/">live555 源码分析： SETUP 的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/live555_src_analysis_describe/">live555 源码分析： DESCRIBE 的处理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="https://source.android.com/" title="Android Open Source Project" target="_blank">Android Open Source Project</a><ul></ul><a href="http://www.vants.org/" title="蚂蚁网" target="_blank">蚂蚁网</a></div><div class="widget"><div class="widget-title"><i class="fa fa-commt"> 最近评论</i></div><script type="text/javascript" src="//wolfcstech.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.2.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:hanpfei@gmail.com" target="_blank" class="fa fa-email"> </a><a href="undefined" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/hanpfei" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">Han Pengfei</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var disqus_shortname = 'wolfcstech';
var disqus_identifier = '2013/09/11/messagequeue_in_android/';
var disqus_title = 'android的消息队列机制';
var disqus_url = 'https://www.wolfcstech.com/2013/09/11/messagequeue_in_android/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wolfcstech.disqus.com/count.js" async></script><script type="text/javascript" src="/js/search.json.js?v=1.2.0"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3c736b12c32c019fd9ff6c825b6b9b44";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></body></html>