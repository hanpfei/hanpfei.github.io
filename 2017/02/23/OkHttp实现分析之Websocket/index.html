<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/freesoft.jpg?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/freesoft.jpg?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/freesoft.jpg?v=6.0.3">


  <link rel="mask-icon" href="/images/freesoft.jpg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="网络协议,Android开发,源码分析," />


<meta name="description" content="HTML5 拥有许多引人注目的新特性，WebSocket就是其中之一。WebSocket一向有着 “Web 的 TCP ”之称。通常 WebSocket 都是用于Web的，用于构建实时的 Web 应用。它可以在浏览器和服务器之间提供一个基于 TCP 连接的双向通道。">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp实现分析之Websocket">
<meta property="og:url" content="https://www.wolfcstech.com/2017/02/23/OkHttp实现分析之Websocket/index.html">
<meta property="og:site_name" content="WolfcsTech">
<meta property="og:description" content="HTML5 拥有许多引人注目的新特性，WebSocket就是其中之一。WebSocket一向有着 “Web 的 TCP ”之称。通常 WebSocket 都是用于Web的，用于构建实时的 Web 应用。它可以在浏览器和服务器之间提供一个基于 TCP 连接的双向通道。">
<meta property="og:image" content="https://www.wolfcstech.com/images/1315506-8f154678806eaf05.png">
<meta property="og:updated_time" content="2017-02-23T10:37:35.160Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OkHttp实现分析之Websocket">
<meta name="twitter:description" content="HTML5 拥有许多引人注目的新特性，WebSocket就是其中之一。WebSocket一向有着 “Web 的 TCP ”之称。通常 WebSocket 都是用于Web的，用于构建实时的 Web 应用。它可以在浏览器和服务器之间提供一个基于 TCP 连接的双向通道。">
<meta name="twitter:image" content="https://www.wolfcstech.com/images/1315506-8f154678806eaf05.png">






  <link rel="canonical" href="https://www.wolfcstech.com/2017/02/23/OkHttp实现分析之Websocket/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>OkHttp实现分析之Websocket | WolfcsTech</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-109419024-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-109419024-1');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3c736b12c32c019fd9ff6c825b6b9b44";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WolfcsTech</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="http://www.ixirong.com/404.html" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />Commonweal 404</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.wolfcstech.com/2017/02/23/OkHttp实现分析之Websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han Pengfei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/freesoft.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WolfcsTech">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OkHttp实现分析之Websocket</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-23T16:43:49+08:00">2017-02-23</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络协议/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/23/OkHttp实现分析之Websocket/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2017/02/23/OkHttp实现分析之Websocket/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/02/23/OkHttp实现分析之Websocket/" class="leancloud_visitors" data-flag-title="OkHttp实现分析之Websocket">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>HTML5 拥有许多引人注目的新特性，WebSocket就是其中之一。WebSocket一向有着 “Web 的 TCP ”之称。通常 WebSocket 都是用于Web的，用于构建实时的 Web 应用。它可以在浏览器和服务器之间提供一个基于 TCP 连接的双向通道。<br><a id="more"></a><br>WebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息 ”Upgrade: WebSocket” 表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>
<p>Websocket同样可以用于移动端。尽管移动端 Android/iOS 的本地应用可以直接通过Socket与服务器建立连接，并定义自己的协议来解决 Web 中实时应用创建困难的问题，但 WebSocket 服务通常复用Web的 80 端口，且可以比较方便的基于Web服务器来实现，因而对于某些端口容易被封的网络环境而言，WebSocket 就变得非常有意义。</p>
<p>OkHttp 是在 2016 年 6 月 10 日发布的 3.4.1 版中添加的对WebSocket的支持的。本文通过分析 OkHttp-3.5.0 的 WebSocket 实现来学习一下这个协议。</p>
<h1 id="OkHttp-WebSocket客户端-API-用法"><a href="#OkHttp-WebSocket客户端-API-用法" class="headerlink" title="OkHttp WebSocket客户端 API 用法"></a>OkHttp WebSocket客户端 API 用法</h1><p>在开始分析 WebSocket 的实现之前，我们先来看一下 OkHttp 的 WebSocket API怎么用。示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> android.util.Log;</div><div class="line"></div><div class="line"><span class="keyword">import</span> okhttp3.OkHttpClient;</div><div class="line"><span class="keyword">import</span> okhttp3.Request;</div><div class="line"><span class="keyword">import</span> okhttp3.Response;</div><div class="line"><span class="keyword">import</span> okhttp3.WebSocket;</div><div class="line"><span class="keyword">import</span> okhttp3.WebSocketListener;</div><div class="line"><span class="keyword">import</span> okio.ByteString;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketClient</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL_CLOSURE_STATUS = <span class="number">1000</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient sClient;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WebSocket sWebSocket;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sClient == <span class="keyword">null</span>) &#123;</div><div class="line">            sClient = <span class="keyword">new</span> OkHttpClient();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sWebSocket == <span class="keyword">null</span>) &#123;</div><div class="line">            Request request = <span class="keyword">new</span> Request.Builder().url(<span class="string">"ws://echo.websocket.org"</span>).build();</div><div class="line"></div><div class="line">            EchoWebSocketListener listener = <span class="keyword">new</span> EchoWebSocketListener();</div><div class="line">            sWebSocket = sClient.newWebSocket(request, listener);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(WebSocket webSocket)</span> </span>&#123;</div><div class="line">        webSocket.send(<span class="string">"Knock, knock!"</span>);</div><div class="line">        webSocket.send(<span class="string">"Hello!"</span>);</div><div class="line">        webSocket.send(ByteString.decodeHex(<span class="string">"deadbeef"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">        WebSocket webSocket;</div><div class="line">        <span class="keyword">synchronized</span> (WebsocketClient.class) &#123;</div><div class="line">            webSocket = sWebSocket;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (webSocket != <span class="keyword">null</span>) &#123;</div><div class="line">            sendMessage(webSocket);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">closeWebSocket</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sWebSocket != <span class="keyword">null</span>) &#123;</div><div class="line">            sWebSocket.close(NORMAL_CLOSURE_STATUS, <span class="string">"Goodbye!"</span>);</div><div class="line">            sWebSocket = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sClient != <span class="keyword">null</span>) &#123;</div><div class="line">            sClient.dispatcher().executorService().shutdown();</div><div class="line">            sClient = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resetWebSocket</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (WebsocketClient.class) &#123;</div><div class="line">            sWebSocket = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoWebSocketListener</span> <span class="keyword">extends</span> <span class="title">WebSocketListener</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"EchoWebSocketListener"</span>;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(WebSocket webSocket, Response response)</span> </span>&#123;</div><div class="line">            sendMessage(webSocket);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(WebSocket webSocket, String text)</span> </span>&#123;</div><div class="line">            Log.i(TAG, <span class="string">"Receiving: "</span> + text);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(WebSocket webSocket, ByteString bytes)</span> </span>&#123;</div><div class="line">            Log.i(TAG, <span class="string">"Receiving: "</span> + bytes.hex());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosing</span><span class="params">(WebSocket webSocket, <span class="keyword">int</span> code, String reason)</span> </span>&#123;</div><div class="line">            webSocket.close(NORMAL_CLOSURE_STATUS, <span class="keyword">null</span>);</div><div class="line">            Log.i(TAG, <span class="string">"Closing: "</span> + code + <span class="string">" "</span> + reason);</div><div class="line">            resetWebSocket();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosed</span><span class="params">(WebSocket webSocket, <span class="keyword">int</span> code, String reason)</span> </span>&#123;</div><div class="line">            Log.i(TAG, <span class="string">"Closed: "</span> + code + <span class="string">" "</span> + reason);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(WebSocket webSocket, Throwable t, Response response)</span> </span>&#123;</div><div class="line">            t.printStackTrace();</div><div class="line">            resetWebSocket();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个过程与发送HTTP请求的过程有许多相似之处，它们都需要创建 OkHttpClient 和Request。然而它们不同的地方更多：</p>
<ol>
<li>WebSocket 请求通过 WebSocketListener 来接收连接的状态和活动，而HTTP请求则通过 Callback。同时请求的 URL 的 scheme 是 “ws” 或者是  “wss” (TLS 之上的 WebSocket)，而不是HTTP的 “http” 和 “https”。</li>
<li>HTTP 请求的连接建立及执行需要基于 Request 和回调创建Call，并调用 Call 的方法手动进行；而对于 WebSocket 请求，则在基于 Request 和回调创建 WebSocket 的时候，OkHttp 会自动发起连接建立的过程。</li>
<li>这也是 WebSocket 与 HTTP 最大的不同。对于 WebSocket，我们可以保存 WebSocket 对象，并在后续多次通过该对象向服务器发送数据。</li>
<li>通过回调可以获得更多 WebSocket 的状态变化。在连接建立、收到服务器发送回来的消息、服务器要关闭连接，以及出现 error 时，都能得到通知。不像 HTTP 请求那样，只在最后得到一个请求成功或者失败的结果。</li>
</ol>
<p>后两点正是 WebSocket 全双工连接的体现。</p>
<h1 id="OkHttp-的-WebSocket-实现"><a href="#OkHttp-的-WebSocket-实现" class="headerlink" title="OkHttp 的 WebSocket 实现"></a>OkHttp 的 WebSocket 实现</h1><p>接着我们来看OkHttp 的 WebSocket 实现。WebSocket 包含两个部分，分别是握手和数据传输，数据传输又包括数据的发送，数据的接收，连接的保活，以及连接的关闭等，我们将分别分析这些过程。</p>
<h1 id="连接握手"><a href="#连接握手" class="headerlink" title="连接握手"></a>连接握手</h1><p>创建 WebSocket 的过程如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Call</span>.<span class="title">Factory</span>, <span class="title">WebSocket</span>.<span class="title">Factory</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> WebSocket <span class="title">newWebSocket</span><span class="params">(Request request, WebSocketListener listener)</span> </span>&#123;</div><div class="line">    RealWebSocket webSocket = <span class="keyword">new</span> RealWebSocket(request, listener, <span class="keyword">new</span> SecureRandom());</div><div class="line">    webSocket.connect(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> webSocket;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在这里会创建一个 <code>RealWebSocket</code> 对象，然后执行其 <code>connect()</code> 方法建立连接。 <code>RealWebSocket</code> 对象的创建过程如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealWebSocket</span><span class="params">(Request request, WebSocketListener listener, Random random)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="string">"GET"</span>.equals(request.method())) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Request must be GET: "</span> + request.method());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.originalRequest = request;</div><div class="line">    <span class="keyword">this</span>.listener = listener;</div><div class="line">    <span class="keyword">this</span>.random = random;</div><div class="line"></div><div class="line">    <span class="keyword">byte</span>[] nonce = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</div><div class="line">    random.nextBytes(nonce);</div><div class="line">    <span class="keyword">this</span>.key = ByteString.of(nonce).base64();</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.writerRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">while</span> (writeOneFrame()) &#123;</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">          failWebSocket(e, <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这里最主要的是初始化了 key，以备后续连接建立及握手之用。Key 是一个16字节长的随机数经过 Base64 编码得到的。此外还初始化了 <code>writerRunnable</code> 等。</p>
<p>连接建立及握手过程如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="keyword">public</span> <span class="keyword">void</span> connect(OkHttpClient <span class="keyword">client</span>) &#123;</div><div class="line">    <span class="keyword">client</span> = <span class="keyword">client</span>.newBuilder()</div><div class="line">        .protocols(ONLY_HTTP1)</div><div class="line">        .build();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pingIntervalMillis = <span class="keyword">client</span>.pingIntervalMillis();</div><div class="line">    <span class="keyword">final</span> Request request = originalRequest.newBuilder()</div><div class="line">        .header(<span class="string">"Upgrade"</span>, <span class="string">"websocket"</span>)</div><div class="line">        .header(<span class="string">"Connection"</span>, <span class="string">"Upgrade"</span>)</div><div class="line">        .header(<span class="string">"Sec-WebSocket-Key"</span>, key)</div><div class="line">        .header(<span class="string">"Sec-WebSocket-Version"</span>, <span class="string">"13"</span>)</div><div class="line">        .build();</div><div class="line">    call = Internal.instance.newWebSocketCall(<span class="keyword">client</span>, request);</div><div class="line">    call.enqueue(<span class="keyword">new</span> Callback() &#123;</div><div class="line">      @Override <span class="keyword">public</span> <span class="keyword">void</span> onResponse(Call call, Response response) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          checkResponse(response);</div><div class="line">        &#125; <span class="keyword">catch</span> (ProtocolException e) &#123;</div><div class="line">          failWebSocket(e, response);</div><div class="line">          closeQuietly(response);</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Promote the HTTP streams into web socket streams.</span></div><div class="line">        StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);</div><div class="line">        streamAllocation.noNewStreams(); <span class="comment">// Prevent connection pooling!</span></div><div class="line">        Streams streams = streamAllocation.connection().newWebSocketStreams(streamAllocation);</div><div class="line"></div><div class="line">        <span class="comment">// Process all web socket messages.</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          listener.onOpen(RealWebSocket.<span class="keyword">this</span>, response);</div><div class="line">          String name = <span class="string">"OkHttp WebSocket "</span> + request.url().redact();</div><div class="line">          initReaderAndWriter(name, pingIntervalMillis, streams);</div><div class="line">          streamAllocation.connection().socket().setSoTimeout(<span class="number">0</span>);</div><div class="line">          loopReader();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">          failWebSocket(e, <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override <span class="keyword">public</span> <span class="keyword">void</span> onFailure(Call call, IOException e) &#123;</div><div class="line">        failWebSocket(e, <span class="keyword">null</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>连接建立及握手的过程主要是向服务器发送一个HTTP请求。这个 HTTP 请求的特别之处在于，它包含了如下的一些Headers：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Upgrade:</span> WebSocket</div><div class="line"><span class="symbol">Connection:</span> Upgrade</div><div class="line"><span class="keyword">Sec</span>-WebSocket-Key: <span class="number">7</span>wgaspE0Tl7/<span class="number">66</span>o4Dov2kw==</div><div class="line"><span class="keyword">Sec</span>-WebSocket-Version: <span class="number">13</span></div></pre></td></tr></table></figure></p>
<p>其中 <code>Upgrade</code> 和 <code>Connection</code> header 向服务器表明，请求的目的就是要将客户端和服务器端的通讯协议从 HTTP 协议升级到 WebSocket 协议，同时在请求处理完成之后，连接不要断开。<code>Sec-WebSocket-Key</code> header 值正是我们前面看到的key，它是 WebSocket 客户端发送的一个 base64 编码的密文，要求服务端必须返回一个对应加密的 “Sec-WebSocket-Accept” 应答，否则客户端会抛出 “Error during WebSocket handshake” 错误，并关闭连接。</p>
<p>来自于 HTTP 服务器的响应到达的时候，即是连接建立大功告成的时候，也就是热豆腐孰了的时候。</p>
<p>然而，响应到达时，尽管连接已经建立，还要为数据的收发做一些准备。这些准备中的第一步就是检查 HTTP 响应：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">checkResponse</span><span class="params">(Response response)</span> <span class="keyword">throws</span> ProtocolException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (response.code() != <span class="number">101</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Expected HTTP 101 response but was '"</span></div><div class="line">          + response.code() + <span class="string">" "</span> + response.message() + <span class="string">"'"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String headerConnection = response.header(<span class="string">"Connection"</span>);</div><div class="line">    <span class="keyword">if</span> (!<span class="string">"Upgrade"</span>.equalsIgnoreCase(headerConnection)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Expected 'Connection' header value 'Upgrade' but was '"</span></div><div class="line">          + headerConnection + <span class="string">"'"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String headerUpgrade = response.header(<span class="string">"Upgrade"</span>);</div><div class="line">    <span class="keyword">if</span> (!<span class="string">"websocket"</span>.equalsIgnoreCase(headerUpgrade)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</div><div class="line">          <span class="string">"Expected 'Upgrade' header value 'websocket' but was '"</span> + headerUpgrade + <span class="string">"'"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String headerAccept = response.header(<span class="string">"Sec-WebSocket-Accept"</span>);</div><div class="line">    String acceptExpected = ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC)</div><div class="line">        .sha1().base64();</div><div class="line">    <span class="keyword">if</span> (!acceptExpected.equals(headerAccept)) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Expected 'Sec-WebSocket-Accept' header value '"</span></div><div class="line">          + acceptExpected + <span class="string">"' but was '"</span> + headerAccept + <span class="string">"'"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  . . . . . .</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failWebSocket</span><span class="params">(Exception e, Response response)</span> </span>&#123;</div><div class="line">    Streams streamsToClose;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (failed) <span class="keyword">return</span>; <span class="comment">// Already failed.</span></div><div class="line">      failed = <span class="keyword">true</span>;</div><div class="line">      streamsToClose = <span class="keyword">this</span>.streams;</div><div class="line">      <span class="keyword">this</span>.streams = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">if</span> (cancelFuture != <span class="keyword">null</span>) cancelFuture.cancel(<span class="keyword">false</span>);</div><div class="line">      <span class="keyword">if</span> (executor != <span class="keyword">null</span>) executor.shutdown();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      listener.onFailure(<span class="keyword">this</span>, e, response);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      closeQuietly(streamsToClose);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>根据 WebSocket 的协议，服务器端用如下响应，来表示接受建立 WebSocket 连接的请求：</p>
<ol>
<li>响应码是 101。</li>
<li>“Connection” header 的值为 “Upgrade”，以表明服务器并没有在处理完请求之后把连接个断开。</li>
<li>“Upgrade”  header 的值为 “websocket”，以表明服务器接受后面使用 WebSocket 来通信。</li>
<li>“Sec-WebSocket-Accept” header 的值为，key + WebSocketProtocol.ACCEPT_MAGIC 做 SHA1 hash，然后做 base64 编码，来做服务器接受连接的验证。关于这部分的设计的详细信息，可参考 <a href="https://tools.ietf.org/html/rfc6455#section-1.3" target="_blank" rel="external">WebSocket 协议规范</a>。</li>
</ol>
<p>为数据收发做准备的第二步是，初始化用于输入输出的 Source 和 Sink。Source 和 Sink 创建于之前发送HTTP请求的时候。这里会阻止在这个连接上再创建新的流。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span> <span class="keyword">extends</span> <span class="title">Http2Connection</span>.<span class="title">Listener</span> <span class="title">implements</span> <span class="title">Connection</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  public <span class="type">RealWebSocket</span>.<span class="type">Streams</span> newWebSocketStreams(<span class="keyword">final</span> <span class="type">StreamAllocation</span> streamAllocation) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">RealWebSocket</span>.<span class="type">Streams</span>(<span class="literal">true</span>, source, sink) &#123;</div><div class="line">      <span class="meta">@Override</span> public void close() <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</div><div class="line">        streamAllocation.streamFinished(<span class="literal">true</span>, streamAllocation.codec());</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>Streams是一个 BufferedSource 和 BufferedSink 的holder：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Streams</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="keyword">client</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> BufferedSource source;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> BufferedSink sink;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Streams(<span class="keyword">boolean</span> <span class="keyword">client</span>, BufferedSource source, BufferedSink sink) &#123;</div><div class="line">      <span class="keyword">this</span>.<span class="keyword">client</span> = <span class="keyword">client</span>;</div><div class="line">      <span class="keyword">this</span>.source = source;</div><div class="line">      <span class="keyword">this</span>.sink = sink;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>第三步是调用回调 <code>onOpen()</code>。</p>
<p>第四步是初始化 Reader 和 Writer：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initReaderAndWriter</span><span class="params">(</span></span></div><div class="line">      String name, <span class="keyword">long</span> pingIntervalMillis, Streams streams) <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.streams = streams;</div><div class="line">      <span class="keyword">this</span>.writer = <span class="keyword">new</span> WebSocketWriter(streams.client, streams.sink, random);</div><div class="line">      <span class="keyword">this</span>.executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, Util.threadFactory(name, <span class="keyword">false</span>));</div><div class="line">      <span class="keyword">if</span> (pingIntervalMillis != <span class="number">0</span>) &#123;</div><div class="line">        executor.scheduleAtFixedRate(</div><div class="line">            <span class="keyword">new</span> PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (!messageAndCloseQueue.isEmpty()) &#123;</div><div class="line">        runWriter(); <span class="comment">// Send messages that were enqueued before we were connected.</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    reader = <span class="keyword">new</span> WebSocketReader(streams.client, streams.source, <span class="keyword">this</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>OkHttp使用 <code>WebSocketReader</code> 和 <code>WebSocketWriter</code> 来处理数据的收发。在发送数据时将数据组织成帧，在接收数据时则进行反向擦做，同时处理 WebSocket 的控制消息。</p>
<p>WebSocket 的所有数据发送动作，都会在单线程线程池的线程中，通过 WebSocketWriter 执行。在这里会创建 ScheduledThreadPoolExecutor 用于跑数据的发送操作。WebSocket 协议中主要会传输两种类型的帧，一是控制帧，主要是用于连接保活的 Ping 帧等；二是用户数据载荷帧。在这里会根据用户的配置，调度 Ping 帧周期性地发送。我们在调用 WebSocket 的接口发送数据时，数据并不是同步发送的，而是被放在了一个消息队列中。发送消息的 Runnable 从消息队列中读取数据发送。这里会检查消息队列中是否有数据，如果有的话，会调度发送消息的 Runnable 执行。</p>
<p>第五步是配置socket的超时时间为0，也就是阻塞IO。</p>
<p>第六步执行 <code>loopReader()</code>。这实际上是进入了消息读取循环了，也就是数据接收的逻辑了。</p>
<h2 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h2><p>我们可以通过 WebSocket 接口的 <code>send(String text)</code> 和 <code>send(ByteString bytes)</code> 分别发送文本的和二进制格式的消息。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">send</span><span class="params">(String text)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"text == null"</span>);</div><div class="line">    <span class="keyword">return</span> send(ByteString.encodeUtf8(text), OPCODE_TEXT);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">send</span><span class="params">(ByteString bytes)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (bytes == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"bytes == null"</span>);</div><div class="line">    <span class="function"><span class="keyword">return</span> <span class="title">send</span><span class="params">(bytes, OPCODE_BINARY)</span></span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">boolean</span> <span class="title">send</span><span class="params">(ByteString data, <span class="keyword">int</span> formatOpcode)</span> </span>&#123;</div><div class="line">    <span class="comment">// Don't send new frames after we've failed or enqueued a close frame.</span></div><div class="line">    <span class="keyword">if</span> (failed || enqueuedClose) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// If this frame overflows the buffer, reject it and close the web socket.</span></div><div class="line">    <span class="keyword">if</span> (queueSize + data.size() &gt; MAX_QUEUE_SIZE) &#123;</div><div class="line">      close(CLOSE_CLIENT_GOING_AWAY, <span class="keyword">null</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Enqueue the message frame.</span></div><div class="line">    queueSize += data.size();</div><div class="line">    messageAndCloseQueue.add(<span class="keyword">new</span> Message(formatOpcode, data));</div><div class="line">    runWriter();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  . . . . . .</div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">runWriter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</div><div class="line">      executor.execute(writerRunnable);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到我们调用发送数据的接口时，做的事情主要是将数据格式化，构造消息，放进一个消息队列，然后调度 writerRunnable 执行。</p>
<p>此外，值得注意的是，当消息队列中的未发送数据超出最大大小限制，WebSocket 连接会被直接关闭。对于发送失败过或被关闭了的 WebSocket，将无法再发送信息。</p>
<p>在 <code>writerRunnable</code> 中会循环调用 <code>writeOneFrame()</code> 逐帧发送数据，直到数据发完，或发送失败。在 WebSocket 协议中，客户端需要发送 <strong><em>四种类型</em></strong> 的帧：</p>
<ol>
<li>PING 帧</li>
<li>PONG 帧</li>
<li>CLOSE 帧</li>
<li>MESSAGE 帧</li>
</ol>
<p>PING帧用于连接保活，它的发送是在 <code>PingRunnable</code> 中执行的，在初始化 Reader 和 Writer 的时候，就会根据设置调度执行或不执行。除PING 帧外的其它 <em>三种</em> 帧，都在 <code>writeOneFrame()</code> 中发送。PONG 帧是对服务器发过来的 PING 帧的响应，同样用于保活连接。后面我们在分析连接的保活时会更详细的分析 PING 和 PONG 这两种帧。CLOSE 帧用于关闭连接，稍后我们在分析连接关闭过程时再来详细地分析。</p>
<p>这里我们主要关注用户数据发送的部分。PONG 帧具有最高的发送优先级。在没有PONG 帧需要发送时，<code>writeOneFrame()</code> 从消息队列中取出一条消息，如果消息不是 CLOSE 帧，则主要通过如下的过程进行发送：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> RealWebSocket <span class="keyword">implements</span> WebSocket, WebSocketReader.FrameCallback &#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="keyword">boolean</span> writeOneFrame() <span class="keyword">throws</span> IOException &#123;</div><div class="line">    WebSocketWriter writer;</div><div class="line">    ByteString pong;</div><div class="line">    Object messageOrClose = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> receivedCloseCode = -<span class="number">1</span>;</div><div class="line">    String receivedCloseReason = <span class="keyword">null</span>;</div><div class="line">    Streams streamsToClose = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (RealWebSocket.<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (failed) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// Failed web socket.</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      writer = <span class="keyword">this</span>.writer;</div><div class="line">      pong = pongQueue.poll();</div><div class="line">      <span class="keyword">if</span> (pong == <span class="keyword">null</span>) &#123;</div><div class="line">        messageOrClose = messageAndCloseQueue.poll();</div><div class="line">  . . . . . .</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose <span class="keyword">instanceof</span> Message) &#123;</div><div class="line">        ByteString data = ((Message) messageOrClose).data;</div><div class="line">        BufferedSink sink = Okio.buffer(writer.newMessageSink(</div><div class="line">            ((Message) messageOrClose).formatOpcode, data.<span class="keyword">size</span>()));</div><div class="line">        sink.<span class="keyword">write</span>(data);</div><div class="line">        sink.close();</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">          queueSize -= data.<span class="keyword">size</span>();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose <span class="keyword">instanceof</span> Close) &#123;</div></pre></td></tr></table></figure></p>
<p>数据发送的过程可以总结如下：</p>
<ol>
<li>创建一个 BufferedSink 用于数据发送。</li>
<li>将数据写入前面创建的 BufferedSink 中。</li>
<li>关闭 BufferedSink。</li>
<li>更新 queueSize 以正确地指示未发送数据的长度。</li>
</ol>
<p>这里面的玄机主要在创建的 BufferedSink。创建的 Sink 是一个 <code>FrameSink</code>：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">toggleMask</span><span class="params">(<span class="keyword">byte</span>[] buffer, <span class="keyword">long</span> byteCount, <span class="keyword">byte</span>[] key, <span class="keyword">long</span> frameBytesRead)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> keyLength = key.length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteCount; i++, frameBytesRead++) &#123;</div><div class="line">    <span class="keyword">int</span> keyIndex = (<span class="keyword">int</span>) (frameBytesRead % keyLength);</div><div class="line">    buffer[i] = (<span class="keyword">byte</span>) (buffer[i] ^ key[keyIndex]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">. . . . . .</div><div class="line"><span class="function">Sink <span class="title">newMessageSink</span><span class="params">(<span class="keyword">int</span> formatOpcode, <span class="keyword">long</span> contentLength)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (activeWriter) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Another message writer is active. Did you call close()?"</span>);</div><div class="line">  &#125;</div><div class="line">  activeWriter = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reset FrameSink state for a new writer.</span></div><div class="line">  frameSink.formatOpcode = formatOpcode;</div><div class="line">  frameSink.contentLength = contentLength;</div><div class="line">  frameSink.isFirstFrame = <span class="keyword">true</span>;</div><div class="line">  frameSink.closed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> frameSink;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeMessageFrameSynchronized</span><span class="params">(<span class="keyword">int</span> formatOpcode, <span class="keyword">long</span> byteCount, <span class="keyword">boolean</span> isFirstFrame,</span></span></div><div class="line">    <span class="keyword">boolean</span> isFinal) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="function"><span class="keyword">assert</span> Thread.<span class="title">holdsLock</span><span class="params">(<span class="keyword">this</span>)</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (writerClosed) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"closed"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;</div><div class="line">  <span class="keyword">if</span> (isFinal) &#123;</div><div class="line">    b0 |= B0_FLAG_FIN;</div><div class="line">  &#125;</div><div class="line">  sink.writeByte(b0);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> b1 = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (isClient) &#123;</div><div class="line">    b1 |= B1_FLAG_MASK;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (byteCount &lt;= PAYLOAD_BYTE_MAX) &#123;</div><div class="line">    b1 |= (<span class="keyword">int</span>) byteCount;</div><div class="line">    sink.writeByte(b1);</div><div class="line">  &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(byteCount &lt;= PAYLOAD_SHORT_MAX)</span> </span>&#123;</div><div class="line">    b1 |= PAYLOAD_SHORT;</div><div class="line">    sink.writeByte(b1);</div><div class="line">    sink.writeShort((<span class="keyword">int</span>) byteCount);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    b1 |= PAYLOAD_LONG;</div><div class="line">    sink.writeByte(b1);</div><div class="line">    sink.writeLong(byteCount);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (isClient) &#123;</div><div class="line">    random.nextBytes(maskKey);</div><div class="line">    sink.write(maskKey);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> written = <span class="number">0</span>; written &lt; byteCount; ) &#123;</div><div class="line">      <span class="keyword">int</span> toRead = (<span class="keyword">int</span>) Math.min(byteCount, maskBuffer.length);</div><div class="line">      <span class="keyword">int</span> read = buffer.read(maskBuffer, <span class="number">0</span>, toRead);</div><div class="line">      <span class="keyword">if</span> (read == <span class="number">-1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">      toggleMask(maskBuffer, read, maskKey, written);</div><div class="line">      sink.write(maskBuffer, <span class="number">0</span>, read);</div><div class="line">      written += read;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    sink.write(buffer, byteCount);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  sink.emit();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameSink</span> <span class="keyword">implements</span> <span class="title">Sink</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> formatOpcode;</div><div class="line">  <span class="keyword">long</span> contentLength;</div><div class="line">  <span class="keyword">boolean</span> isFirstFrame;</div><div class="line">  <span class="keyword">boolean</span> closed;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(Buffer source, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"closed"</span>);</div><div class="line"></div><div class="line">    buffer.write(source, byteCount);</div><div class="line"></div><div class="line">    <span class="comment">// Determine if this is a buffered write which we can defer until close() flushes.</span></div><div class="line">    <span class="keyword">boolean</span> deferWrite = isFirstFrame</div><div class="line">        &amp;&amp; contentLength != <span class="number">-1</span></div><div class="line">        &amp;&amp; buffer.size() &gt; contentLength - <span class="number">8192</span> <span class="comment">/* segment size */</span>;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> emitCount = buffer.completeSegmentByteCount();</div><div class="line">    <span class="keyword">if</span> (emitCount &gt; <span class="number">0</span> &amp;&amp; !deferWrite) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (WebSocketWriter.<span class="keyword">this</span>) &#123;</div><div class="line">        writeMessageFrameSynchronized(formatOpcode, emitCount, isFirstFrame, <span class="keyword">false</span> <span class="comment">/* final */</span>);</div><div class="line">      &#125;</div><div class="line">      isFirstFrame = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"closed"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (WebSocketWriter.<span class="keyword">this</span>) &#123;</div><div class="line">      writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, <span class="keyword">false</span> <span class="comment">/* final */</span>);</div><div class="line">    &#125;</div><div class="line">    isFirstFrame = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">Timeout <span class="title">timeout</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> sink.<span class="title">timeout</span><span class="params">()</span></span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"PointlessBitwiseExpression"</span>)</div><div class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"closed"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (WebSocketWriter.<span class="keyword">this</span>) &#123;</div><div class="line">      writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, <span class="keyword">true</span> <span class="comment">/* final */</span>);</div><div class="line">    &#125;</div><div class="line">    closed = <span class="keyword">true</span>;</div><div class="line">    activeWriter = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> <code>FrameSink</code> 的 <code>write()</code> 会先将数据写如一个 Buffer 中，然后再从这个 Buffer 中读取数据来发送。如果是第一次发送数据，同时剩余要发送的数据小于 8192<br>字节时，会延迟执行实际的数据发送，等 <code>close()</code> 时刷新。根据 <code>RealWebSocket</code> 的 <code>writeOneFrame()</code> 的逻辑，在 write() 时，总是写入整个消息的所有数据，因而，在 <code>FrameSink</code> 的 <code>write()</code> 中总是不会发送数据的。</p>
<p><code>writeMessageFrameSynchronized()</code> 将用户数据格式化并发送出去。规范中定义的数据格式如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> 0                   1                   2                   3</div><div class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</div><div class="line">|<span class="string">F</span>|<span class="string">R</span>|<span class="string">R</span>|<span class="string">R</span>|<span class="string"> opcode</span>|<span class="string">M</span>|<span class="string"> Payload len </span>|<span class="string">    Extended payload length    </span>|</div><div class="line">|<span class="string">I</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">  (4)  </span>|<span class="string">A</span>|<span class="string">     (7)     </span>|<span class="string">             (16/64)           </span>|</div><div class="line">|<span class="string">N</span>|<span class="string">V</span>|<span class="string">V</span>|<span class="string">V</span>|<span class="string">       </span>|<span class="string">S</span>|<span class="string">             </span>|<span class="string">   (if payload len==126/127)   </span>|</div><div class="line">|<span class="string"> </span>|<span class="string">1</span>|<span class="string">2</span>|<span class="string">3</span>|<span class="string">       </span>|<span class="string">K</span>|<span class="string">             </span>|<span class="string">                               </span>|</div><div class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</div><div class="line">|<span class="string">     Extended payload length continued, if payload len == 127  </span>|</div><div class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</div><div class="line">|<span class="string">                               </span>|<span class="string">Masking-key, if MASK set to 1  </span>|</div><div class="line">+-------------------------------+-------------------------------+</div><div class="line">|<span class="string"> Masking-key (continued)       </span>|<span class="string">          Payload Data         </span>|</div><div class="line">+-------------------------------- - - - - - - - - - - - - - - - +</div><div class="line">:                     Payload Data continued ...                :</div><div class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</div><div class="line">|<span class="string">                     Payload Data continued ...                </span>|</div><div class="line">+---------------------------------------------------------------+</div></pre></td></tr></table></figure></p>
<p>基本结构为：</p>
<ol>
<li>第一个字节是 meta data 控制位，包括四位的操作码，用于指明这是否是消息的最后一帧的FIN位及三个保留位。</li>
<li>第二个字节包括掩码位，和载荷长度或载荷长度指示。只有载荷长度比较小，在 127 以内时，载荷长度才会包含在这个字节中。否则这个字节中将包含载荷长度指示的位。</li>
<li>可选的载荷长度。载荷长度大于127时，帧中会专门有一些字节来描述载荷的长度。载荷长度具体占用几个自己，因载荷的实际长度而异。</li>
<li>可选的掩码字节。客户端发送的帧，设置掩码指示位，并包含四个字节的掩码字节。</li>
<li>载荷数据。客户端发送的数据，会将原始的数据与掩码字节做异或之后再发送。</li>
</ol>
<p>关于帧格式的更详细信息，可以参考 <a href="https://tools.ietf.org/html/rfc6455#section-5.2" target="_blank" rel="external">WebSocket Protocol 规范</a>。</p>
<h2 id="数据的接收"><a href="#数据的接收" class="headerlink" title="数据的接收"></a>数据的接收</h2><p>如我们前面看到的， 在握手的HTTP请求返回之后，会在HTTP请求的回调里，启动消息读取循环 <code>loopReader()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="comment">/** Receive frames until there are no more. Invoked only by the reader thread. */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">while</span> (receivedCloseCode == -<span class="number">1</span>) &#123;</div><div class="line">      <span class="comment">// This method call results in one or more onRead* methods being called on this thread.</span></div><div class="line">      reader.processNextFrame();</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在这个循环中，不断通过 <code>WebSocketReader</code> 的 <code>processNextFrame()</code> 读取消息，直到收到了关闭连接的消息。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">class</span> WebSocketReader &#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> FrameCallback &#123;</div><div class="line">    <span class="keyword">void</span> onReadMessage(String text) <span class="keyword">throws</span> IOException;</div><div class="line">    <span class="keyword">void</span> onReadMessage(ByteString bytes) <span class="keyword">throws</span> IOException;</div><div class="line">    <span class="keyword">void</span> onReadPing(ByteString buffer);</div><div class="line">    <span class="keyword">void</span> onReadPong(ByteString buffer);</div><div class="line">    <span class="keyword">void</span> onReadClose(<span class="keyword">int</span> code, String reason);</div><div class="line">  &#125;</div><div class="line">  . . . . . .</div><div class="line">  <span class="keyword">void</span> processNextFrame() <span class="keyword">throws</span> IOException &#123;</div><div class="line">    readHeader();</div><div class="line">    <span class="keyword">if</span> (isControlFrame) &#123;</div><div class="line">      readControlFrame();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      readMessageFrame();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">void</span> readHeader() <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"closed"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Disable the timeout to read the first byte of a new frame.</span></div><div class="line">    <span class="keyword">int</span> b0;</div><div class="line">    <span class="keyword">long</span> timeoutBefore = <span class="keyword">source</span>.timeout().timeoutNanos();</div><div class="line">    <span class="keyword">source</span>.timeout().clearTimeout();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      b0 = <span class="keyword">source</span>.readByte() &amp; <span class="number">0</span>xff;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="keyword">source</span>.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    opcode = b0 &amp; B0_MASK_OPCODE;</div><div class="line">    isFinalFrame = (b0 &amp; B0_FLAG_FIN) != <span class="number">0</span>;</div><div class="line">    isControlFrame = (b0 &amp; OPCODE_FLAG_CONTROL) != <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Control frames must be final frames (cannot contain continuations).</span></div><div class="line">    <span class="keyword">if</span> (isControlFrame &amp;&amp; !isFinalFrame) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Control frames must be final."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> reservedFlag1 = (b0 &amp; B0_FLAG_RSV1) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> reservedFlag2 = (b0 &amp; B0_FLAG_RSV2) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> reservedFlag3 = (b0 &amp; B0_FLAG_RSV3) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (reservedFlag1 || reservedFlag2 || reservedFlag3) &#123;</div><div class="line">      <span class="comment">// Reserved flags are for extensions which we currently do not support.</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Reserved flags are unsupported."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> b1 = <span class="keyword">source</span>.readByte() &amp; <span class="number">0</span>xff;</div><div class="line"></div><div class="line">    isMasked = (b1 &amp; B1_FLAG_MASK) != <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (isMasked == isClient) &#123;</div><div class="line">      <span class="comment">// Masked payloads must be read on the server. Unmasked payloads must be read on the client.</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(isClient</div><div class="line">          ? <span class="string">"Server-sent frames must not be masked."</span></div><div class="line">          : <span class="string">"Client-sent frames must be masked."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Get frame length, optionally reading from follow-up bytes if indicated by special values.</span></div><div class="line">    frameLength = b1 &amp; B1_MASK_LENGTH;</div><div class="line">    <span class="keyword">if</span> (frameLength == PAYLOAD_SHORT) &#123;</div><div class="line">      frameLength = <span class="keyword">source</span>.readShort() &amp; <span class="number">0</span>xffffL; <span class="comment">// Value is unsigned.</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameLength == PAYLOAD_LONG) &#123;</div><div class="line">      frameLength = <span class="keyword">source</span>.readLong();</div><div class="line">      <span class="keyword">if</span> (frameLength &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</div><div class="line">            <span class="string">"Frame length 0x"</span> + <span class="keyword">Long</span>.toHexString(frameLength) + <span class="string">" &gt; 0x7FFFFFFFFFFFFFFF"</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    frameBytesRead = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isControlFrame &amp;&amp; frameLength &gt; PAYLOAD_BYTE_MAX) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Control frame must be less than "</span> + PAYLOAD_BYTE_MAX + <span class="string">"B."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isMasked) &#123;</div><div class="line">      <span class="comment">// Read the masking key as bytes so that they can be used directly for unmasking.</span></div><div class="line">      <span class="keyword">source</span>.readFully(maskKey);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p> <code>processNextFrame()</code> 先读取 Header 的两个字节，然后根据 Header 的信息，读取数据内容。</p>
<p>在读取 Header 时，读的第一个字节是同步的不计超时时间的。<code>WebSocketReader</code> 从 Header 中，获取到这个帧是不是消息的最后一帧，消息的类型，是否有掩码字节，保留位，帧的长度，以及掩码字节等信息。WebSocket 通过掩码位和掩码字节来区分数据是从客户端发送给服务器的，还是服务器发送给客户端的。这里会根据协议，对这些信息进行有效性一致性检验，若不一致则会抛出 <code>ProtocolException</code>。</p>
<p><code>WebSocketReader</code> 同步读取时的调用栈如下：<br><img src="https://www.wolfcstech.com/images/1315506-8f154678806eaf05.png" alt="Reader Thread"></p>
<p>通过帧的 Header 确定了是数据帧，则会执行 <code>readMessageFrame()</code> 读取消息帧：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">class</span> WebSocketReader &#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="keyword">private</span> <span class="keyword">void</span> readMessageFrame() <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">int</span> opcode = <span class="keyword">this</span>.opcode;</div><div class="line">    <span class="keyword">if</span> (opcode != OPCODE_TEXT &amp;&amp; opcode != OPCODE_BINARY) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Unknown opcode: "</span> + toHexString(opcode));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Buffer message = <span class="keyword">new</span> Buffer();</div><div class="line">    readMessage(message);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (opcode == OPCODE_TEXT) &#123;</div><div class="line">      frameCallback.onReadMessage(message.readUtf8());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      frameCallback.onReadMessage(message.readByteString());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Read headers and process any control frames until we reach a non-control frame. */</span></div><div class="line">  <span class="keyword">void</span> readUntilNonControlFrame() <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">while</span> (!closed) &#123;</div><div class="line">      readHeader();</div><div class="line">      <span class="keyword">if</span> (!isControlFrame) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      readControlFrame();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Reads a message body into across one or more frames. Control frames that occur between</div><div class="line">   * fragments will be processed. If the message payload is masked this will unmask as it's being</div><div class="line">   * processed.</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">void</span> readMessage(Buffer sink) <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"closed"</span>);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (frameBytesRead == frameLength) &#123;</div><div class="line">        <span class="keyword">if</span> (isFinalFrame) <span class="keyword">return</span>; <span class="comment">// We are exhausted and have no continuations.</span></div><div class="line"></div><div class="line">        readUntilNonControlFrame();</div><div class="line">        <span class="keyword">if</span> (opcode != OPCODE_CONTINUATION) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Expected continuation opcode. Got: "</span> + toHexString(opcode));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isFinalFrame &amp;&amp; frameLength == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span>; <span class="comment">// Fast-path for empty final frame.</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">long</span> toRead = frameLength - frameBytesRead;</div><div class="line"></div><div class="line">      <span class="keyword">long</span> <span class="keyword">read</span>;</div><div class="line">      <span class="keyword">if</span> (isMasked) &#123;</div><div class="line">        toRead = Math.min(toRead, maskBuffer.length);</div><div class="line">        <span class="keyword">read</span> = <span class="keyword">source</span>.<span class="keyword">read</span>(maskBuffer, <span class="number">0</span>, (<span class="keyword">int</span>) toRead);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">read</span> == -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">        toggleMask(maskBuffer, <span class="keyword">read</span>, maskKey, frameBytesRead);</div><div class="line">        sink.<span class="keyword">write</span>(maskBuffer, <span class="number">0</span>, (<span class="keyword">int</span>) <span class="keyword">read</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">read</span> = <span class="keyword">source</span>.<span class="keyword">read</span>(sink, toRead);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">read</span> == -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      frameBytesRead += <span class="keyword">read</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这个过程中，会读取一条消息包含的所有数据帧。按照 WebSocket 的标准，包含用户数据的消息数据帧可以和控制帧交替发送；但消息之间的数据帧不可以。因而在这个过程中，若遇到了控制帧，则会先读取控制帧进行处理，然后继续读取消息的数据帧，直到读取了消息的所有数据帧。</p>
<p>掩码位和掩码字节，对于客户端而言，发送的数据中包含这些东西，在接收的数据中不包含这些；对于服务器而言，则是在接收的数据中包含这些，发送的数据中不包含。OkHttp 既支持服务器开发，也支持客户端开发，因而可以看到对于掩码位和掩码字节完整的处理。</p>
<p>在一个消息读取完成之后，会通过回调 <code>FrameCallback</code> 将读取的内容通知出去。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">class</span> WebSocketReader &#123;</div><div class="line">  . . . . . .</div><div class="line">  WebSocketReader(<span class="keyword">boolean</span> isClient, BufferedSource <span class="keyword">source</span>, FrameCallback frameCallback) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">source</span> == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"source == null"</span>);</div><div class="line">    <span class="keyword">if</span> (frameCallback == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"frameCallback == null"</span>);</div><div class="line">    <span class="keyword">this</span>.isClient = isClient;</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">source</span> = <span class="keyword">source</span>;</div><div class="line">    <span class="keyword">this</span>.frameCallback = frameCallback;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这一事件会通知到 <code>RealWebSocket</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadMessage</span><span class="params">(String text)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    listener.onMessage(<span class="keyword">this</span>, text);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadMessage</span><span class="params">(ByteString bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    listener.onMessage(<span class="keyword">this</span>, bytes);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>RealWebSocket</code> 中，这一事件又被通知到我们在应用程序中创建的回调 <code>WebSocketListener</code>。</p>
<h2 id="连接的保活"><a href="#连接的保活" class="headerlink" title="连接的保活"></a>连接的保活</h2><p>连接的保活通过 PING 帧和 PONG 帧来实现。如我们前面看到的，若用户设置了 PING 帧的发送周期，在握手的HTTP请求返回时，消息读取循环开始前会调度 <code>PingRunnable</code> 周期性的向服务器发送 PING 帧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    PingRunnable() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      writePingFrame();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">writePingFrame</span><span class="params">()</span> </span>&#123;</div><div class="line">    WebSocketWriter writer;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (failed) <span class="keyword">return</span>;</div><div class="line">      writer = <span class="keyword">this</span>.writer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      writer.writePing(ByteString.EMPTY);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      failWebSocket(e, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>PingRunnable</code> 中，通过 <code>WebSocketWriter</code> 发送 PING 帧：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketWriter</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="comment">/** Send a ping with the supplied &#123;<span class="doctag">@code</span> payload&#125;. */</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">writePing</span><span class="params">(ByteString payload)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      writeControlFrameSynchronized(OPCODE_CONTROL_PING, payload);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  . . . . . .</div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">writeControlFrameSynchronized</span><span class="params">(<span class="keyword">int</span> opcode, ByteString payload)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">assert</span> Thread.<span class="title">holdsLock</span><span class="params">(<span class="keyword">this</span>)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (writerClosed) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"closed"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> length = payload.size();</div><div class="line">    <span class="keyword">if</span> (length &gt; PAYLOAD_BYTE_MAX) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">          <span class="string">"Payload size must be less than or equal to "</span> + PAYLOAD_BYTE_MAX);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> b0 = B0_FLAG_FIN | opcode;</div><div class="line">    sink.writeByte(b0);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> b1 = length;</div><div class="line">    <span class="keyword">if</span> (isClient) &#123;</div><div class="line">      b1 |= B1_FLAG_MASK;</div><div class="line">      sink.writeByte(b1);</div><div class="line"></div><div class="line">      random.nextBytes(maskKey);</div><div class="line">      sink.write(maskKey);</div><div class="line"></div><div class="line">      <span class="keyword">byte</span>[] bytes = payload.toByteArray();</div><div class="line">      toggleMask(bytes, bytes.length, maskKey, <span class="number">0</span>);</div><div class="line">      sink.write(bytes);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      sink.writeByte(b1);</div><div class="line">      sink.write(payload);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sink.flush();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>PING 帧是一个不包含载荷的控制帧。关于掩码位和掩码字节的设置，与消息的数据帧相同。即客户端发送的帧，设置掩码位，帧中包含掩码字节；服务器发送的帧，不设置掩码位，帧中不包含掩码字节。</p>
<p>通过 WebSocket 通信的双方，在收到对方发来的 PING 帧时，需要用PONG帧来回复。在 <code>WebSocketReader</code> 的 <code>readControlFrame()</code> 中可以看到这一点：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">final <span class="keyword">class</span> WebSocketReader &#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="keyword">private</span> <span class="keyword">void</span> readControlFrame() throws IOException &#123;</div><div class="line">    Buffer <span class="built_in">buffer</span> = <span class="keyword">new</span> Buffer();</div><div class="line">    <span class="built_in">if</span> (frameBytesRead &lt; frameLength) &#123;</div><div class="line">      <span class="built_in">if</span> (isClient) &#123;</div><div class="line">        source.readFully(<span class="built_in">buffer</span>, frameLength);</div><div class="line">      &#125; <span class="built_in">else</span> &#123;</div><div class="line">        <span class="built_in">while</span> (frameBytesRead &lt; frameLength) &#123;</div><div class="line">          <span class="keyword">int</span> toRead = (<span class="keyword">int</span>) Math.<span class="built_in">min</span>(frameLength - frameBytesRead, maskBuffer.length);</div><div class="line">          <span class="keyword">int</span> <span class="built_in">read</span> = source.<span class="built_in">read</span>(maskBuffer, <span class="number">0</span>, toRead);</div><div class="line">          <span class="built_in">if</span> (<span class="built_in">read</span> == <span class="number">-1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">          toggleMask(maskBuffer, <span class="built_in">read</span>, maskKey, frameBytesRead);</div><div class="line">          <span class="built_in">buffer</span>.<span class="built_in">write</span>(maskBuffer, <span class="number">0</span>, <span class="built_in">read</span>);</div><div class="line">          frameBytesRead += <span class="built_in">read</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">switch</span> (opcode) &#123;</div><div class="line">      <span class="built_in">case</span> OPCODE_CONTROL_PING:</div><div class="line">        frameCallback.onReadPing(<span class="built_in">buffer</span>.readByteString());</div><div class="line">        <span class="built_in">break</span>;</div><div class="line">      <span class="built_in">case</span> OPCODE_CONTROL_PONG:</div><div class="line">        frameCallback.onReadPong(<span class="built_in">buffer</span>.readByteString());</div><div class="line">        <span class="built_in">break</span>;</div></pre></td></tr></table></figure></p>
<p>PING 帧和 PONG 帧都不带载荷，控制帧读写时对于载荷长度的处理，都是为 CLOSE 帧做的。因而针对 PING 帧和 PONG 帧，除了 Header 外， <code>readControlFrame()</code> 实际上无需再读取任何数据，但它会将这些事件通知出去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onReadPing</span><span class="params">(ByteString payload)</span> </span>&#123;</div><div class="line">    <span class="comment">// Don't respond to pings after we've failed or sent the close frame.</span></div><div class="line">    <span class="keyword">if</span> (failed || (enqueuedClose &amp;&amp; messageAndCloseQueue.isEmpty())) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    pongQueue.add(payload);</div><div class="line">    runWriter();</div><div class="line">    pingCount++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onReadPong</span><span class="params">(ByteString buffer)</span> </span>&#123;</div><div class="line">    <span class="comment">// This API doesn't expose pings.</span></div><div class="line">    pongCount++;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可见在收到 PING 帧的时候，总是会发一个 PONG 帧出去，且通常其没有载荷数据。在收到一个 PONG 帧时，则通常只是记录一下，然后什么也不做。如我们前面所见，PONG 帧在 <code>writerRunnable</code> 中被发送出去：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> &#123;</span></div><div class="line">  . . . . . .</div><div class="line">      <span class="keyword">if</span> (pong != <span class="literal">null</span>) &#123;</div><div class="line">        writer.writePong(pong);</div><div class="line"></div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose <span class="keyword">instanceof</span> Message) &#123;</div></pre></td></tr></table></figure></p>
<p>PONG 帧的发送与 PING 帧的非常相似：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketWriter</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="comment">/** Send a pong with the supplied &#123;<span class="doctag">@code</span> payload&#125;. */</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">writePong</span><span class="params">(ByteString payload)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      writeControlFrameSynchronized(OPCODE_CONTROL_PONG, payload);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="连接的关闭"><a href="#连接的关闭" class="headerlink" title="连接的关闭"></a>连接的关闭</h2><p>连接的关闭，与数据发送的过程颇有几分相似之处。通过 <code>WebSocket</code> 接口的 <code>close(int code, String reason)</code> 我们可以关闭一个 WebSocket 连接：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> code, String reason)</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> <span class="title">close</span><span class="params">(code, reason, CANCEL_AFTER_CLOSE_MILLIS)</span></span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">synchronized</span> <span class="function"><span class="keyword">boolean</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> code, String reason, <span class="keyword">long</span> cancelAfterCloseMillis)</span> </span>&#123;</div><div class="line">    validateCloseCode(code);</div><div class="line"></div><div class="line">    ByteString reasonBytes = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (reason != <span class="keyword">null</span>) &#123;</div><div class="line">      reasonBytes = ByteString.encodeUtf8(reason);</div><div class="line">      <span class="keyword">if</span> (reasonBytes.size() &gt; CLOSE_MESSAGE_MAX) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"reason.size() &gt; "</span> + CLOSE_MESSAGE_MAX + <span class="string">": "</span> + reason);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (failed || enqueuedClose) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Immediately prevent further frames from being enqueued.</span></div><div class="line">    enqueuedClose = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Enqueue the close frame.</span></div><div class="line">    messageAndCloseQueue.add(<span class="keyword">new</span> Close(code, reasonBytes, cancelAfterCloseMillis));</div><div class="line">    runWriter();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在执行关闭连接动作前，会先检查一下 close code 的有效性在合法范围内。关于不同 close code 的详细说明，可以参考 <a href="https://tools.ietf.org/html/rfc6455#section-7.4" target="_blank" rel="external">WebSocket 协议规范</a>。</p>
<p>检查完了之后，会构造一个 Close 消息放入发送消息队列，并调度 <code>writerRunnable</code> 执行。Close 消息可以带有不超出 123 字节的字符串，以作为 Close message，来说明连接关闭的原因。</p>
<p>连接的关闭分为主动关闭和被动关闭。客户端先向服务器发送一个 CLOSE 帧，然后服务器恢复一个 CLOSE 帧，对于客户端而言，这个过程为主动关闭；反之则为对客户端而言则为被动关闭。</p>
<p>在 <code>writerRunnable</code> 执行的 <code>writeOneFrame()</code> 实际发送 CLOSE 帧：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="title">implements</span> <span class="title">WebSocket</span>, <span class="type">WebSocketReader.FrameCallback &#123;</span></span></div><div class="line">  . . . . . .</div><div class="line">        messageOrClose = messageAndCloseQueue.poll();</div><div class="line">        <span class="keyword">if</span> (messageOrClose instanceof Close) &#123;</div><div class="line">          receivedCloseCode = <span class="keyword">this</span>.receivedCloseCode;</div><div class="line">          receivedCloseReason = <span class="keyword">this</span>.receivedCloseReason;</div><div class="line">          <span class="keyword">if</span> (receivedCloseCode != <span class="number">-1</span>) &#123;</div><div class="line">            streamsToClose = <span class="keyword">this</span>.streams;</div><div class="line">            <span class="keyword">this</span>.streams = <span class="literal">null</span>;</div><div class="line">            <span class="keyword">this</span>.executor.shutdown();</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// When we request a graceful close also schedule a cancel of the websocket.</span></div><div class="line">            cancelFuture = executor.schedule(new CancelRunnable(),</div><div class="line">                ((Close) messageOrClose).cancelAfterCloseMillis, MILLISECONDS);</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose == <span class="literal">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// The queue is exhausted.</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">  . . . . . .</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageOrClose instanceof Close) &#123;</div><div class="line">        Close close = (Close) messageOrClose;</div><div class="line">        writer.writeClose(close.code, close.reason);</div><div class="line"></div><div class="line">        <span class="comment">// We closed the writer: now both reader and writer are closed.</span></div><div class="line">        <span class="keyword">if</span> (streamsToClose != <span class="literal">null</span>) &#123;</div><div class="line">          listener.onClosed(<span class="keyword">this</span>, receivedCloseCode, receivedCloseReason);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div></pre></td></tr></table></figure></p>
<p>发送 CLOSE 帧也分为主动关闭的发送还是被动关闭的发送。<br>对于被动关闭，在发送完 CLOSE 帧之后，连接被最终关闭，因而，发送 CLOSE 帧之前，这里会停掉发送消息用的 executor。而在发送之后，则会通过 <code>onClosed()</code> 通知用户。</p>
<p>而对于主动关闭，则在发送前会调度 <code>CancelRunnable</code> 的执行，发送后不会通过 <code>onClosed()</code> 通知用户。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketWriter</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">writeClose</span><span class="params">(<span class="keyword">int</span> code, ByteString reason)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ByteString payload = ByteString.EMPTY;</div><div class="line">    <span class="keyword">if</span> (code != <span class="number">0</span> || reason != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (code != <span class="number">0</span>) &#123;</div><div class="line">        validateCloseCode(code);</div><div class="line">      &#125;</div><div class="line">      Buffer buffer = <span class="keyword">new</span> Buffer();</div><div class="line">      buffer.writeShort(code);</div><div class="line">      <span class="keyword">if</span> (reason != <span class="keyword">null</span>) &#123;</div><div class="line">        buffer.write(reason);</div><div class="line">      &#125;</div><div class="line">      payload = buffer.readByteString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        writerClosed = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>将 CLOSE 帧发送到网络的过程与 PING 和 PONG 帧的颇为相似，仅有的差别就是 CLOSE 帧有载荷。关于掩码位和掩码自己的规则，同样适用于 CLOSE 帧的发送。</p>
<p>CLOSE 的读取在 <code>WebSocketReader</code> 的 <code>readControlFrame()</code>中：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">final <span class="keyword">class</span> WebSocketReader &#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="keyword">private</span> <span class="keyword">void</span> readControlFrame() throws IOException &#123;</div><div class="line">    Buffer <span class="built_in">buffer</span> = <span class="keyword">new</span> Buffer();</div><div class="line">    <span class="built_in">if</span> (frameBytesRead &lt; frameLength) &#123;</div><div class="line">      <span class="built_in">if</span> (isClient) &#123;</div><div class="line">        source.readFully(<span class="built_in">buffer</span>, frameLength);</div><div class="line">      &#125; <span class="built_in">else</span> &#123;</div><div class="line">        <span class="built_in">while</span> (frameBytesRead &lt; frameLength) &#123;</div><div class="line">          <span class="keyword">int</span> toRead = (<span class="keyword">int</span>) Math.<span class="built_in">min</span>(frameLength - frameBytesRead, maskBuffer.length);</div><div class="line">          <span class="keyword">int</span> <span class="built_in">read</span> = source.<span class="built_in">read</span>(maskBuffer, <span class="number">0</span>, toRead);</div><div class="line">          <span class="built_in">if</span> (<span class="built_in">read</span> == <span class="number">-1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</div><div class="line">          toggleMask(maskBuffer, <span class="built_in">read</span>, maskKey, frameBytesRead);</div><div class="line">          <span class="built_in">buffer</span>.<span class="built_in">write</span>(maskBuffer, <span class="number">0</span>, <span class="built_in">read</span>);</div><div class="line">          frameBytesRead += <span class="built_in">read</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">switch</span> (opcode) &#123;</div><div class="line">  . . . . . .</div><div class="line">      <span class="built_in">case</span> OPCODE_CONTROL_CLOSE:</div><div class="line">        <span class="keyword">int</span> code = CLOSE_NO_STATUS_CODE;</div><div class="line">        <span class="keyword">String</span> reason = <span class="string">""</span>;</div><div class="line">        <span class="keyword">long</span> bufferSize = <span class="built_in">buffer</span>.<span class="built_in">size</span>();</div><div class="line">        <span class="built_in">if</span> (bufferSize == <span class="number">1</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Malformed close payload length of 1."</span>);</div><div class="line">        &#125; <span class="built_in">else</span> <span class="built_in">if</span> (bufferSize != <span class="number">0</span>) &#123;</div><div class="line">          code = <span class="built_in">buffer</span>.readShort();</div><div class="line">          reason = <span class="built_in">buffer</span>.readUtf8();</div><div class="line">          <span class="keyword">String</span> codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);</div><div class="line">          <span class="built_in">if</span> (codeExceptionMessage != null) <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(codeExceptionMessage);</div><div class="line">        &#125;</div><div class="line">        frameCallback.onReadClose(code, reason);</div><div class="line">        closed = true;</div><div class="line">        <span class="built_in">break</span>;</div><div class="line">      <span class="built_in">default</span>:</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Unknown control opcode: "</span> + toHexString(opcode));</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>读到 CLOSE 帧时，<code>WebSocketReader</code> 会将这一事件通知出去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealWebSocket</span> <span class="keyword">implements</span> <span class="title">WebSocket</span>, <span class="title">WebSocketReader</span>.<span class="title">FrameCallback</span> </span>&#123;</div><div class="line">  . . . . . .</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadClose</span><span class="params">(<span class="keyword">int</span> code, String reason)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (code == -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line"></div><div class="line">    Streams toClose = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (receivedCloseCode != -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"already closed"</span>);</div><div class="line">      receivedCloseCode = code;</div><div class="line">      receivedCloseReason = reason;</div><div class="line">      <span class="keyword">if</span> (enqueuedClose &amp;&amp; messageAndCloseQueue.isEmpty()) &#123;</div><div class="line">        toClose = <span class="keyword">this</span>.streams;</div><div class="line">        <span class="keyword">this</span>.streams = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (cancelFuture != <span class="keyword">null</span>) cancelFuture.cancel(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">this</span>.executor.shutdown();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      listener.onClosing(<span class="keyword">this</span>, code, reason);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (toClose != <span class="keyword">null</span>) &#123;</div><div class="line">        listener.onClosed(<span class="keyword">this</span>, code, reason);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      closeQuietly(toClose);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>对于收到的 CLOSE 帧处理同样分为主动关闭的情况和被动关闭的情况。与 CLOSE 发送时的情形正好相反，若是主动关闭，则在收到 CLOSE 帧之后，WebSocket 连接最终断开，因而需要停掉executor，被动关闭则暂时不需要。</p>
<p>收到 CLOSE 帧，总是会通过 <code>onClosing()</code> 将事件通知出去。</p>
<p>对于主动关闭的情形，最后还会通过 <code>onClosed()</code> 通知用户，连接已经最终关闭。</p>
<p>关于 WebSocket 的 CLOSE 帧的更多说明，可以参考 <a href="https://tools.ietf.org/html/rfc6455#section-5.5.1" target="_blank" rel="external">WebSocket协议规范</a>。</p>
<h2 id="WebSocket连接的生命周期"><a href="#WebSocket连接的生命周期" class="headerlink" title="WebSocket连接的生命周期"></a>WebSocket连接的生命周期</h2><p>总结一下 WebSocket 连接的生命周期：</p>
<ol>
<li>连接通过一个HTTP请求握手并建立连接。WebSocket 连接可以理解为是通过HTTP请求建立的普通TCP连接。</li>
<li>WebSocket 做了二进制分帧。WebSocket 连接中收发的数据以帧为单位。主要有用于连接保活的控制帧 PING 和 PONG，用于用户数据发送的 MESSAGE 帧，和用于关闭连接的控制帧 CLOSE。</li>
<li>连接建立之后，通过 PING 帧和 PONG 帧做连接保活。</li>
<li>一次 send 数据，被封为一个消息，通过一个或多个 MESSAGE帧进行发送。一个消息的帧和控制帧可以交叉发送，不同消息的帧之间不可以。</li>
<li>WebSocket 连接的两端相互发送一个 CLOSE 帧以最终关闭连接。</li>
</ol>
<p>关于 WebSocket 的详细信息，可以参考 <a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="external">WebSocket协议规范</a>。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="external">WebSocket 协议规范</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-WebSocket/index.html" target="_blank" rel="external">WebSocket 实战</a><br><a href="https://www.ibm.com/developerworks/cn/web/1112_huangxa_websocket/index.html" target="_blank" rel="external">使用 HTML5 WebSocket 构建实时 Web 应用</a><br><a href="http://howtoprogram.xyz/2016/12/24/websocket-client-example-okhttp/" target="_blank" rel="external">WebSocket Client Example with OkHttp</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wxpay.png" alt="Han Pengfei WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Han Pengfei Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/网络协议/" rel="tag"># 网络协议</a>
          
            <a href="/tags/Android开发/" rel="tag"># Android开发</a>
          
            <a href="/tags/源码分析/" rel="tag"># 源码分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/22/introduction_to_android_things/" rel="next" title="Android Things介绍">
                <i class="fa fa-chevron-left"></i> Android Things介绍
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/24/Install_Tomcat8_on_Ubuntu16.04/" rel="prev" title="Ubuntu 16.04 Tomcat 8安装指南">
                Ubuntu 16.04 Tomcat 8安装指南 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/freesoft.jpg"
                alt="Han Pengfei" />
            
              <p class="site-author-name" itemprop="name">Han Pengfei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">161</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hanpfei" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.douban.com/people/3681478/" target="_blank" title="豆瓣"><i class="fa fa-fw fa-globe"></i>豆瓣</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/han-peng-fei-49" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hanpfei@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://source.android.com/" title="Android Open Source Project" target="_blank">Android Open Source Project</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.vants.org/" title="蚂蚁网" target="_blank">蚂蚁网</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OkHttp-WebSocket客户端-API-用法"><span class="nav-number">1.</span> <span class="nav-text">OkHttp WebSocket客户端 API 用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OkHttp-的-WebSocket-实现"><span class="nav-number">2.</span> <span class="nav-text">OkHttp 的 WebSocket 实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#连接握手"><span class="nav-number">3.</span> <span class="nav-text">连接握手</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据发送"><span class="nav-number">3.1.</span> <span class="nav-text">数据发送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据的接收"><span class="nav-number">3.2.</span> <span class="nav-text">数据的接收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接的保活"><span class="nav-number">3.3.</span> <span class="nav-text">连接的保活</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接的关闭"><span class="nav-number">3.4.</span> <span class="nav-text">连接的关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocket连接的生命周期"><span class="nav-number">3.5.</span> <span class="nav-text">WebSocket连接的生命周期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文档"><span class="nav-number">4.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016.09.16 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Han Pengfei</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname,
            owner: 'hanpfei',
            repo: 'blog_comment',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '2e5e06c86dfee4177d58dd4660d1ed4bce4f155d',
            
                client_id: '0ec580f0a999fbe77a63'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("KUAjB88PxNQR5DOgg6jhgdp7-gzGzoHsz", "3c3yzt2EN31aXwYgVdmzDUUk");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  

  

  

</body>
</html>
