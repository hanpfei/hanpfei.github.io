<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>live555 源码分析：基础设施 | WolfcsTech</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.2.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=1.2.0"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">live555 源码分析：基础设施</h1><a id="logo" href="/.">WolfcsTech</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">live555 源码分析：基础设施</h1><div class="post-meta">Aug 30, 2017<span> | </span><span class="category"><a href="/categories/live555/">live555</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2017/08/30/live555_src_analysis_infrasture/" href="/2017/08/30/live555_src_analysis_infrasture/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>live555 由多个模块组成，其中 UsageEnvironment 、 BasicUsageEnvironment 和 groupsock 分别提供了事件循环，输入输出，基本的数据结构，以及网络 IO 等功能，它们可以看作 live555 的基础设施。对于 live555 的源码分析，就从这些基础设施，基本的数据结构开始。<br><a id="more"></a></p>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p>首先来看 <code>HashTable</code>，这是 live555 定义的一个范型关联容器。</p>
<h2 id="UsageEnvironment-的-HashTable"><a href="#UsageEnvironment-的-HashTable" class="headerlink" title="UsageEnvironment 的 HashTable"></a>UsageEnvironment 的 HashTable</h2><p>UsageEnvironment 中的 <code>HashTable</code> 类定义了接口，该接口定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> HashTable &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~HashTable();</div><div class="line">  </div><div class="line">  <span class="comment">// The following must be implemented by a particular</span></div><div class="line">  <span class="comment">// implementation (subclass):</span></div><div class="line">  <span class="function"><span class="keyword">static</span> HashTable* <span class="title">create</span><span class="params">(<span class="keyword">int</span> keyType)</span></span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">Add</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* key, <span class="keyword">void</span>* value)</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="comment">// Returns the old value if different, otherwise 0</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> Boolean <span class="title">Remove</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* key)</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">Lookup</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* key)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="comment">// Returns 0 if not found</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">numEntries</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="function">Boolean <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> numEntries() == <span class="number">0</span>; &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// Used to iterate through the members of the table:</span></div><div class="line">  <span class="keyword">class</span> Iterator &#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="comment">// The following must be implemented by a particular</span></div><div class="line">    <span class="comment">// implementation (subclass):</span></div><div class="line">    <span class="function"><span class="keyword">static</span> Iterator* <span class="title">create</span><span class="params">(HashTable <span class="keyword">const</span>&amp; hashTable)</span></span>;</div><div class="line">    </div><div class="line">    <span class="keyword">virtual</span> ~Iterator();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">next</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>*&amp; key)</span> </span>= <span class="number">0</span>; <span class="comment">// returns 0 if none</span></div><div class="line">    </div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    Iterator(); <span class="comment">// abstract base class</span></div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="comment">// A shortcut that can be used to successively remove each of</span></div><div class="line">  <span class="comment">// the entries in the table (e.g., so that their values can be</span></div><div class="line">  <span class="comment">// deleted, if they happen to be pointers to allocated memory).</span></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">RemoveNext</span><span class="params">()</span></span>;</div><div class="line">  </div><div class="line">  <span class="comment">// Returns the first entry in the table.</span></div><div class="line">  <span class="comment">// (This is useful for deleting each entry in the table, if the entry's destructor also removes itself from the table.)</span></div><div class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">getFirst</span><span class="params">()</span></span>; </div><div class="line">  </div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  HashTable(); <span class="comment">// abstract base class</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Warning: The following are deliberately the same as in</span></div><div class="line"><span class="comment">// Tcl's hash table implementation</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> STRING_HASH_KEYS = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> ONE_WORD_HASH_KEYS = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>尽管 <code>HashTable</code> 要定义为范型关联容器，然而它没有使用 C++ 的模板。<code>HashTable</code> 要求键为一个 C 风格的字符串，即 <code>char const*</code>，而值为一个 <code>void*</code>，以此可以表示各种不同类型的值。就像 C++ 标准库中的许多容器一眼，<code>HashTable</code> 内部还定义了一个迭代器类，用来遍历这个容器。</p>
<p>其它添加、移除、查找元素等操作，与其它的普通容器设计并没有太大的不同。</p>
<p><code>HashTable</code> 类实现了公共的与具体存储结构无关的两个模板函数 <code>RemoveNext()</code> 和 <code>getFirst()</code>，这两个函数分别用于移除容器中的下一个元素并返回元素的值，及得到容器中的第一个元素，它们的实现如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include <span class="string">"HashTable.hh"</span></div><div class="line"></div><div class="line">HashTable::HashTable() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HashTable::~HashTable() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HashTable::<span class="built_in">Iterator</span>::<span class="built_in">Iterator</span>() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HashTable::<span class="built_in">Iterator</span>::~<span class="built_in">Iterator</span>() &#123;&#125;</div><div class="line"></div><div class="line">void* HashTable::RemoveNext() &#123;</div><div class="line">  <span class="built_in">Iterator</span>* iter = <span class="built_in">Iterator</span>::create(*this);</div><div class="line">  <span class="keyword">char</span> <span class="keyword">const</span>* key;</div><div class="line">  void* removedValue = iter-&gt;next(key);</div><div class="line">  <span class="keyword">if</span> (removedValue != <span class="number">0</span>) Remove(key);</div><div class="line"></div><div class="line">  delete iter;</div><div class="line">  <span class="keyword">return</span> removedValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void* HashTable::getFirst() &#123;</div><div class="line">  <span class="built_in">Iterator</span>* iter = <span class="built_in">Iterator</span>::create(*this);</div><div class="line">  <span class="keyword">char</span> <span class="keyword">const</span>* key;</div><div class="line">  void* firstValue = iter-&gt;next(key);</div><div class="line"></div><div class="line">  delete iter;</div><div class="line">  <span class="keyword">return</span> firstValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数，都借助于容器的迭代器来实现。<code>Iterator</code> 类的 <code>next(char const*&amp; key)</code> 接收一个传出参数，用于将键返回给调用者。</p>
<p>从接口定义的角度来看 live555 定义的 <code>HashTable</code>。它的 <code>Iterator</code> 类对象是由 <code>Iterator</code> 类的静态方法 <code>create(HashTable const&amp; hashTable)</code> 创建的，但销毁创建的对象的职责却是在调用者这里，这大大破坏了 <code>HashTable</code> 接口的实现的灵活性，比如创建的对象因此而无法做缓存。</p>
<p><code>HashTable</code> 类及其迭代器类 <code>Iterator</code> 各自定义了一个静态方法 <code>create()</code>。这里使用了桥接的方式，<code>HashTable</code> 的这个方法像一座桥一样，把 <code>HashTable</code> 接口与接口的实现联系了起来。这个类静态函数都在实现接口的类中定义。</p>
<p><code>HashTable</code> 有两种类型，分别用两个整型值来标识，<code>STRING_HASH_KEYS</code> 和 <code>ONE_WORD_HASH_KEYS</code>。当然，依赖于在 <code>create()</code> 方法中是根据 <code>HashTable</code> 类型创建相同类的对象还是创建不同类的对象，可以将 <code>create()</code> 方法的设计理解为是桥接，或者工厂方法。</p>
<h2 id="BasicUsageEnvironment-的-BasicHashTable"><a href="#BasicUsageEnvironment-的-BasicHashTable" class="headerlink" title="BasicUsageEnvironment 的 BasicHashTable"></a>BasicUsageEnvironment 的 BasicHashTable</h2><p>BasicUsageEnvironment 中的 <code>BasicHashTable</code> 提供了一个 <code>HashTable</code> 的实现。<code>BasicHashTable</code> 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A simple hash table implementation, inspired by the hash table</span></div><div class="line"><span class="comment">// implementation used in Tcl 7.6: &lt;http://www.tcl.tk/&gt;</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALL_HASH_TABLE_SIZE 4</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> BasicHashTable: <span class="keyword">public</span> HashTable &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">class</span> TableEntry; <span class="comment">// forward</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BasicHashTable(<span class="keyword">int</span> keyType);</div><div class="line">  <span class="keyword">virtual</span> ~BasicHashTable();</div><div class="line"></div><div class="line">  <span class="comment">// Used to iterate through the members of the table:</span></div><div class="line">  <span class="keyword">class</span> Iterator; <span class="keyword">friend</span> <span class="keyword">class</span> Iterator; <span class="comment">// to make Sun's C++ compiler happy</span></div><div class="line">  <span class="keyword">class</span> Iterator: <span class="keyword">public</span> HashTable::Iterator &#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Iterator(BasicHashTable <span class="keyword">const</span>&amp; table);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>: <span class="comment">// implementation of inherited pure virtual functions</span></div><div class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">next</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>*&amp; key)</span></span>; <span class="comment">// returns 0 if none</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    BasicHashTable <span class="keyword">const</span>&amp; fTable;</div><div class="line">    <span class="keyword">unsigned</span> fNextIndex; <span class="comment">// index of next bucket to be enumerated after this</span></div><div class="line">    TableEntry* fNextEntry; <span class="comment">// next entry in the current bucket</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line"><span class="keyword">private</span>: <span class="comment">// implementation of inherited pure virtual functions</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">Add</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* key, <span class="keyword">void</span>* value)</span></span>;</div><div class="line">  <span class="comment">// Returns the old value if different, otherwise 0</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> Boolean <span class="title">Remove</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* key)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">Lookup</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* key)</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="comment">// Returns 0 if not found</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">numEntries</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">class</span> TableEntry &#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TableEntry* fNext;</div><div class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* key;</div><div class="line">    <span class="keyword">void</span>* value;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="function">TableEntry* <span class="title">lookupKey</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* key, <span class="keyword">unsigned</span>&amp; index)</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="comment">// returns entry matching "key", or NULL if none</span></div><div class="line">  <span class="function">Boolean <span class="title">keyMatches</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* key1, <span class="keyword">char</span> <span class="keyword">const</span>* key2)</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="comment">// used to implement "lookupKey()"</span></div><div class="line"></div><div class="line">  <span class="function">TableEntry* <span class="title">insertNewEntry</span><span class="params">(<span class="keyword">unsigned</span> index, <span class="keyword">char</span> <span class="keyword">const</span>* key)</span></span>;</div><div class="line">    <span class="comment">// creates a new entry, and inserts it in the table</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">assignKey</span><span class="params">(TableEntry* entry, <span class="keyword">char</span> <span class="keyword">const</span>* key)</span></span>;</div><div class="line">    <span class="comment">// used to implement "insertNewEntry()"</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(<span class="keyword">unsigned</span> index, TableEntry* entry)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(TableEntry* entry)</span></span>;</div><div class="line">    <span class="comment">// used to implement "deleteEntry()"</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">()</span></span>; <span class="comment">// rebuilds the table as its size increases</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">hashIndexFromKey</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* key)</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="comment">// used to implement many of the routines above</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">randomIndex</span><span class="params">(<span class="keyword">uintptr_t</span> i)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span>)(((i*<span class="number">1103515245</span>) &gt;&gt; fDownShift) &amp; fMask);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  TableEntry** fBuckets; <span class="comment">// pointer to bucket array</span></div><div class="line">  TableEntry* fStaticBuckets[SMALL_HASH_TABLE_SIZE];<span class="comment">// used for small tables</span></div><div class="line">  <span class="keyword">unsigned</span> fNumBuckets, fNumEntries, fRebuildSize, fDownShift, fMask;</div><div class="line">  <span class="keyword">int</span> fKeyType;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>BasicHashTable</code> 定义了一个类 <code>TableEntry</code>，用于表示键-值对。<code>fNext</code> 字段用于指向计算的键的哈希值冲突的不同的键-值对中的下一个。</p>
<p>来看 <code>BasicHashTable</code> 的创建：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BasicHashTable::BasicHashTable(<span class="keyword">int</span> keyType)</div><div class="line">  : fBuckets(fStaticBuckets), fNumBuckets(SMALL_HASH_TABLE_SIZE),</div><div class="line">    fNumEntries(0), fRebuildSize(SMALL_HASH_TABLE_SIZE*REBUILD_MULTIPLIER),</div><div class="line">    fDownShift(28), fMask(0x3), fKeyType(keyType) &#123;</div><div class="line">  <span class="keyword">for</span> (unsigned i = <span class="number">0</span>; i &lt; SMALL_HASH_TABLE_SIZE; ++i) &#123;</div><div class="line">    fStaticBuckets[i] = NULL;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">. . . . . .</div><div class="line">HashTable* HashTable::create(<span class="keyword">int</span> keyType) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BasicHashTable(keyType);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>BasicHashTable</code> 用 <code>TableEntry</code> 指针的数组保存所有的键-值对。在该类对象创建时，一个小的 <code>TableEntry</code> 指针数组 <code>fStaticBuckets</code> 会随着对象的创建而创建，在 <code>BasicHashTable</code> 中元素比较少时，直接在这个数组中保存键值对，以此来优化当元素比较少的性能，降低内存分配的开销。</p>
<p><code>fBuckets</code> 指向保存键-值对的 <code>TableEntry</code> 指针数组，在对象创建初期，它指向 <code>fStaticBuckets</code>，而在哈希桶扩容时，它指向新分配的 <code>TableEntry</code> 指针数组。对于容器中元素的访问，都通过<br> <code>fBuckets</code> 来完成。<code>fNumBuckets</code> 用于保存 <code>TableEntry</code> 指针数组的长度。<code>fNumEntries</code> 用于保存容器中键-值对的个数。<code>fRebuildSize</code> 为哈希桶扩容的阈值，即当 <code>BasicHashTable</code> 中保存的键值对超过该值时，哈希桶需要扩容。<code>fDownShift</code> 和 <code>fMask</code> 用于计算哈希值，并把哈希值映射到哈希桶容量范围内。</p>
<h2 id="向-BasicHashTable-中插入元素"><a href="#向-BasicHashTable-中插入元素" class="headerlink" title="向 BasicHashTable 中插入元素"></a>向 BasicHashTable 中插入元素</h2><p>可以通过 <code>Add(char const* key, void* value)</code> 向 <code>BasicHashTable</code> 中插入元素，这个函数的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* BasicHashTable::Add(<span class="keyword">char</span> <span class="keyword">const</span>* key, <span class="keyword">void</span>* value) &#123;</div><div class="line">  <span class="keyword">void</span>* oldValue;</div><div class="line">  <span class="keyword">unsigned</span> index;</div><div class="line">  TableEntry* entry = lookupKey(key, index);</div><div class="line">  <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="comment">// There's already an item with this key</span></div><div class="line">    oldValue = entry-&gt;value;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// There's no existing entry; create a new one:</span></div><div class="line">    entry = insertNewEntry(index, key);</div><div class="line">    oldValue = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  entry-&gt;value = value;</div><div class="line"></div><div class="line">  <span class="comment">// If the table has become too large, rebuild it with more buckets:</span></div><div class="line">  <span class="keyword">if</span> (fNumEntries &gt;= fRebuildSize) rebuild();</div><div class="line"></div><div class="line">  <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>向 BasicHashTable 中插入元素的过车大致如下：</p>
<ol>
<li>查找 BasicHashTable 中与要插入的键-值对的键匹配的元素 <code>TableEntry</code>。</li>
<li>若找到，把该元素的旧的值保存在 <code>oldValue</code> 中。</li>
<li>若没有找到，则通过 <code>insertNewEntry(index, key)</code> 创建一个 <code>TableEntry</code> 并加入到哈希桶中，<code>oldValue</code> 被赋值为 NULL。</li>
<li>把要插入的键-值对的值保存进新创建或找到的 <code>TableEntry</code> 中。</li>
<li>如果 BasicHashTable 中的元素个数超出 <code>fRebuildSize</code> 的大小，则对哈希桶扩容。</li>
<li>返回元素的旧的值。</li>
</ol>
<p>查找 BasicHashTable 中与要插入的键-值对的键匹配的元素 <code>TableEntry</code> 的过程如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">BasicHashTable::TableEntry* BasicHashTable</div><div class="line">::lookupKey(<span class="keyword">char</span> <span class="keyword">const</span>* key, <span class="keyword">unsigned</span>&amp; index) <span class="keyword">const</span> &#123;</div><div class="line">  TableEntry* entry;</div><div class="line">  index = hashIndexFromKey(key);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (entry = fBuckets[index]; entry != <span class="literal">NULL</span>; entry = entry-&gt;fNext) &#123;</div><div class="line">    <span class="keyword">if</span> (keyMatches(key, entry-&gt;key)) <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> entry;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Boolean BasicHashTable</div><div class="line">::keyMatches(<span class="keyword">char</span> <span class="keyword">const</span>* key1, <span class="keyword">char</span> <span class="keyword">const</span>* key2) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="comment">// The way we check the keys for a match depends upon their type:</span></div><div class="line">  <span class="keyword">if</span> (fKeyType == STRING_HASH_KEYS) &#123;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(key1, key2) == <span class="number">0</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fKeyType == ONE_WORD_HASH_KEYS) &#123;</div><div class="line">    <span class="keyword">return</span> (key1 == key2);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">unsigned</span>* k1 = (<span class="keyword">unsigned</span>*)key1;</div><div class="line">    <span class="keyword">unsigned</span>* k2 = (<span class="keyword">unsigned</span>*)key2;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fKeyType; ++i) &#123;</div><div class="line">      <span class="keyword">if</span> (k1[i] != k2[i]) <span class="keyword">return</span> False; <span class="comment">// keys differ</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> True;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">. . . . . .</div><div class="line"><span class="keyword">unsigned</span> BasicHashTable::hashIndexFromKey(<span class="keyword">char</span> <span class="keyword">const</span>* key) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">unsigned</span> result = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (fKeyType == STRING_HASH_KEYS) &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">char</span> c = *key++;</div><div class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">      result += (result&lt;&lt;<span class="number">3</span>) + (<span class="keyword">unsigned</span>)c;</div><div class="line">    &#125;</div><div class="line">    result &amp;= fMask;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fKeyType == ONE_WORD_HASH_KEYS) &#123;</div><div class="line">    result = randomIndex((<span class="keyword">uintptr_t</span>)key);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">unsigned</span>* k = (<span class="keyword">unsigned</span>*)key;</div><div class="line">    <span class="keyword">uintptr_t</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fKeyType; ++i) &#123;</div><div class="line">      sum += k[i];</div><div class="line">    &#125;</div><div class="line">    result = randomIndex(sum);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>lookupKey()</code> 首先通过 <code>hashIndexFromKey(key)</code> 根据键值对的键计算哈希值，并把该值映射到哈希桶容量范围内，得到索引。然后根据得到的索引，查找与传入的键匹配的元素。</p>
<p>这里可以更加清晰地看到，不同类型的 <code>HashTable</code> 之间的区别主要在于对待键的方式不同。STRING_HASH_KEYS 型的 <code>HashTable</code>，其键为传入的字符串指针指向的字符串的内容，而<br> ONE_WORD_HASH_KEYS 型的 <code>HashTable</code>，其键则为传入的字符串指针本身。</p>
<p>计算最终的哈希值，并把该值映射到哈希桶容量范围内，得到索引的过程如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">randomIndex</span><span class="params">(<span class="keyword">uintptr_t</span> i)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span>)(((i*<span class="number">1103515245</span>) &gt;&gt; fDownShift) &amp; fMask);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>insertNewEntry(index, key)</code> 创建一个 <code>TableEntry</code> 并加入到哈希桶中的过程如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">BasicHashTable::TableEntry* BasicHashTable</div><div class="line">::insertNewEntry(unsigned index, <span class="built_in">char</span> <span class="keyword">const</span>* <span class="built_in">key</span>) &#123;</div><div class="line">  TableEntry* entry = <span class="keyword">new</span> TableEntry();</div><div class="line">  entry-&gt;fNext = fBuckets[index];</div><div class="line">  fBuckets[index] = entry;</div><div class="line"></div><div class="line">  ++fNumEntries;</div><div class="line">  assignKey(entry, <span class="built_in">key</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> entry;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicHashTable::assignKey(TableEntry* entry, <span class="built_in">char</span> <span class="keyword">const</span>* <span class="built_in">key</span>) &#123;</div><div class="line">  <span class="comment">// The way we assign the key depends upon its type:</span></div><div class="line">  <span class="keyword">if</span> (fKeyType == STRING_HASH_KEYS) &#123;</div><div class="line">    entry-&gt;<span class="built_in">key</span> = strDup(<span class="built_in">key</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fKeyType == ONE_WORD_HASH_KEYS) &#123;</div><div class="line">    entry-&gt;<span class="built_in">key</span> = <span class="built_in">key</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fKeyType &gt; <span class="number">0</span>) &#123;</div><div class="line">    unsigned* keyFrom = (unsigned*)<span class="built_in">key</span>;</div><div class="line">    unsigned* keyTo = <span class="keyword">new</span> unsigned[fKeyType];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; fKeyType; ++i) keyTo[i] = keyFrom[i];</div><div class="line"></div><div class="line">    entry-&gt;<span class="built_in">key</span> = (<span class="built_in">char</span> <span class="keyword">const</span>*)keyTo;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见插入的过程主要为，</p>
<ol>
<li>创建 TableEntry 对象，并把它插入到键所对应的 TableEntry 指针数组中的 TableEntry 元素链的头部。</li>
<li>增加容器中元素个数的计数。</li>
<li>为 TableEntry 分配传入的键。</li>
</ol>
<p>依据 <code>HashTable</code> 类型的不同，分配键的方式也不同。</p>
<ol>
<li>对于 STRING_HASH_KEYS 型的 <code>HashTable</code>，需要将传入的字符串指针指向的字符串的内容复制一份，赋值给 TableEntry 的 <code>key</code>。</li>
<li>对于 ONE_WORD_HASH_KEYS 型的 <code>HashTable</code>，需要将传入的字符串指针本身，赋值给 TableEntry 的 <code>key</code>。</li>
<li>对于 <code>fKeyType</code> 大于 0 的情况，需要将传入的字符串指针指向的字符串的内容的前 (sizeof(unsigned) <em> fKeyType) 个字节复制一份，赋值给 TableEntry 的 <code>key</code>。这种代码真是看得人胆颤心惊，万一传入的 key 字符串长度小于 (sizeof(unsigned) </em> fKeyType) 个字节呢？。。。</li>
</ol>
<p>对比 <code>keyMatches()</code> 和 <code>assignKey()</code> 函数的实现，不难发现，当 <code>HashTable</code> 类型 <code>fKeyType</code> 大于0，且不是 <code>ONE_WORD_HASH_KEYS</code> 时，要求作为哈希表中键值对的键的字符串的长度固定为 (sizeof(unsigned) * fKeyType) 个字节。</p>
<p>然后来看，BasicHashTable 中对哈希桶扩容的过程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BasicHashTable::rebuild() &#123;</div><div class="line">  <span class="comment">// Remember the existing table size:</span></div><div class="line">  <span class="keyword">unsigned</span> oldSize = fNumBuckets;</div><div class="line">  TableEntry** oldBuckets = fBuckets;</div><div class="line"></div><div class="line">  <span class="comment">// Create the new sized table:</span></div><div class="line">  fNumBuckets *= <span class="number">4</span>;</div><div class="line">  fBuckets = <span class="keyword">new</span> TableEntry*[fNumBuckets];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; fNumBuckets; ++i) &#123;</div><div class="line">    fBuckets[i] = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  fRebuildSize *= <span class="number">4</span>;</div><div class="line">  fDownShift -= <span class="number">2</span>;</div><div class="line">  fMask = (fMask&lt;&lt;<span class="number">2</span>)|<span class="number">0x3</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Rehash the existing entries into the new table:</span></div><div class="line">  <span class="keyword">for</span> (TableEntry** oldChainPtr = oldBuckets; oldSize &gt; <span class="number">0</span>;</div><div class="line">       --oldSize, ++oldChainPtr) &#123;</div><div class="line">    <span class="keyword">for</span> (TableEntry* hPtr = *oldChainPtr; hPtr != <span class="literal">NULL</span>;</div><div class="line">	 hPtr = *oldChainPtr) &#123;</div><div class="line">      *oldChainPtr = hPtr-&gt;fNext;</div><div class="line"></div><div class="line">      <span class="keyword">unsigned</span> index = hashIndexFromKey(hPtr-&gt;key);</div><div class="line"></div><div class="line">      hPtr-&gt;fNext = fBuckets[index];</div><div class="line">      fBuckets[index] = hPtr;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Free the old bucket array, if it was dynamically allocated:</span></div><div class="line">  <span class="keyword">if</span> (oldBuckets != fStaticBuckets) <span class="keyword">delete</span>[] oldBuckets;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里就是，</p>
<ol>
<li>为 <code>fBuckets</code> 分配一块新的内存，容量为原来的4倍。</li>
<li>适当更新 <code>fNumBuckets</code>，<code>fRebuildSize</code>，<code>fDownShift</code> 和 <code>fMask</code> 等。</li>
<li>将老的 <code>fBuckets</code> 中的元素，依据元素的 <code>key</code> 和新的哈希桶的容量，搬到新的 <code>fBuckets</code> 中。</li>
<li>根据需要释放老的 <code>fBuckets</code> 的内存。</li>
</ol>
<h2 id="在-BasicHashTable-中查找元素"><a href="#在-BasicHashTable-中查找元素" class="headerlink" title="在 BasicHashTable 中查找元素"></a>在 BasicHashTable 中查找元素</h2><p>然后来看在 BasicHashTable 中查找元素的过程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span>* BasicHashTable::Lookup(<span class="keyword">char</span> <span class="keyword">const</span>* key) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">unsigned</span> index;</div><div class="line">  TableEntry* entry = lookupKey(key, index);</div><div class="line">  <span class="keyword">if</span> (entry == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// no such entry</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> entry-&gt;value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个过程主要是根据 key，通过 <code>lookupKey()</code> 查找到对应的元素 TableEntry，然后返回其 value。</p>
<h2 id="移除-BasicHashTable-中的元素"><a href="#移除-BasicHashTable-中的元素" class="headerlink" title="移除 BasicHashTable 中的元素"></a>移除 BasicHashTable 中的元素</h2><p>来看移除 BasicHashTable 中的元素的过程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">Boolean BasicHashTable::Remove(<span class="keyword">char</span> <span class="keyword">const</span>* key) &#123;</div><div class="line">  <span class="keyword">unsigned</span> index;</div><div class="line">  TableEntry* entry = lookupKey(key, index);</div><div class="line">  <span class="keyword">if</span> (entry == <span class="literal">NULL</span>) <span class="keyword">return</span> False; <span class="comment">// no such entry</span></div><div class="line"></div><div class="line">  deleteEntry(index, entry);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> True;</div><div class="line">&#125;</div><div class="line">. . . . . .</div><div class="line"><span class="keyword">void</span> BasicHashTable::deleteEntry(<span class="keyword">unsigned</span> index, TableEntry* entry) &#123;</div><div class="line">  TableEntry** ep = &amp;fBuckets[index];</div><div class="line"></div><div class="line">  Boolean foundIt = False;</div><div class="line">  <span class="keyword">while</span> (*ep != <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (*ep == entry) &#123;</div><div class="line">      foundIt = True;</div><div class="line">      *ep = entry-&gt;fNext;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    ep = &amp;((*ep)-&gt;fNext);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!foundIt) &#123; <span class="comment">// shouldn't happen</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"BasicHashTable[%p]::deleteEntry(%d,%p): internal error - not found (first entry %p"</span>, <span class="keyword">this</span>, index, entry, fBuckets[index]);</div><div class="line">    <span class="keyword">if</span> (fBuckets[index] != <span class="literal">NULL</span>) <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">", next entry %p"</span>, fBuckets[index]-&gt;fNext);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">")\n"</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  --fNumEntries;</div><div class="line">  deleteKey(entry);</div><div class="line">  <span class="keyword">delete</span> entry;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicHashTable::deleteKey(TableEntry* entry) &#123;</div><div class="line">  <span class="comment">// The way we delete the key depends upon its type:</span></div><div class="line">  <span class="keyword">if</span> (fKeyType == ONE_WORD_HASH_KEYS) &#123;</div><div class="line">    entry-&gt;key = <span class="literal">NULL</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">delete</span>[] (<span class="keyword">char</span>*)entry-&gt;key;</div><div class="line">    entry-&gt;key = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>移除 BasicHashTable 中的元素的过程，也是免不了要先找到元素在 <code>BasicHashTable</code> 中的 TableEntry 的，找到之后，通过 <code>deleteEntry()</code> 移除元素。</p>
<p>在 <code>deleteEntry()</code> 中，先把元素从 <code>BasicHashTable</code> 中移除出去，然后通过 <code>deleteKey()</code> 释放 key 占用的内存，随后释放 TableEntry 本身占用的内存。这里把 TableEntry 从 <code>BasicHashTable</code> 中移除出去采用了下面这种方法：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">TableEntry** ep = &amp;fBuckets[index];</div><div class="line"></div><div class="line"><span class="keyword">Boolean</span> foundIt = <span class="keyword">False</span>;</div><div class="line"><span class="keyword">while</span> (*ep != <span class="keyword">NULL</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (*ep == entry) &#123;</div><div class="line">    foundIt = <span class="keyword">True</span>;</div><div class="line">    *ep = entry-&gt;fNext;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  ep = &amp;((*ep)-&gt;fNext);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过二级指针，遍历链表一趟，就将元素移除出去了。记得这是这中场景下 Linus 大神鼓励的一种写法。从链表中删除一个元素，用好几个临时变量，或者加许多判断的方法，都弱爆了。</p>
<h2 id="通过-Iterator-遍历-BasicHashTable"><a href="#通过-Iterator-遍历-BasicHashTable" class="headerlink" title="通过 Iterator 遍历 BasicHashTable"></a>通过 Iterator 遍历 BasicHashTable</h2><p>可以使用 <code>BasicHashTable</code> 中定义的 <code>Iterator</code> 来遍历它。过程如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">BasicHashTable::<span class="built_in">Iterator</span>::<span class="built_in">Iterator</span>(BasicHashTable <span class="keyword">const</span>&amp; table)</div><div class="line">  : fTable(table), fNextIndex(<span class="number">0</span>), fNextEntry(NULL) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void* BasicHashTable::<span class="built_in">Iterator</span>::next(<span class="keyword">char</span> <span class="keyword">const</span>*&amp; key) &#123;</div><div class="line">  <span class="keyword">while</span> (fNextEntry == NULL) &#123;</div><div class="line">    <span class="keyword">if</span> (fNextIndex &gt;= fTable.fNumBuckets) <span class="keyword">return</span> NULL;</div><div class="line"></div><div class="line">    fNextEntry = fTable.fBuckets[fNextIndex++];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  BasicHashTable::TableEntry* entry = fNextEntry;</div><div class="line">  fNextEntry = entry-&gt;fNext;</div><div class="line"></div><div class="line">  key = entry-&gt;key;</div><div class="line">  <span class="keyword">return</span> entry-&gt;value;</div><div class="line">&#125;</div><div class="line">. . . . . .</div><div class="line">HashTable::<span class="built_in">Iterator</span>* HashTable::<span class="built_in">Iterator</span>::create(HashTable <span class="keyword">const</span>&amp; hashTable) &#123;</div><div class="line">  <span class="comment">// "hashTable" is assumed to be a BasicHashTable</span></div><div class="line">  <span class="keyword">return</span> new BasicHashTable::<span class="built_in">Iterator</span>((BasicHashTable <span class="keyword">const</span>&amp;)hashTable);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>BasicHashTable</code> 的 <code>fBuckets</code> 中的每个元素都保存一个 <code>TableEntry</code> 的链表。在这里会逐个链表地遍历。</p>
<p> live555 定义的 <code>HashTable</code> 的内容就是这些了。</p>
<h1 id="UsageEnvironment"><a href="#UsageEnvironment" class="headerlink" title="UsageEnvironment"></a>UsageEnvironment</h1><p>live555 中，<code>UsageEnvironment</code> 类扮演一个简单的控制器的角色。UsageEnvironment 模块中，<code>UsageEnvironment</code> 类的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> TaskScheduler; <span class="comment">// forward</span></div><div class="line"></div><div class="line"><span class="comment">// An abstract base class, subclassed for each use of the library</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> UsageEnvironment &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function">Boolean <span class="title">reclaim</span><span class="params">()</span></span>;</div><div class="line">      <span class="comment">// returns True iff we were actually able to delete our object</span></div><div class="line"></div><div class="line">  <span class="comment">// task scheduler:</span></div><div class="line">  <span class="function">TaskScheduler&amp; <span class="title">taskScheduler</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> fScheduler;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// result message handling:</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">const</span>* MsgString;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> MsgString <span class="title">getResultMsg</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setResultMsg</span><span class="params">(MsgString msg)</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setResultMsg</span><span class="params">(MsgString msg1, MsgString msg2)</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setResultMsg</span><span class="params">(MsgString msg1, MsgString msg2, MsgString msg3)</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setResultErrMsg</span><span class="params">(MsgString msg, <span class="keyword">int</span> err = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</div><div class="line">	<span class="comment">// like setResultMsg(), except that an 'errno' message is appended.  (If "err == 0", the "getErrno()" code is used instead.)</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">appendToResultMsg</span><span class="params">(MsgString msg)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">reportBackgroundError</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">	<span class="comment">// used to report a (previously set) error message within</span></div><div class="line">	<span class="comment">// a background event</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">internalError</span><span class="params">()</span></span>; <span class="comment">// used to 'handle' a 'should not occur'-type error condition within the library.</span></div><div class="line"></div><div class="line">  <span class="comment">// 'errno'</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getErrno</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 'console' output:</span></div><div class="line">  <span class="keyword">virtual</span> UsageEnvironment&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">char</span> <span class="keyword">const</span>* str) = <span class="number">0</span>;</div><div class="line">  <span class="keyword">virtual</span> UsageEnvironment&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span> i) = <span class="number">0</span>;</div><div class="line">  <span class="keyword">virtual</span> UsageEnvironment&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> u) = <span class="number">0</span>;</div><div class="line">  <span class="keyword">virtual</span> UsageEnvironment&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">double</span> d) = <span class="number">0</span>;</div><div class="line">  <span class="keyword">virtual</span> UsageEnvironment&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">void</span>* p) = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// a pointer to additional, optional, client-specific state</span></div><div class="line">  <span class="keyword">void</span>* liveMediaPriv;</div><div class="line">  <span class="keyword">void</span>* groupsockPriv;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  UsageEnvironment(TaskScheduler&amp; scheduler); <span class="comment">// abstract base class</span></div><div class="line">  <span class="keyword">virtual</span> ~UsageEnvironment(); <span class="comment">// we are deleted only by reclaim()</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  TaskScheduler&amp; fScheduler;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>UsageEnvironment</code> 类持有 <code>TaskScheduler</code> 的引用，并提供文本的输出操作，用于输出信息，其它还提供了获取 errno 的操作，在发生内部错误时的处理程序 <code>internalError()</code>，以及销毁自身的操作。<code>UsageEnvironment</code> 类本身实现了如下这几个函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Boolean UsageEnvironment::reclaim() &#123;</div><div class="line">  <span class="comment">// We delete ourselves only if we have no remainining state:</span></div><div class="line">  <span class="keyword">if</span> (liveMediaPriv == <span class="literal">NULL</span> &amp;&amp; groupsockPriv == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> True;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> False;</div><div class="line">&#125;</div><div class="line"></div><div class="line">UsageEnvironment::UsageEnvironment(TaskScheduler&amp; scheduler)</div><div class="line">  : liveMediaPriv(<span class="literal">NULL</span>), groupsockPriv(<span class="literal">NULL</span>), fScheduler(scheduler) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">UsageEnvironment::~UsageEnvironment() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// By default, we handle 'should not occur'-type library errors by calling abort().  Subclasses can redefine this, if desired.</span></div><div class="line"><span class="comment">// (If your runtime library doesn't define the "abort()" function, then define your own (e.g., that does nothing).)</span></div><div class="line"><span class="keyword">void</span> UsageEnvironment::internalError() &#123;</div><div class="line">  <span class="built_in">abort</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些函数都比较简单，这里不再赘述。</p>
<p><code>UsageEnvironment</code> 是一个接口类，BasicUsageEnvironment 模块中，通过两个类 <code>BasicUsageEnvironment</code> 和 <code>BasicUsageEnvironment0</code>，提供了它的一个实现。<code>BasicUsageEnvironment0</code> 类提供了那组直接操作字符串的函数的实现，该类的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BasicUsageEnvironment0: <span class="keyword">public</span> UsageEnvironment &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// redefined virtual functions:</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> MsgString <span class="title">getResultMsg</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setResultMsg</span><span class="params">(MsgString msg)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setResultMsg</span><span class="params">(MsgString msg1,</span></span></div><div class="line">		    MsgString msg2);</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setResultMsg</span><span class="params">(MsgString msg1,</span></span></div><div class="line">		    MsgString msg2,</div><div class="line">		    MsgString msg3);</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setResultErrMsg</span><span class="params">(MsgString msg, <span class="keyword">int</span> err = <span class="number">0</span>)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">appendToResultMsg</span><span class="params">(MsgString msg)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">reportBackgroundError</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  BasicUsageEnvironment0(TaskScheduler&amp; taskScheduler);</div><div class="line">  <span class="keyword">virtual</span> ~BasicUsageEnvironment0();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">char</span> fResultMsgBuffer[RESULT_MSG_BUFFER_MAX];</div><div class="line">  <span class="keyword">unsigned</span> fCurBufferSize;</div><div class="line">  <span class="keyword">unsigned</span> fBufferMaxSize;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个类定义了一个缓冲区，大小为 <code>RESULT_MSG_BUFFER_MAX</code>。类的实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">BasicUsageEnvironment0::BasicUsageEnvironment0(TaskScheduler&amp; taskScheduler)</div><div class="line">  : UsageEnvironment(taskScheduler),</div><div class="line">    fBufferMaxSize(RESULT_MSG_BUFFER_MAX) &#123;</div><div class="line">  reset();</div><div class="line">&#125;</div><div class="line"></div><div class="line">BasicUsageEnvironment0::~BasicUsageEnvironment0() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicUsageEnvironment0::reset() &#123;</div><div class="line">  fCurBufferSize = <span class="number">0</span>;</div><div class="line">  fResultMsgBuffer[fCurBufferSize] = <span class="string">'\0'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Implementation of virtual functions:</span></div><div class="line"></div><div class="line"><span class="keyword">char</span> <span class="keyword">const</span>* BasicUsageEnvironment0::getResultMsg() <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> fResultMsgBuffer;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicUsageEnvironment0::setResultMsg(MsgString msg) &#123;</div><div class="line">  reset();</div><div class="line">  appendToResultMsg(msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicUsageEnvironment0::setResultMsg(MsgString msg1, MsgString msg2) &#123;</div><div class="line">  setResultMsg(msg1);</div><div class="line">  appendToResultMsg(msg2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicUsageEnvironment0::setResultMsg(MsgString msg1, MsgString msg2,</div><div class="line">				       MsgString msg3) &#123;</div><div class="line">  setResultMsg(msg1, msg2);</div><div class="line">  appendToResultMsg(msg3);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicUsageEnvironment0::setResultErrMsg(MsgString msg, <span class="keyword">int</span> err) &#123;</div><div class="line">  setResultMsg(msg);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (err == <span class="number">0</span>) err = getErrno();</div><div class="line">. . . . . .</div><div class="line">  appendToResultMsg(strerror(err));</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicUsageEnvironment0::appendToResultMsg(MsgString msg) &#123;</div><div class="line">  <span class="keyword">char</span>* curPtr = &amp;fResultMsgBuffer[fCurBufferSize];</div><div class="line">  <span class="keyword">unsigned</span> spaceAvailable = fBufferMaxSize - fCurBufferSize;</div><div class="line">  <span class="keyword">unsigned</span> msgLength = <span class="built_in">strlen</span>(msg);</div><div class="line"></div><div class="line">  <span class="comment">// Copy only enough of "msg" as will fit:</span></div><div class="line">  <span class="keyword">if</span> (msgLength &gt; spaceAvailable<span class="number">-1</span>) &#123;</div><div class="line">    msgLength = spaceAvailable<span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  memmove(curPtr, (<span class="keyword">char</span>*)msg, msgLength);</div><div class="line">  fCurBufferSize += msgLength;</div><div class="line">  fResultMsgBuffer[fCurBufferSize] = <span class="string">'\0'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicUsageEnvironment0::reportBackgroundError() &#123;</div><div class="line">  <span class="built_in">fputs</span>(getResultMsg(), <span class="built_in">stderr</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这组函数提供了把传入的字符串，加进缓冲区，以及把缓冲区中的内容输出到标准输出的功能。</p>
<p><code>BasicUsageEnvironment</code> 类则提供了那组用于输出基本数据类型的操作符。这个类的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BasicUsageEnvironment: <span class="keyword">public</span> BasicUsageEnvironment0 &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">static</span> BasicUsageEnvironment* <span class="title">createNew</span><span class="params">(TaskScheduler&amp; taskScheduler)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// redefined virtual functions:</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getErrno</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> UsageEnvironment&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">char</span> <span class="keyword">const</span>* str);</div><div class="line">  <span class="keyword">virtual</span> UsageEnvironment&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span> i);</div><div class="line">  <span class="keyword">virtual</span> UsageEnvironment&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> u);</div><div class="line">  <span class="keyword">virtual</span> UsageEnvironment&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">double</span> d);</div><div class="line">  <span class="keyword">virtual</span> UsageEnvironment&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">void</span>* p);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  BasicUsageEnvironment(TaskScheduler&amp; taskScheduler);</div><div class="line">      <span class="comment">// called only by "createNew()" (or subclass constructors)</span></div><div class="line">  <span class="keyword">virtual</span> ~BasicUsageEnvironment();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定义比较简单。然后来看它的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">BasicUsageEnvironment::BasicUsageEnvironment(TaskScheduler&amp; taskScheduler)</div><div class="line">: BasicUsageEnvironment0(taskScheduler) &#123;</div><div class="line">. . . . . .</div><div class="line">&#125;</div><div class="line"></div><div class="line">BasicUsageEnvironment::~BasicUsageEnvironment() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BasicUsageEnvironment*</div><div class="line">BasicUsageEnvironment::createNew(TaskScheduler&amp; taskScheduler) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BasicUsageEnvironment(taskScheduler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> BasicUsageEnvironment::getErrno() <span class="keyword">const</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__WIN32__) || defined(_WIN32) || defined(_WIN32_WCE)</span></div><div class="line">  <span class="keyword">return</span> WSAGetLastError();</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">  <span class="keyword">return</span> errno;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line">UsageEnvironment&amp; BasicUsageEnvironment::<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">char</span> <span class="keyword">const</span>* str) &#123;</div><div class="line">  <span class="keyword">if</span> (str == <span class="literal">NULL</span>) str = <span class="string">"(NULL)"</span>; <span class="comment">// sanity check</span></div><div class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s"</span>, str);</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">UsageEnvironment&amp; BasicUsageEnvironment::<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span> i) &#123;</div><div class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%d"</span>, i);</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">UsageEnvironment&amp; BasicUsageEnvironment::<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> u) &#123;</div><div class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%u"</span>, u);</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">UsageEnvironment&amp; BasicUsageEnvironment::<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">double</span> d) &#123;</div><div class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%f"</span>, d);</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">UsageEnvironment&amp; BasicUsageEnvironment::<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">void</span>* p) &#123;</div><div class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%p"</span>, p);</div><div class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>BasicUsageEnvironment</code> 类还提供了一个静态的创建对象的函数 <code>createNew()</code> 用来创建 <code>BasicUsageEnvironment</code> 的对象。对于那些输出操作符的实现，都比较直接。</p>
<p>感觉 live555 这组 I/O 函数的实现并不是太好，C++ 标准库对这些接口都有着良好的实现，但 live555 似乎并没有要引入 C++ 标准库的打算。</p>
<h1 id="TaskScheduler"><a href="#TaskScheduler" class="headerlink" title="TaskScheduler"></a>TaskScheduler</h1><p>TaskScheduler 是 live555 中的任务调度器，它实现了 live555 的事件循环。UsageEnvironment 模块中，<code>TaskScheduler</code> 类的定义如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="function">typedef <span class="keyword">void</span> <span class="title">TaskFunc</span>(<span class="params"><span class="keyword">void</span>* clientData</span>)</span>;</div><div class="line">typedef <span class="keyword">void</span>* TaskToken;</div><div class="line">typedef u_int32_t EventTriggerId;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">TaskScheduler</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~TaskScheduler();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> TaskToken <span class="title">scheduleDelayedTask</span>(<span class="params">int64_t microseconds, TaskFunc* proc,</span></span></div><div class="line">					<span class="keyword">void</span>* clientData) = <span class="number">0</span>;</div><div class="line">	<span class="comment">// Schedules a task to occur (after a delay) when we next</span></div><div class="line">	<span class="comment">// reach a scheduling point.</span></div><div class="line">	<span class="comment">// (Does not delay if "microseconds" &lt;= 0)</span></div><div class="line">	<span class="comment">// Returns a token that can be used in a subsequent call to</span></div><div class="line">	<span class="comment">// unscheduleDelayedTask() or rescheduleDelayedTask()</span></div><div class="line">        <span class="comment">// (but only if the task has not yet occurred).</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">unscheduleDelayedTask</span>(<span class="params">TaskToken&amp; prevTask</span>) </span>= <span class="number">0</span>;</div><div class="line">	<span class="comment">// (Has no effect if "prevTask" == NULL)</span></div><div class="line">        <span class="comment">// Sets "prevTask" to NULL afterwards.</span></div><div class="line">        <span class="comment">// <span class="doctag">Note:</span> This MUST NOT be called if the scheduled task has already occurred.</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">rescheduleDelayedTask</span>(<span class="params">TaskToken&amp; task,</span></span></div><div class="line">				     int64_t microseconds, TaskFunc* proc,</div><div class="line">				     <span class="keyword">void</span>* clientData);</div><div class="line">        <span class="comment">// Combines "unscheduleDelayedTask()" with "scheduleDelayedTask()"</span></div><div class="line">        <span class="comment">// (setting "task" to the new task token).</span></div><div class="line">        <span class="comment">// <span class="doctag">Note:</span> This MUST NOT be called if the scheduled task has already occurred.</span></div><div class="line"></div><div class="line">  <span class="comment">// For handling socket operations in the background (from the event loop):</span></div><div class="line">  <span class="function">typedef <span class="keyword">void</span> <span class="title">BackgroundHandlerProc</span>(<span class="params"><span class="keyword">void</span>* clientData, <span class="keyword">int</span> mask</span>)</span>;</div><div class="line">    <span class="comment">// Possible bits to set in "mask".  (These are deliberately defined</span></div><div class="line">    <span class="comment">// the same as those in Tcl, to make a Tcl-based subclass easy.)</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> SOCKET_READABLE    (1&lt;&lt;1)</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> SOCKET_WRITABLE    (1&lt;&lt;2)</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> SOCKET_EXCEPTION   (1&lt;&lt;3)</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setBackgroundHandling</span>(<span class="params"><span class="keyword">int</span> socketNum, <span class="keyword">int</span> conditionSet, BackgroundHandlerProc* handlerProc, <span class="keyword">void</span>* clientData</span>) </span>= <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">disableBackgroundHandling</span>(<span class="params"><span class="keyword">int</span> socketNum</span>) </span>&#123; setBackgroundHandling(socketNum, <span class="number">0</span>, NULL, NULL); &#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">moveSocketHandling</span>(<span class="params"><span class="keyword">int</span> oldSocketNum, <span class="keyword">int</span> newSocketNum</span>) </span>= <span class="number">0</span>;</div><div class="line">        <span class="comment">// Changes any socket handling for "oldSocketNum" so that occurs with "newSocketNum" instead.</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doEventLoop</span>(<span class="params"><span class="keyword">char</span> <span class="keyword">volatile</span>* watchVariable = NULL</span>) </span>= <span class="number">0</span>;</div><div class="line">      <span class="comment">// Causes further execution to take place within the event loop.</span></div><div class="line">      <span class="comment">// Delayed tasks, background I/O handling, and other events are handled, sequentially (as a single thread of control).</span></div><div class="line">      <span class="comment">// (If "watchVariable" is not NULL, then we return from this routine when *watchVariable != 0)</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> EventTriggerId <span class="title">createEventTrigger</span>(<span class="params">TaskFunc* eventHandlerProc</span>) </span>= <span class="number">0</span>;</div><div class="line">      <span class="comment">// Creates a 'trigger' for an event, which - if it occurs - will be handled (from the event loop) using "eventHandlerProc".</span></div><div class="line">      <span class="comment">// (Returns 0 iff no such trigger can be created (e.g., because of implementation limits on the number of triggers).)</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">deleteEventTrigger</span>(<span class="params">EventTriggerId eventTriggerId</span>) </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">triggerEvent</span>(<span class="params">EventTriggerId eventTriggerId, <span class="keyword">void</span>* clientData = NULL</span>) </span>= <span class="number">0</span>;</div><div class="line">      <span class="comment">// Causes the (previously-registered) handler function for the specified event to be handled (from the event loop).</span></div><div class="line">      <span class="comment">// The handler function is called with "clientData" as parameter.</span></div><div class="line">      <span class="comment">// <span class="doctag">Note:</span> This function (unlike other library functions) may be called from an external thread</span></div><div class="line">      <span class="comment">// - to signal an external event.  (However, "triggerEvent()" should not be called with the</span></div><div class="line">      <span class="comment">// same 'event trigger id' from different threads.)</span></div><div class="line"></div><div class="line">  <span class="comment">// The following two functions are deprecated, and are provided for backwards-compatibility only:</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">turnOnBackgroundReadHandling</span>(<span class="params"><span class="keyword">int</span> socketNum, BackgroundHandlerProc* handlerProc, <span class="keyword">void</span>* clientData</span>) </span>&#123;</div><div class="line">    setBackgroundHandling(socketNum, SOCKET_READABLE, handlerProc, clientData);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">turnOffBackgroundReadHandling</span>(<span class="params"><span class="keyword">int</span> socketNum</span>) </span>&#123; disableBackgroundHandling(socketNum); &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">internalError</span>(<span class="params"></span>)</span>; <span class="comment">// used to 'handle' a 'should not occur'-type error condition within the library.</span></div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  TaskScheduler(); <span class="comment">// abstract base class</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>TaskScheduler</code> 的接口可以分为如下的几组：</p>
<ol>
<li>调度定时器任务。这主要包括 <code>scheduleDelayedTask()</code>、<code>unscheduleDelayedTask()</code> 和 <code>rescheduleDelayedTask()</code> 这几个函数，它们分别用于调度一个延迟任务，取消一个延迟任务，以及重新调度一个延迟任务。</li>
<li>后台调度 Socket I/O 处理操作。这主要包括 <code>setBackgroundHandling()</code>、<code>disableBackgroundHandling()</code>、<code>moveSocketHandling()</code>、<code>turnOnBackgroundReadHandling()</code> 和 <code>turnOffBackgroundReadHandling()</code> 这样几个函数，它们用于设置、修改或取消 socket 上特定 I/O 事件的处理程序。</li>
<li>用户事件调度。这主要包括 <code>createEventTrigger()</code>、<code>deleteEventTrigger()</code> 和 <code>triggerEvent()</code> 这样几个函数，它们用于创建、删除及触发一个用户自定义事件。</li>
<li>执行事件循环。这个由 <code>doEventLoop()</code> 函数完成，这个函数通常也是应用程序的主循环。</li>
<li>内部错误处理程序。这个指 <code>internalError()</code> 函数，用于在 <code>TaskScheduler</code> 发生内部错误时，执行一些处理。</li>
</ol>
<p><code>TaskScheduler</code> 类本身提供了几个简单函数的实现：<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">TaskScheduler::TaskScheduler() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TaskScheduler::~TaskScheduler() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TaskScheduler::rescheduleDelayedTask(TaskToken&amp; task,</div><div class="line">					  int64_t microseconds, TaskFunc* <span class="keyword">proc</span>,<span class="title"></span></div><div class="line">					  void* clientData) &#123;</div><div class="line">  unscheduleDelayedTask(task);</div><div class="line">  task = scheduleDelayedTask(microseconds, <span class="keyword">proc</span>,<span class="title"> clientData);</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">//<span class="title"> By</span> default,<span class="title"> we</span> handle 'should<span class="title"> not</span> occur'-type<span class="title"> library</span> errors<span class="title"> by</span> calling<span class="title"> abort().</span> <span class="title"> Subclasses</span> can<span class="title"> redefine</span> this,<span class="title"> if</span> desired.<span class="title"></span></div><div class="line">void TaskScheduler::internalError() &#123;</div><div class="line">  abort();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它们都简单而易于理解，这里不再赘述。</p>
<p>BasicUsageEnvironment 模块中同样提供了，<code>TaskScheduler</code> 接口的实现。与 <code>UsageEnvironment</code> 接口的情况类似，<code>TaskScheduler</code> 类的接口同样由两个类来实现，分别是 <code>BasicTaskScheduler</code> 和 <code>BasicTaskScheduler0</code>，其中<br> <code>BasicTaskScheduler0</code> 类实现我们前面提到的第 1 组，第 3 组接口，以及 <code>doEventLoop()</code> 的框架，而 <code>BasicTaskScheduler</code> 则用于实现第 2 组接口，并实现 <code>doEventLoop()</code> 的事件循环的循环体。</p>
<p><code>BasicTaskScheduler0</code> 类定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> HandlerSet; <span class="comment">// forward</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM_EVENT_TRIGGERS 32</span></div><div class="line"></div><div class="line"><span class="comment">// An abstract base class, useful for subclassing</span></div><div class="line"><span class="comment">// (e.g., to redefine the implementation of socket event handling)</span></div><div class="line"><span class="keyword">class</span> BasicTaskScheduler0: <span class="keyword">public</span> TaskScheduler &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~BasicTaskScheduler0();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SingleStep</span><span class="params">(<span class="keyword">unsigned</span> maxDelayTime = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</div><div class="line">      <span class="comment">// "maxDelayTime" is in microseconds.  It allows a subclass to impose a limit</span></div><div class="line">      <span class="comment">// on how long "select()" can delay, in case it wants to also do polling.</span></div><div class="line">      <span class="comment">// 0 (the default value) means: There's no maximum; just look at the delay queue</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Redefined virtual functions:</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> TaskToken <span class="title">scheduleDelayedTask</span><span class="params">(<span class="keyword">int64_t</span> microseconds, TaskFunc* proc,</span></span></div><div class="line">				<span class="keyword">void</span>* clientData);</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">unscheduleDelayedTask</span><span class="params">(TaskToken&amp; prevTask)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doEventLoop</span><span class="params">(<span class="keyword">char</span> <span class="keyword">volatile</span>* watchVariable)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> EventTriggerId <span class="title">createEventTrigger</span><span class="params">(TaskFunc* eventHandlerProc)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">deleteEventTrigger</span><span class="params">(EventTriggerId eventTriggerId)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">triggerEvent</span><span class="params">(EventTriggerId eventTriggerId, <span class="keyword">void</span>* clientData = <span class="literal">NULL</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  BasicTaskScheduler0();</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="comment">// To implement delayed operations:</span></div><div class="line">  DelayQueue fDelayQueue;</div><div class="line"></div><div class="line">  <span class="comment">// To implement background reads:</span></div><div class="line">  HandlerSet* fHandlers;</div><div class="line">  <span class="keyword">int</span> fLastHandledSocketNum;</div><div class="line"></div><div class="line">  <span class="comment">// To implement event triggers:</span></div><div class="line">  EventTriggerId <span class="keyword">volatile</span> fTriggersAwaitingHandling; <span class="comment">// implemented as a 32-bit bitmap</span></div><div class="line">  EventTriggerId fLastUsedTriggerMask; <span class="comment">// implemented as a 32-bit bitmap</span></div><div class="line">  TaskFunc* fTriggeredEventHandlers[MAX_NUM_EVENT_TRIGGERS];</div><div class="line">  <span class="keyword">void</span>* fTriggeredEventClientDatas[MAX_NUM_EVENT_TRIGGERS];</div><div class="line">  <span class="keyword">unsigned</span> fLastUsedTriggerNum; <span class="comment">// in the range [0,MAX_NUM_EVENT_TRIGGERS)</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>BasicTaskScheduler0</code> 类的成员函数，基本上就是继承自 <code>TaskScheduler</code> 类中，它要实现功能的那部分接口，但它新添加了一个虚函数 <code>SingleStep()</code> ，用于让其子类覆写，实现事件循环中的单次迭代。</p>
<p><code>BasicTaskScheduler0</code> 类的成员变量则是清晰地分为三组：<code>fDelayQueue</code> 用于实现定时器操作；<code>fHandlers</code> 和 <code>fLastHandledSocketNum</code> 用于实现 Socket I/O 事件处理操作；<code>fTriggersAwaitingHandling</code>、<code>fLastUsedTriggerMask</code>、<code>fTriggeredEventHandlers</code>、<code>fTriggeredEventClientDatas</code> 和 <code>fLastUsedTriggerNum</code> 用于实现用户事件。</p>
<p><strong><em>对于 <code>fHandlers</code> 和 <code>fLastHandledSocketNum</code>，感觉实际上没有必要在<br> <code>BasicTaskScheduler0</code> 类中定义。纵观 <code>BasicTaskScheduler0</code> 类的整个实现，除初始化这两个成员变量之外，不存在其它的访问操作。从这两个变量的职责来说，也不在 <code>BasicTaskScheduler0</code> 类的职责范围内。感觉这两个变量实际上放在 <code>BasicTaskScheduler</code> 类中更合适一点。</em></strong></p>
<p><code>BasicTaskScheduler0</code> 类对象创建及销毁过程如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BasicTaskScheduler0::BasicTaskScheduler0()</div><div class="line">  : fLastHandledSocketNum(<span class="number">-1</span>), fTriggersAwaitingHandling(<span class="number">0</span>), fLastUsedTriggerMask(<span class="number">1</span>), fLastUsedTriggerNum(MAX_NUM_EVENT_TRIGGERS<span class="number">-1</span>) &#123;</div><div class="line">  fHandlers = <span class="keyword">new</span> HandlerSet;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; MAX_NUM_EVENT_TRIGGERS; ++i) &#123;</div><div class="line">    fTriggeredEventHandlers[i] = <span class="literal">NULL</span>;</div><div class="line">    fTriggeredEventClientDatas[i] = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">BasicTaskScheduler0::~BasicTaskScheduler0() &#123;</div><div class="line">  <span class="keyword">delete</span> fHandlers;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在类对象创建的过程中，创建和/或初始化成员对象，对象销毁时，则销毁成员对象。</p>
<h2 id="时间的表示"><a href="#时间的表示" class="headerlink" title="时间的表示"></a>时间的表示</h2><p>在 live555 的 BasicUsageEnvironment 模块中，用 <code>Timeval</code> 类来描述时间，并用 <code>DelayInterval</code> 来描述延迟时间。这两个类的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Timeval &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function">time_base_seconds <span class="title">seconds</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> fTv.tv_sec;</div><div class="line">  &#125;</div><div class="line">  <span class="function">time_base_seconds <span class="title">seconds</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> fTv.tv_sec;</div><div class="line">  &#125;</div><div class="line">  <span class="function">time_base_seconds <span class="title">useconds</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> fTv.tv_usec;</div><div class="line">  &#125;</div><div class="line">  <span class="function">time_base_seconds <span class="title">useconds</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> fTv.tv_usec;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> <span class="keyword">operator</span>&gt;=(Timeval <span class="keyword">const</span>&amp; arg2) <span class="keyword">const</span>;</div><div class="line">  <span class="keyword">int</span> <span class="keyword">operator</span>&lt;=(Timeval <span class="keyword">const</span>&amp; arg2) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> arg2 &gt;= *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> <span class="keyword">operator</span>&lt;(Timeval <span class="keyword">const</span>&amp; arg2) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> &gt;= arg2);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> <span class="keyword">operator</span>&gt;(Timeval <span class="keyword">const</span>&amp; arg2) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> arg2 &lt; *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> <span class="keyword">operator</span>==(Timeval <span class="keyword">const</span>&amp; arg2) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> &gt;= arg2 &amp;&amp; arg2 &gt;= *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> <span class="keyword">operator</span>!=(Timeval <span class="keyword">const</span>&amp; arg2) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == arg2);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">class</span> DelayInterval <span class="keyword">const</span>&amp; arg2);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>-=(<span class="keyword">class</span> DelayInterval <span class="keyword">const</span>&amp; arg2);</div><div class="line">  <span class="comment">// returns ZERO iff arg2 &gt;= arg1</span></div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  Timeval(time_base_seconds seconds, time_base_seconds useconds) &#123;</div><div class="line">    fTv.tv_sec = seconds; fTv.tv_usec = useconds;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="function">time_base_seconds&amp; <span class="title">secs</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (time_base_seconds&amp;)fTv.tv_sec;</div><div class="line">  &#125;</div><div class="line">  <span class="function">time_base_seconds&amp; <span class="title">usecs</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (time_base_seconds&amp;)fTv.tv_usec;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">struct</span> timeval fTv;</div><div class="line">&#125;;</div><div class="line">. . . . . .</div><div class="line"><span class="keyword">class</span> DelayInterval: <span class="keyword">public</span> Timeval &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  DelayInterval(time_base_seconds seconds, time_base_seconds useconds)</div><div class="line">    : Timeval(seconds, useconds) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>DelayInterval</code> 类基本上就是 <code>Timeval</code> 类的别名，而之所以重新定义这样一个类，大概主要是为了便于阅读维护吧。<code>Timeval</code> 类用标准库中保存时间的 <code>struct timeval</code> 结构保存时间值，但通过操作符重载，提供了一些方便操作时间值的操作符函数。以成员函数的方式定义的操作符函数的实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Timeval::<span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Timeval&amp; arg2) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> seconds() &gt; arg2.seconds()</div><div class="line">    || (seconds() == arg2.seconds()</div><div class="line">	&amp;&amp; useconds() &gt;= arg2.useconds());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Timeval::<span class="keyword">operator</span>+=(<span class="keyword">const</span> DelayInterval&amp; arg2) &#123;</div><div class="line">  secs() += arg2.seconds(); usecs() += arg2.useconds();</div><div class="line">  <span class="keyword">if</span> (useconds() &gt;= MILLION) &#123;</div><div class="line">    usecs() -= MILLION;</div><div class="line">    ++secs();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Timeval::<span class="keyword">operator</span>-=(<span class="keyword">const</span> DelayInterval&amp; arg2) &#123;</div><div class="line">  secs() -= arg2.seconds(); usecs() -= arg2.useconds();</div><div class="line">  <span class="keyword">if</span> ((<span class="keyword">int</span>)useconds() &lt; <span class="number">0</span>) &#123;</div><div class="line">    usecs() += MILLION;</div><div class="line">    --secs();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> ((<span class="keyword">int</span>)seconds() &lt; <span class="number">0</span>)</div><div class="line">    secs() = usecs() = <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些操作符函数的实现，都比较直观。</p>
<p>除了以成员操作符函数定义的这些操作符之外，还包括如下这些非成员函数的操作符：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> max</span></div><div class="line"><span class="function"><span class="keyword">inline</span> Timeval <span class="title">max</span><span class="params">(Timeval <span class="keyword">const</span>&amp; arg1, Timeval <span class="keyword">const</span>&amp; arg2)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> arg1 &gt;= arg2 ? arg1 : arg2;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> min</span></div><div class="line"><span class="function"><span class="keyword">inline</span> Timeval <span class="title">min</span><span class="params">(Timeval <span class="keyword">const</span>&amp; arg1, Timeval <span class="keyword">const</span>&amp; arg2)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> arg1 &lt;= arg2 ? arg1 : arg2;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">. . . . . .</div><div class="line">DelayInterval <span class="keyword">operator</span>-(<span class="keyword">const</span> Timeval&amp; arg1, <span class="keyword">const</span> Timeval&amp; arg2) &#123;</div><div class="line">  time_base_seconds secs = arg1.seconds() - arg2.seconds();</div><div class="line">  time_base_seconds usecs = arg1.useconds() - arg2.useconds();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ((<span class="keyword">int</span>)usecs &lt; <span class="number">0</span>) &#123;</div><div class="line">    usecs += MILLION;</div><div class="line">    --secs;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> ((<span class="keyword">int</span>)secs &lt; <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> DELAY_ZERO;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> DelayInterval(secs, usecs);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">///// DelayInterval /////</span></div><div class="line"></div><div class="line">DelayInterval <span class="keyword">operator</span>*(<span class="keyword">short</span> arg1, <span class="keyword">const</span> DelayInterval&amp; arg2) &#123;</div><div class="line">  time_base_seconds result_seconds = arg1*arg2.seconds();</div><div class="line">  time_base_seconds result_useconds = arg1*arg2.useconds();</div><div class="line"></div><div class="line">  time_base_seconds carry = result_useconds/MILLION;</div><div class="line">  result_useconds -= carry*MILLION;</div><div class="line">  result_seconds += carry;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> DelayInterval(result_seconds, result_useconds);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INT_MAX</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX	0x7FFFFFFF</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="function"><span class="keyword">const</span> DelayInterval <span class="title">DELAY_ZERO</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">const</span> DelayInterval <span class="title">DELAY_SECOND</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</div><div class="line"><span class="keyword">const</span> DelayInterval DELAY_MINUTE = <span class="number">60</span>*DELAY_SECOND;</div><div class="line"><span class="keyword">const</span> DelayInterval DELAY_HOUR = <span class="number">60</span>*DELAY_MINUTE;</div><div class="line"><span class="keyword">const</span> DelayInterval DELAY_DAY = <span class="number">24</span>*DELAY_HOUR;</div><div class="line"><span class="function"><span class="keyword">const</span> DelayInterval <span class="title">ETERNITY</span><span class="params">(INT_MAX, MILLION<span class="number">-1</span>)</span></span>;</div><div class="line"><span class="comment">// used internally to make the implementation work</span></div></pre></td></tr></table></figure></p>
<p>它们的实现也都比较直观。</p>
<h2 id="延迟任务的表示及组织"><a href="#延迟任务的表示及组织" class="headerlink" title="延迟任务的表示及组织"></a>延迟任务的表示及组织</h2><p>在 live555 的 BasicUsageEnvironment 模块中，用 <code>DelayQueueEntry</code> 类表示一个延迟任务。该类定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> DelayQueueEntry &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~DelayQueueEntry();</div><div class="line"></div><div class="line">  <span class="keyword">intptr_t</span> token() &#123;</div><div class="line">    <span class="keyword">return</span> fToken;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>: <span class="comment">// abstract base class</span></div><div class="line">  DelayQueueEntry(DelayInterval delay);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleTimeout</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> DelayQueue;</div><div class="line">  DelayQueueEntry* fNext;</div><div class="line">  DelayQueueEntry* fPrev;</div><div class="line">  DelayInterval fDeltaTimeRemaining;</div><div class="line"></div><div class="line">  <span class="keyword">intptr_t</span> fToken;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">intptr_t</span> tokenCounter;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>延迟任务通过 token 来标识，token 在对象创建时，借助于全局的 <code>tokenCounter</code> 产生。<code>fDeltaTimeRemaining</code> 用于表示延迟任务需要被执行的时间距当前时间的间隔。由 <code>fNext</code> 和 <code>fPrev</code> 不难猜到，在 BasicUsageEnvironment 模块中是以双向链表来组织延迟任务的。<code>handleTimeout()</code> 函数是延迟任务的主体，需要由具体的子类提供实现。</p>
<p> <code>DelayQueueEntry</code> 类的具体实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">intptr_t</span> DelayQueueEntry::tokenCounter = <span class="number">0</span>;</div><div class="line"></div><div class="line">DelayQueueEntry::DelayQueueEntry(DelayInterval delay)</div><div class="line">  : fDeltaTimeRemaining(delay) &#123;</div><div class="line">  fNext = fPrev = <span class="keyword">this</span>;</div><div class="line">  fToken = ++tokenCounter;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DelayQueueEntry::~DelayQueueEntry() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> DelayQueueEntry::handleTimeout() &#123;</div><div class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>BasicUsageEnvironment 模块中实际使用 <code>AlarmHandler</code> 来描述延迟任务的，其定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> AlarmHandler: <span class="keyword">public</span> DelayQueueEntry &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AlarmHandler(TaskFunc* proc, <span class="keyword">void</span>* clientData, DelayInterval timeToDelay)</div><div class="line">    : DelayQueueEntry(timeToDelay), fProc(proc), fClientData(clientData) &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>: <span class="comment">// redefined virtual functions</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleTimeout</span><span class="params">()</span> </span>&#123;</div><div class="line">    (*fProc)(fClientData);</div><div class="line">    DelayQueueEntry::handleTimeout();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  TaskFunc* fProc;</div><div class="line">  <span class="keyword">void</span>* fClientData;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>BasicUsageEnvironment 模块需要用 <code>DelayQueueEntry</code> 类表示和组织延迟任务，而在接口层，也就是 <code>TaskScheduler</code> 中则是通过 <code>TaskFunc</code> 和用户数据指针来表示延迟任务。<code>AlarmHandler</code> 协助完成接口的结构到实现的结构的转换。</p>
<p>BasicUsageEnvironment 模块使用 <code>DelayQueue</code> 把 <code>DelayQueueEntry</code> 组织为双向链表，该类定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> DelayQueue: <span class="keyword">public</span> DelayQueueEntry &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  DelayQueue();</div><div class="line">  <span class="keyword">virtual</span> ~DelayQueue();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(DelayQueueEntry* newEntry)</span></span>; <span class="comment">// returns a token for the entry</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">updateEntry</span><span class="params">(DelayQueueEntry* entry, DelayInterval newDelay)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">updateEntry</span><span class="params">(<span class="keyword">intptr_t</span> tokenToFind, DelayInterval newDelay)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">removeEntry</span><span class="params">(DelayQueueEntry* entry)</span></span>; <span class="comment">// but doesn't delete it</span></div><div class="line">  <span class="function">DelayQueueEntry* <span class="title">removeEntry</span><span class="params">(<span class="keyword">intptr_t</span> tokenToFind)</span></span>; <span class="comment">// but doesn't delete it</span></div><div class="line"></div><div class="line">  <span class="function">DelayInterval <span class="keyword">const</span>&amp; <span class="title">timeToNextAlarm</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleAlarm</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="function">DelayQueueEntry* <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> fNext; &#125;</div><div class="line">  <span class="function">DelayQueueEntry* <span class="title">findEntryByToken</span><span class="params">(<span class="keyword">intptr_t</span> token)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">synchronize</span><span class="params">()</span></span>; <span class="comment">// bring the 'time remaining' fields up-to-date</span></div><div class="line"></div><div class="line">  _EventTime fLastSyncTime;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>首先来看一下 <code>DelayQueue</code> 类对象构造和销毁的过程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">DelayQueue::DelayQueue()</div><div class="line">  : DelayQueueEntry(ETERNITY) &#123;</div><div class="line">  fLastSyncTime = TimeNow();</div><div class="line">&#125;</div><div class="line"></div><div class="line">DelayQueue::~DelayQueue() &#123;</div><div class="line">  <span class="keyword">while</span> (fNext != <span class="keyword">this</span>) &#123;</div><div class="line">    DelayQueueEntry* entryToRemove = fNext;</div><div class="line">    removeEntry(entryToRemove);</div><div class="line">    <span class="keyword">delete</span> entryToRemove;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后来看一下向链表中添加元素的过程：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">void DelayQueue::addEntry(DelayQueueEntry* newEntry) &#123;</div><div class="line">  synchronize();</div><div class="line"></div><div class="line">  DelayQueueEntry* cur = head();</div><div class="line">  <span class="function"><span class="title">while</span> (newEntry-&gt;</span><span class="function"><span class="title">fDeltaTimeRemaining</span> &gt;= cur-&gt;</span>fDeltaTimeRemaining) &#123;</div><div class="line">    <span class="function"><span class="title">newEntry</span>-&gt;</span><span class="function"><span class="title">fDeltaTimeRemaining</span> -= cur-&gt;</span>fDeltaTimeRemaining;</div><div class="line">    <span class="function"><span class="title">cur</span> = cur-&gt;</span>fNext;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="title">cur</span>-&gt;</span><span class="function"><span class="title">fDeltaTimeRemaining</span> -= newEntry-&gt;</span>fDeltaTimeRemaining;</div><div class="line"></div><div class="line">  <span class="comment">// Add "newEntry" to the queue, just before "cur":</span></div><div class="line">  <span class="function"><span class="title">newEntry</span>-&gt;</span>fNext = cur;</div><div class="line">  <span class="function"><span class="title">newEntry</span>-&gt;</span><span class="function"><span class="title">fPrev</span> = cur-&gt;</span>fPrev;</div><div class="line">  <span class="function"><span class="title">cur</span>-&gt;</span><span class="function"><span class="title">fPrev</span> = newEntry-&gt;</span><span class="function"><span class="title">fPrev</span>-&gt;</span>fNext = newEntry;</div><div class="line">&#125;</div><div class="line">. . . . . .</div><div class="line">void DelayQueue::synchronize() &#123;</div><div class="line">  <span class="comment">// First, figure out how much time has elapsed since the last sync:</span></div><div class="line">  _EventTime timeNow = TimeNow();</div><div class="line">  <span class="keyword">if</span> (timeNow &lt; fLastSyncTime) &#123;</div><div class="line">    <span class="comment">// The system clock has apparently gone back in time; reset our sync time and return:</span></div><div class="line">    fLastSyncTime  = timeNow;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  DelayInterval timeSinceLastSync = timeNow - fLastSyncTime;</div><div class="line">  fLastSyncTime = timeNow;</div><div class="line"></div><div class="line">  <span class="comment">// Then, adjust the delay queue for any entries whose time is up:</span></div><div class="line">  DelayQueueEntry* curEntry = head();</div><div class="line">  <span class="function"><span class="title">while</span> (timeSinceLastSync &gt;= curEntry-&gt;</span>fDeltaTimeRemaining) &#123;</div><div class="line">    <span class="function"><span class="title">timeSinceLastSync</span> -= curEntry-&gt;</span>fDeltaTimeRemaining;</div><div class="line">    <span class="function"><span class="title">curEntry</span>-&gt;</span>fDeltaTimeRemaining = DELAY_ZERO;</div><div class="line">    <span class="function"><span class="title">curEntry</span> = curEntry-&gt;</span>fNext;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="title">curEntry</span>-&gt;</span>fDeltaTimeRemaining -= timeSinceLastSync;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这两个函数，可以更加清楚的看到，在 <code>DelayQueue</code> 中是怎么组织延迟任务的。<code>DelayQueue</code> 因为其本身是一个 <code>DelayQueueEntry</code>，实际上它是一个环形双向链表。它的 <code>fNext</code> 指向这个链表的逻辑上的头部元素，但它本身是这个链表的尾部元素。双向链表中每个元素的 <code>fDeltaTimeRemaining</code> 保存的是这个任务应该被调度执行的时间点，与它前面的那个任务应该被调度执行的时间点之间的差值，当该值为 0 时，也就表示这个任务需要被执行了。这样也就是说， <code>DelayQueue</code> 是一个双向环形的有序链表，顺序按照所需的执行时间排列。</p>
<p><code>removeEntry()</code> 用于从双向链表中移除一个任务：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void DelayQueue::removeEntry(DelayQueueEntry* entry) &#123;</div><div class="line">  <span class="function"><span class="title">if</span> (entry == NULL || entry-&gt;</span>fNext == NULL) return;</div><div class="line"></div><div class="line">  <span class="function"><span class="title">entry</span>-&gt;</span><span class="function"><span class="title">fNext</span>-&gt;</span><span class="function"><span class="title">fDeltaTimeRemaining</span> += entry-&gt;</span>fDeltaTimeRemaining;</div><div class="line">  <span class="function"><span class="title">entry</span>-&gt;</span><span class="function"><span class="title">fPrev</span>-&gt;</span><span class="function"><span class="title">fNext</span> = entry-&gt;</span>fNext;</div><div class="line">  <span class="function"><span class="title">entry</span>-&gt;</span><span class="function"><span class="title">fNext</span>-&gt;</span><span class="function"><span class="title">fPrev</span> = entry-&gt;</span>fPrev;</div><div class="line">  <span class="function"><span class="title">entry</span>-&gt;</span><span class="function"><span class="title">fNext</span> = entry-&gt;</span>fPrev = NULL;</div><div class="line">  <span class="comment">// in case we should try to remove it again</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">DelayQueueEntry* DelayQueue::removeEntry(intptr_t tokenToFind) &#123;</div><div class="line">  DelayQueueEntry* entry = findEntryByToken(tokenToFind);</div><div class="line">  removeEntry(entry);</div><div class="line">  return entry;</div><div class="line">&#125;</div><div class="line">. . . . . .</div><div class="line">DelayQueueEntry* DelayQueue::findEntryByToken(intptr_t tokenToFind) &#123;</div><div class="line">  DelayQueueEntry* cur = head();</div><div class="line">  <span class="keyword">while</span> (cur != this) &#123;</div><div class="line">    <span class="function"><span class="title">if</span> (cur-&gt;</span>token() == tokenToFind) return cur;</div><div class="line">    <span class="function"><span class="title">cur</span> = cur-&gt;</span>fNext;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>removeEntry(DelayQueueEntry* entry)</code> 中，在 <code>entry-&gt;fNext == NULL</code> 成立时会直接返回，也是由于 <code>DelayQueue</code> 实际是一个双向环形链表的缘故。</p>
<p> <code>DelayQueue</code> 还提供了用于更新延迟任务执行时间的接口：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void DelayQueue::updateEntry(DelayQueueEntry* <span class="keyword">entry</span>, DelayInterval newDelay) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">entry</span> == NULL) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  removeEntry(<span class="keyword">entry</span>);</div><div class="line">  <span class="keyword">entry</span>-&gt;fDeltaTimeRemaining = newDelay;</div><div class="line">  addEntry(<span class="keyword">entry</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void DelayQueue::updateEntry(intptr_t tokenToFind, DelayInterval newDelay) &#123;</div><div class="line">  DelayQueueEntry* <span class="keyword">entry</span> = findEntryByToken(tokenToFind);</div><div class="line">  updateEntry(<span class="keyword">entry</span>, newDelay);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此外，<code>timeToNextAlarm()</code> 用于计算最近的一个任务执行的时间，而 <code>handleAlarm()</code> 则用于执行该任务。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">DelayInterval <span class="keyword">const</span>&amp; DelayQueue::timeToNextAlarm() &#123;</div><div class="line">  <span class="keyword">if</span> <span class="function"><span class="params">(head()-&gt;fDeltaTimeRemaining == DELAY_ZERO)</span> <span class="title">return</span> <span class="title">DELAY_ZERO</span>; // <span class="title">a</span> <span class="title">common</span> <span class="title">case</span></span></div><div class="line"></div><div class="line">  <span class="title">synchronize</span><span class="params">()</span>;</div><div class="line">  <span class="title">return</span> <span class="title">head</span><span class="params">()</span>-&gt;fDeltaTimeRemaining;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="literal">void</span> DelayQueue::handleAlarm() &#123;</div><div class="line">  <span class="keyword">if</span> <span class="function"><span class="params">(head()-&gt;fDeltaTimeRemaining != DELAY_ZERO)</span> <span class="title">synchronize</span><span class="params">()</span>;</span></div><div class="line"></div><div class="line">  <span class="title">if</span> <span class="params">(head()-&gt;fDeltaTimeRemaining == DELAY_ZERO)</span> &#123;</div><div class="line">    // <span class="title">This</span> <span class="title">event</span> <span class="title">is</span> <span class="title">due</span> <span class="title">to</span> <span class="title">be</span> <span class="title">handled</span>:</div><div class="line">    <span class="title">DelayQueueEntry</span>* <span class="title">toRemove</span> = <span class="title">head</span><span class="params">()</span>;</div><div class="line">    <span class="title">removeEntry</span><span class="params">(toRemove)</span>; // <span class="title">do</span> <span class="title">this</span> <span class="title">first</span>, <span class="title">in</span> <span class="title">case</span> <span class="title">handler</span> <span class="title">accesses</span> <span class="title">queue</span></div><div class="line"></div><div class="line">    <span class="title">toRemove</span>-&gt;handleTimeout();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="延迟任务调度"><a href="#延迟任务调度" class="headerlink" title="延迟任务调度"></a>延迟任务调度</h2><p>看过了 live555 的 BasicUsageEnvironment 模块中时间的表示，以及延迟任务的表示及组织之后，再来看延迟任务的调度。</p>
<p><code>BasicTaskScheduler0</code> 类通过 <code>scheduleDelayedTask()</code>  和 <code>unscheduleDelayedTask()</code> 函数实现定时器任务调度，它们分别用于调度一个延迟任务及取消一个延迟任务，它们的实现如下：<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">TaskToken BasicTaskScheduler0::scheduleDelayedTask(int64_t microseconds,</div><div class="line">						 TaskFunc* <span class="keyword">proc</span>,<span class="title"></span></div><div class="line">						 void* clientData) &#123;</div><div class="line">  <span class="keyword">if</span> (microseconds &lt; <span class="number">0</span>) microseconds = <span class="number">0</span>;</div><div class="line">  DelayInterval timeToDelay((long)(microseconds/<span class="number">1000000</span>), (long)(microseconds%<span class="number">1000000</span>));</div><div class="line">  AlarmHandler* alarmHandler = new AlarmHandler(<span class="keyword">proc</span>,<span class="title"> clientData,</span> timeToDelay);<span class="title"></span></div><div class="line">  fDelayQueue.addEntry(alarmHandler);</div><div class="line"><span class="title"></span></div><div class="line">  return (void*)(alarmHandler-&gt;token());</div><div class="line">&#125;<span class="title"></span></div><div class="line"></div><div class="line">void BasicTaskScheduler0::unscheduleDelayedTask(TaskToken&amp;<span class="title"> prevTask)</span> &#123;</div><div class="line">  DelayQueueEntry* alarmHandler = fDelayQueue.removeEntry((intptr_t)prevTask);</div><div class="line">  prevTask = NULL;</div><div class="line">  delete alarmHandler;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>延迟任务调度也就是把延迟任务放进 <code>DelayQueue</code> 中，而取消延迟任务则是，把任务从 <code>DelayQueue</code> 中移除。</p>
<p>后面再来看延迟任务被执行的过程。</p>
<h2 id="用户事件任务调度"><a href="#用户事件任务调度" class="headerlink" title="用户事件任务调度"></a>用户事件任务调度</h2><p>用户事件任务调度接口，让调用者可以创建任务，并触发该任务在事件循环中执行。这组接口主要包括这样几个：<code>createEventTrigger()</code>、<code>deleteEventTrigger()</code> 和 <code>triggerEvent()</code>，它们分别用于创建任务，删除任务，及触发任务执行。</p>
<p>这些接口的实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">EventTriggerId BasicTaskScheduler0::createEventTrigger(TaskFunc* eventHandlerProc) &#123;</div><div class="line">  <span class="keyword">unsigned</span> i = fLastUsedTriggerNum;</div><div class="line">  EventTriggerId mask = fLastUsedTriggerMask;</div><div class="line"></div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    i = (i+<span class="number">1</span>)%MAX_NUM_EVENT_TRIGGERS;</div><div class="line">    mask &gt;&gt;= <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (mask == <span class="number">0</span>) mask = <span class="number">0x80000000</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fTriggeredEventHandlers[i] == <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// This trigger number is free; use it:</span></div><div class="line">      fTriggeredEventHandlers[i] = eventHandlerProc;</div><div class="line">      fTriggeredEventClientDatas[i] = <span class="literal">NULL</span>; <span class="comment">// sanity</span></div><div class="line"></div><div class="line">      fLastUsedTriggerMask = mask;</div><div class="line">      fLastUsedTriggerNum = i;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> mask;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (i != fLastUsedTriggerNum);</div><div class="line"></div><div class="line">  <span class="comment">// All available event triggers are allocated; return 0 instead:</span></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicTaskScheduler0::deleteEventTrigger(EventTriggerId eventTriggerId) &#123;</div><div class="line">  fTriggersAwaitingHandling &amp;=~ eventTriggerId;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (eventTriggerId == fLastUsedTriggerMask) &#123; <span class="comment">// common-case optimization:</span></div><div class="line">    fTriggeredEventHandlers[fLastUsedTriggerNum] = <span class="literal">NULL</span>;</div><div class="line">    fTriggeredEventClientDatas[fLastUsedTriggerNum] = <span class="literal">NULL</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// "eventTriggerId" should have just one bit set.</span></div><div class="line">    <span class="comment">// However, we do the reasonable thing if the user happened to 'or' together two or more "EventTriggerId"s:</span></div><div class="line">    EventTriggerId mask = <span class="number">0x80000000</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; MAX_NUM_EVENT_TRIGGERS; ++i) &#123;</div><div class="line">      <span class="keyword">if</span> ((eventTriggerId&amp;mask) != <span class="number">0</span>) &#123;</div><div class="line">	fTriggeredEventHandlers[i] = <span class="literal">NULL</span>;</div><div class="line">	fTriggeredEventClientDatas[i] = <span class="literal">NULL</span>;</div><div class="line">      &#125;</div><div class="line">      mask &gt;&gt;= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicTaskScheduler0::triggerEvent(EventTriggerId eventTriggerId, <span class="keyword">void</span>* clientData) &#123;</div><div class="line">  <span class="comment">// First, record the "clientData".  (Note that we allow "eventTriggerId" to be a combination of bits for multiple events.)</span></div><div class="line">  EventTriggerId mask = <span class="number">0x80000000</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; MAX_NUM_EVENT_TRIGGERS; ++i) &#123;</div><div class="line">    <span class="keyword">if</span> ((eventTriggerId&amp;mask) != <span class="number">0</span>) &#123;</div><div class="line">      fTriggeredEventClientDatas[i] = clientData;</div><div class="line">    &#125;</div><div class="line">    mask &gt;&gt;= <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Then, note this event as being ready to be handled.</span></div><div class="line">  <span class="comment">// (Note that because this function (unlike others in the library) can be called from an external thread, we do this last, to</span></div><div class="line">  <span class="comment">//  reduce the risk of a race condition.)</span></div><div class="line">  fTriggersAwaitingHandling |= eventTriggerId;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>BasicTaskScheduler0</code> 的 <code>fTriggeredEventHandlers</code> 和 <code>fTriggeredEventClientDatas</code> 用于保存任务本身，它们分别保存任务主体函数，以及执行任务时传入的用户数据。它们都是数组，每个任务占用一个元素，相同索引处的元素属于同一个任务。数组的长度为 <code>MAX_NUM_EVENT_TRIGGERS</code>，即 32，也就是说最多可以创建的任务的个数为 32。</p>
<p><code>fTriggersAwaitingHandling</code> 用于记录当前触发了哪些任务。每个任务的触发状态都对应于其中的一个位，当对应的位置 1 时，表示任务被触发，需要执行；反之则不需要执行。比如 <code>fTriggeredEventHandlers</code> 和 <code>fTriggeredEventClientDatas</code> 中索引 0 处的任务的触发状态，对应于 <code>fTriggersAwaitingHandling</code> 的最高位，索引 1 处的任务的触发状态，对应于次高位，依次类推。</p>
<p>创建任务，即是在 <code>fTriggeredEventHandlers</code> 和 <code>fTriggeredEventClientDatas</code> 中为任务找到一个空闲的位置，把任务的主体函数的指针保存起来，返回任务的索引在 <code>fTriggersAwaitingHandling</code>  中的对应位的掩码，作为任务的标识。<code>fLastUsedTriggerNum</code> 用于防止遍历 <code>fTriggeredEventHandlers</code> 查找时的无限循环。</p>
<p>删除任务即是移除任务相关的所有数据，包括复位 <code>fTriggersAwaitingHandling</code> 中的触发状态，以及 <code>fTriggeredEventHandlers</code> 和 <code>fTriggeredEventClientDatas</code> 中任务的主体函数指针和用户数据。</p>
<p>触发事件任务则是置为任务在 <code>fTriggersAwaitingHandling</code> 中对应的位，并设置任务数据。任务的实际执行同样需要在事件循环中执行。</p>
<h2 id="事件循环执行框架"><a href="#事件循环执行框架" class="headerlink" title="事件循环执行框架"></a>事件循环执行框架</h2><p><code>BasicTaskScheduler0</code> 中执行事件循环由 <code>doEventLoop()</code> 函数完成，具体实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BasicTaskScheduler0::doEventLoop(<span class="keyword">char</span> <span class="keyword">volatile</span>* watchVariable) &#123;</div><div class="line">  <span class="comment">// Repeatedly loop, handling readble sockets and timed events:</span></div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (watchVariable != <span class="literal">NULL</span> &amp;&amp; *watchVariable != <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">    SingleStep();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要特别关注的是传入的参数 <code>watchVariable</code>：调用者可以通过这个参数，来在事件循环的外部控制，事件循环何时结束。</p>
<h2 id="Socket-I-O-事件描述及其组织"><a href="#Socket-I-O-事件描述及其组织" class="headerlink" title="Socket I/O 事件描述及其组织"></a>Socket I/O 事件描述及其组织</h2><p>BasicUsageEnvironment 模块中，用 <code>HandlerDescriptor</code> 描述要监听的 socket 上的事件及事件发生时的处理程序，该类定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> HandlerDescriptor &#123;</div><div class="line">  HandlerDescriptor(HandlerDescriptor* nextHandler);</div><div class="line">  <span class="keyword">virtual</span> ~HandlerDescriptor();</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">int</span> socketNum;</div><div class="line">  <span class="keyword">int</span> conditionSet;</div><div class="line">  TaskScheduler::BackgroundHandlerProc* handlerProc;</div><div class="line">  <span class="keyword">void</span>* clientData;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Descriptors are linked together in a doubly-linked list:</span></div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> HandlerSet;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> HandlerIterator;</div><div class="line">  HandlerDescriptor* fNextHandler;</div><div class="line">  HandlerDescriptor* fPrevHandler;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>socketNum</code> 为要监听的 socket，<code>conditionSet</code> 描述要监听的 socket 上的事件，<code>handlerProc</code> 为事件发生时的处理程序，<code>clientData</code> 为传递给事件处理程序的用户数据。而 <code>fNextHandler</code> 和 <code>fPrevHandler</code> 则用于将<br> <code>HandlerDescriptor</code> 组织起来。不难猜到，BasicUsageEnvironment 模块中 <code>HandlerDescriptor</code> 也是要被组织为双向链表的。</p>
<p> <code>HandlerDescriptor</code> 类的实现如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">HandlerDescriptor::HandlerDescriptor(HandlerDescriptor* nextHandler)</div><div class="line">  : conditionSet(<span class="number">0</span>), handlerProc(NULL) &#123;</div><div class="line">  <span class="comment">// Link this descriptor into a doubly-linked list:</span></div><div class="line">  <span class="keyword">if</span> (nextHandler == this) &#123; <span class="comment">// initialization</span></div><div class="line">    fNextHandler = fPrevHandler = this;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    fNextHandler = nextHandler;</div><div class="line">    <span class="function"><span class="title">fPrevHandler</span> = nextHandler-&gt;</span>fPrevHandler;</div><div class="line">    <span class="function"><span class="title">nextHandler</span>-&gt;</span>fPrevHandler = this;</div><div class="line">    <span class="function"><span class="title">fPrevHandler</span>-&gt;</span>fNextHandler = this;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HandlerDescriptor::~HandlerDescriptor() &#123;</div><div class="line">  <span class="comment">// Unlink this descriptor from a doubly-linked list:</span></div><div class="line">  <span class="function"><span class="title">fNextHandler</span>-&gt;</span>fPrevHandler = fPrevHandler;</div><div class="line">  <span class="function"><span class="title">fPrevHandler</span>-&gt;</span>fNextHandler = fNextHandler;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>BasicUsageEnvironment 模块中，使用 <code>HandlerSet</code> 来维护所有的  <code>HandlerDescriptor</code>，这个类的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> HandlerSet &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HandlerSet();</div><div class="line">  <span class="keyword">virtual</span> ~HandlerSet();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">assignHandler</span><span class="params">(<span class="keyword">int</span> socketNum, <span class="keyword">int</span> conditionSet, TaskScheduler::BackgroundHandlerProc* handlerProc, <span class="keyword">void</span>* clientData)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearHandler</span><span class="params">(<span class="keyword">int</span> socketNum)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">moveHandler</span><span class="params">(<span class="keyword">int</span> oldSocketNum, <span class="keyword">int</span> newSocketNum)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="function">HandlerDescriptor* <span class="title">lookupHandler</span><span class="params">(<span class="keyword">int</span> socketNum)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> HandlerIterator;</div><div class="line">  HandlerDescriptor fHandlers;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>HandlerSet</code>/<code>HandlerDescriptor</code> 的设计与 <code>DelayQueue</code>/<code>DelayQueueEntry</code> 的设计非常相似。<code>HandlerSet</code> 的实现如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">HandlerSet::HandlerSet()</div><div class="line">  : fHandlers(&amp;fHandlers) &#123;</div><div class="line">  fHandlers.socketNum = <span class="number">-1</span>; <span class="comment">// shouldn't ever get looked at, but in case...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">HandlerSet::~HandlerSet() &#123;</div><div class="line">  <span class="comment">// Delete each handler descriptor:</span></div><div class="line">  <span class="keyword">while</span> (fHandlers.fNextHandler != &amp;fHandlers) &#123;</div><div class="line">    delete fHandlers.fNextHandler; <span class="comment">// changes fHandlers-&gt;fNextHandler</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> HandlerSet</div><div class="line">::assignHandler(<span class="keyword">int</span> socketNum, <span class="keyword">int</span> conditionSet, TaskScheduler::BackgroundHandlerProc* handlerProc, <span class="keyword">void</span>* clientData) &#123;</div><div class="line">  <span class="comment">// First, see if there's already a handler for this socket:</span></div><div class="line">  HandlerDescriptor* <span class="keyword">handler</span> = lookupHandler(socketNum);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">handler</span> == NULL) &#123; <span class="comment">// No existing handler, so create a new descr:</span></div><div class="line">    <span class="keyword">handler</span> = <span class="keyword">new</span> HandlerDescriptor(fHandlers.fNextHandler);</div><div class="line">    <span class="keyword">handler</span>-&gt;socketNum = socketNum;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">handler</span>-&gt;conditionSet = conditionSet;</div><div class="line">  <span class="keyword">handler</span>-&gt;handlerProc = handlerProc;</div><div class="line">  <span class="keyword">handler</span>-&gt;clientData = clientData;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> HandlerSet::clearHandler(<span class="keyword">int</span> socketNum) &#123;</div><div class="line">  HandlerDescriptor* <span class="keyword">handler</span> = lookupHandler(socketNum);</div><div class="line">  delete <span class="keyword">handler</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> HandlerSet::moveHandler(<span class="keyword">int</span> oldSocketNum, <span class="keyword">int</span> newSocketNum) &#123;</div><div class="line">  HandlerDescriptor* <span class="keyword">handler</span> = lookupHandler(oldSocketNum);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">handler</span> != NULL) &#123;</div><div class="line">    <span class="keyword">handler</span>-&gt;socketNum = newSocketNum;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HandlerDescriptor* HandlerSet::lookupHandler(<span class="keyword">int</span> socketNum) &#123;</div><div class="line">  HandlerDescriptor* <span class="keyword">handler</span>;</div><div class="line">  <span class="function">HandlerIterator <span class="title">iter</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</div><div class="line">  <span class="keyword">while</span> ((<span class="keyword">handler</span> = iter.next()) != NULL) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">handler</span>-&gt;socketNum == socketNum) <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">handler</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>HandlerSet</code> 类似地，被设计为 <code>HandlerDescriptor</code> 的双向循环列表，只是其中的元素的顺序没有意义。</p>
<p>BasicUsageEnvironment 模块还提供了迭代器 <code>HandlerIterator</code>，用于遍历<code>HandlerSet</code> ，其定义及实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> HandlerIterator &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HandlerIterator(HandlerSet&amp; handlerSet);</div><div class="line">  <span class="keyword">virtual</span> ~HandlerIterator();</div><div class="line"></div><div class="line">  <span class="function">HandlerDescriptor* <span class="title">next</span><span class="params">()</span></span>; <span class="comment">// returns NULL if none</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  HandlerSet&amp; fOurSet;</div><div class="line">  HandlerDescriptor* fNextPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">///////////////////////////////////// Implementation</span></div><div class="line">HandlerIterator::HandlerIterator(HandlerSet&amp; handlerSet)</div><div class="line">  : fOurSet(handlerSet) &#123;</div><div class="line">  reset();</div><div class="line">&#125;</div><div class="line"></div><div class="line">HandlerIterator::~HandlerIterator() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> HandlerIterator::reset() &#123;</div><div class="line">  fNextPtr = fOurSet.fHandlers.fNextHandler;</div><div class="line">&#125;</div><div class="line"></div><div class="line">HandlerDescriptor* HandlerIterator::next() &#123;</div><div class="line">  HandlerDescriptor* result = fNextPtr;</div><div class="line">  <span class="keyword">if</span> (result == &amp;fOurSet.fHandlers) &#123; <span class="comment">// no more</span></div><div class="line">    result = <span class="literal">NULL</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    fNextPtr = fNextPtr-&gt;fNextHandler;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结一下，可以监听每个 socket 上的事件，并在事件发生时执行处理程序，监听的 socket 上的事件及事件处理程序由 <code>HandlerDescriptor</code> 描述；所有的 <code>HandlerDescriptor</code> 由 <code>HandlerSet</code> 组织为一个双向的循环链表，元素之间的实际顺序没有意义，新加入的元素被放在逻辑上的链表头部。</p>
<h2 id="Socket-I-O-事件处理任务调度"><a href="#Socket-I-O-事件处理任务调度" class="headerlink" title="Socket I/O 事件处理任务调度"></a>Socket I/O 事件处理任务调度</h2><p>Socket I/O 事件处理任务调度都在 <code>BasicTaskScheduler</code> 类中完成，这个类的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BasicTaskScheduler: <span class="keyword">public</span> BasicTaskScheduler0 &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">static</span> BasicTaskScheduler* <span class="title">createNew</span><span class="params">(<span class="keyword">unsigned</span> maxSchedulerGranularity = <span class="number">10000</span><span class="comment">/*microseconds*/</span>)</span></span>;</div><div class="line">  <span class="keyword">virtual</span> ~BasicTaskScheduler();</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  BasicTaskScheduler(<span class="keyword">unsigned</span> maxSchedulerGranularity);</div><div class="line">      <span class="comment">// called only by "createNew()"</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedulerTickTask</span><span class="params">(<span class="keyword">void</span>* clientData)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">schedulerTickTask</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="comment">// Redefined virtual functions:</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SingleStep</span><span class="params">(<span class="keyword">unsigned</span> maxDelayTime)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setBackgroundHandling</span><span class="params">(<span class="keyword">int</span> socketNum, <span class="keyword">int</span> conditionSet, BackgroundHandlerProc* handlerProc, <span class="keyword">void</span>* clientData)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">moveSocketHandling</span><span class="params">(<span class="keyword">int</span> oldSocketNum, <span class="keyword">int</span> newSocketNum)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="comment">// To implement background reads:</span></div><div class="line">  HandlerSet* fHandlers;</div><div class="line">  <span class="keyword">int</span> fLastHandledSocketNum;</div><div class="line"></div><div class="line">  <span class="keyword">unsigned</span> fMaxSchedulerGranularity;</div><div class="line"></div><div class="line">  <span class="comment">// To implement background operations:</span></div><div class="line">  <span class="keyword">int</span> fMaxNumSockets;</div><div class="line">  fd_set fReadSet;</div><div class="line">  fd_set fWriteSet;</div><div class="line">  fd_set fExceptionSet;</div><div class="line">. . . . . .</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>fHandlers</code> 用于组织 <code>HandlerDescriptor</code>，<code>fReadSet</code>、<code>fWriteSet</code>、<code>fExceptionSet</code> 和 <code>fMaxNumSockets</code> 主要是为了适配 <code>select()</code> 接口，分别用于描述要监听其可读事件、可写事件、异常事件的 socket 集合，以及要监听的 socket 中 socket number 最大的那个。</p>
<p>Socket I/O 事件处理任务调度，由 <code>setBackgroundHandling()</code> 和 <code>moveSocketHandling()</code> 这两个函数完成，它们的实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BasicTaskScheduler</div><div class="line">  ::setBackgroundHandling(<span class="keyword">int</span> socketNum, <span class="keyword">int</span> conditionSet, BackgroundHandlerProc* handlerProc, <span class="keyword">void</span>* clientData) &#123;</div><div class="line">  <span class="keyword">if</span> (socketNum &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__WIN32__) &amp;&amp; !defined(_WIN32) &amp;&amp; defined(FD_SETSIZE)</span></div><div class="line">  <span class="keyword">if</span> (socketNum &gt;= (<span class="keyword">int</span>)(FD_SETSIZE)) <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  FD_CLR((<span class="keyword">unsigned</span>)socketNum, &amp;fReadSet);</div><div class="line">  FD_CLR((<span class="keyword">unsigned</span>)socketNum, &amp;fWriteSet);</div><div class="line">  FD_CLR((<span class="keyword">unsigned</span>)socketNum, &amp;fExceptionSet);</div><div class="line">  <span class="keyword">if</span> (conditionSet == <span class="number">0</span>) &#123;</div><div class="line">    fHandlers-&gt;clearHandler(socketNum);</div><div class="line">    <span class="keyword">if</span> (socketNum+<span class="number">1</span> == fMaxNumSockets) &#123;</div><div class="line">      --fMaxNumSockets;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    fHandlers-&gt;assignHandler(socketNum, conditionSet, handlerProc, clientData);</div><div class="line">    <span class="keyword">if</span> (socketNum+<span class="number">1</span> &gt; fMaxNumSockets) &#123;</div><div class="line">      fMaxNumSockets = socketNum+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (conditionSet&amp;SOCKET_READABLE) FD_SET((<span class="keyword">unsigned</span>)socketNum, &amp;fReadSet);</div><div class="line">    <span class="keyword">if</span> (conditionSet&amp;SOCKET_WRITABLE) FD_SET((<span class="keyword">unsigned</span>)socketNum, &amp;fWriteSet);</div><div class="line">    <span class="keyword">if</span> (conditionSet&amp;SOCKET_EXCEPTION) FD_SET((<span class="keyword">unsigned</span>)socketNum, &amp;fExceptionSet);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> BasicTaskScheduler::moveSocketHandling(<span class="keyword">int</span> oldSocketNum, <span class="keyword">int</span> newSocketNum) &#123;</div><div class="line">  <span class="keyword">if</span> (oldSocketNum &lt; <span class="number">0</span> || newSocketNum &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// sanity check</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__WIN32__) &amp;&amp; !defined(_WIN32) &amp;&amp; defined(FD_SETSIZE)</span></div><div class="line">  <span class="keyword">if</span> (oldSocketNum &gt;= (<span class="keyword">int</span>)(FD_SETSIZE) || newSocketNum &gt;= (<span class="keyword">int</span>)(FD_SETSIZE)) <span class="keyword">return</span>; <span class="comment">// sanity check</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  <span class="keyword">if</span> (FD_ISSET(oldSocketNum, &amp;fReadSet)) &#123;FD_CLR((<span class="keyword">unsigned</span>)oldSocketNum, &amp;fReadSet); FD_SET((<span class="keyword">unsigned</span>)newSocketNum, &amp;fReadSet);&#125;</div><div class="line">  <span class="keyword">if</span> (FD_ISSET(oldSocketNum, &amp;fWriteSet)) &#123;FD_CLR((<span class="keyword">unsigned</span>)oldSocketNum, &amp;fWriteSet); FD_SET((<span class="keyword">unsigned</span>)newSocketNum, &amp;fWriteSet);&#125;</div><div class="line">  <span class="keyword">if</span> (FD_ISSET(oldSocketNum, &amp;fExceptionSet)) &#123;FD_CLR((<span class="keyword">unsigned</span>)oldSocketNum, &amp;fExceptionSet); FD_SET((<span class="keyword">unsigned</span>)newSocketNum, &amp;fExceptionSet);&#125;</div><div class="line">  fHandlers-&gt;moveHandler(oldSocketNum, newSocketNum);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (oldSocketNum+<span class="number">1</span> == fMaxNumSockets) &#123;</div><div class="line">    --fMaxNumSockets;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (newSocketNum+<span class="number">1</span> &gt; fMaxNumSockets) &#123;</div><div class="line">    fMaxNumSockets = newSocketNum+<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于 <code>setBackgroundHandling()</code>，当 <code>conditionSet</code> 为非 0 值时，会更新或者新建对特定 socket 的监听；为 0 时，则将清除对该 socket 的监听。 <code>moveSocketHandling()</code> 更新对于 socket 事件的监听。</p>
<p><code>BasicTaskScheduler</code> 的 <code>SingleStep()</code> 实现事件循环的单次迭代：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BasicTaskScheduler::SingleStep(<span class="keyword">unsigned</span> maxDelayTime) &#123;</div><div class="line">  fd_set readSet = fReadSet; <span class="comment">// make a copy for this select() call</span></div><div class="line">  fd_set writeSet = fWriteSet; <span class="comment">// ditto</span></div><div class="line">  fd_set exceptionSet = fExceptionSet; <span class="comment">// ditto</span></div><div class="line"></div><div class="line">  DelayInterval <span class="keyword">const</span>&amp; timeToDelay = fDelayQueue.timeToNextAlarm();</div><div class="line">  <span class="keyword">struct</span> timeval tv_timeToDelay;</div><div class="line">  tv_timeToDelay.tv_sec = timeToDelay.seconds();</div><div class="line">  tv_timeToDelay.tv_usec = timeToDelay.useconds();</div><div class="line">  <span class="comment">// Very large "tv_sec" values cause select() to fail.</span></div><div class="line">  <span class="comment">// Don't make it any larger than 1 million seconds (11.5 days)</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">long</span> MAX_TV_SEC = MILLION;</div><div class="line">  <span class="keyword">if</span> (tv_timeToDelay.tv_sec &gt; MAX_TV_SEC) &#123;</div><div class="line">    tv_timeToDelay.tv_sec = MAX_TV_SEC;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// Also check our "maxDelayTime" parameter (if it's &gt; 0):</span></div><div class="line">  <span class="keyword">if</span> (maxDelayTime &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">      (tv_timeToDelay.tv_sec &gt; (<span class="keyword">long</span>)maxDelayTime/MILLION ||</div><div class="line">       (tv_timeToDelay.tv_sec == (<span class="keyword">long</span>)maxDelayTime/MILLION &amp;&amp;</div><div class="line">	tv_timeToDelay.tv_usec &gt; (<span class="keyword">long</span>)maxDelayTime%MILLION))) &#123;</div><div class="line">    tv_timeToDelay.tv_sec = maxDelayTime/MILLION;</div><div class="line">    tv_timeToDelay.tv_usec = maxDelayTime%MILLION;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> selectResult = select(fMaxNumSockets, &amp;readSet, &amp;writeSet, &amp;exceptionSet, &amp;tv_timeToDelay);</div><div class="line">  <span class="keyword">if</span> (selectResult &lt; <span class="number">0</span>) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__WIN32__) || defined(_WIN32)</span></div><div class="line">    <span class="keyword">int</span> err = WSAGetLastError();</div><div class="line">    <span class="comment">// For some unknown reason, select() in Windoze sometimes fails with WSAEINVAL if</span></div><div class="line">    <span class="comment">// it was called with no entries set in "readSet".  If this happens, ignore it:</span></div><div class="line">    <span class="keyword">if</span> (err == WSAEINVAL &amp;&amp; readSet.fd_count == <span class="number">0</span>) &#123;</div><div class="line">      err = EINTR;</div><div class="line">      <span class="comment">// To stop this from happening again, create a dummy socket:</span></div><div class="line">      <span class="keyword">if</span> (fDummySocketNum &gt;= <span class="number">0</span>) closeSocket(fDummySocketNum);</div><div class="line">      fDummySocketNum = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</div><div class="line">      FD_SET((<span class="keyword">unsigned</span>)fDummySocketNum, &amp;fReadSet);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (err != EINTR) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">if</span> (errno != EINTR &amp;&amp; errno != EAGAIN) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	<span class="comment">// Unexpected error - treat this as fatal:</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_WIN32_WCE)</span></div><div class="line">	perror(<span class="string">"BasicTaskScheduler::SingleStep(): select() fails"</span>);</div><div class="line">	<span class="comment">// Because this failure is often "Bad file descriptor" - which is caused by an invalid socket number (i.e., a socket number</span></div><div class="line">	<span class="comment">// that had already been closed) being used in "select()" - we print out the sockets that were being used in "select()",</span></div><div class="line">	<span class="comment">// to assist in debugging:</span></div><div class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket numbers used in the select() call:"</span>);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</div><div class="line">	  <span class="keyword">if</span> (FD_ISSET(i, &amp;fReadSet) || FD_ISSET(i, &amp;fWriteSet) || FD_ISSET(i, &amp;fExceptionSet)) &#123;</div><div class="line">	    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" %d("</span>, i);</div><div class="line">	    <span class="keyword">if</span> (FD_ISSET(i, &amp;fReadSet)) <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"r"</span>);</div><div class="line">	    <span class="keyword">if</span> (FD_ISSET(i, &amp;fWriteSet)) <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"w"</span>);</div><div class="line">	    <span class="keyword">if</span> (FD_ISSET(i, &amp;fExceptionSet)) <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"e"</span>);</div><div class="line">	    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">")"</span>);</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	internalError();</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Call the handler function for one readable socket:</span></div><div class="line">  <span class="function">HandlerIterator <span class="title">iter</span><span class="params">(*fHandlers)</span></span>;</div><div class="line">  HandlerDescriptor* handler;</div><div class="line">  <span class="comment">// To ensure forward progress through the handlers, begin past the last</span></div><div class="line">  <span class="comment">// socket number that we handled:</span></div><div class="line">  <span class="keyword">if</span> (fLastHandledSocketNum &gt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">while</span> ((handler = iter.next()) != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (handler-&gt;socketNum == fLastHandledSocketNum) <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (handler == <span class="literal">NULL</span>) &#123;</div><div class="line">      fLastHandledSocketNum = <span class="number">-1</span>;</div><div class="line">      iter.reset(); <span class="comment">// start from the beginning instead</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> ((handler = iter.next()) != <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="keyword">int</span> sock = handler-&gt;socketNum; <span class="comment">// alias</span></div><div class="line">    <span class="keyword">int</span> resultConditionSet = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (FD_ISSET(sock, &amp;readSet) &amp;&amp; FD_ISSET(sock, &amp;fReadSet)<span class="comment">/*sanity check*/</span>) resultConditionSet |= SOCKET_READABLE;</div><div class="line">    <span class="keyword">if</span> (FD_ISSET(sock, &amp;writeSet) &amp;&amp; FD_ISSET(sock, &amp;fWriteSet)<span class="comment">/*sanity check*/</span>) resultConditionSet |= SOCKET_WRITABLE;</div><div class="line">    <span class="keyword">if</span> (FD_ISSET(sock, &amp;exceptionSet) &amp;&amp; FD_ISSET(sock, &amp;fExceptionSet)<span class="comment">/*sanity check*/</span>) resultConditionSet |= SOCKET_EXCEPTION;</div><div class="line">    <span class="keyword">if</span> ((resultConditionSet&amp;handler-&gt;conditionSet) != <span class="number">0</span> &amp;&amp; handler-&gt;handlerProc != <span class="literal">NULL</span>) &#123;</div><div class="line">      fLastHandledSocketNum = sock;</div><div class="line">          <span class="comment">// <span class="doctag">Note:</span> we set "fLastHandledSocketNum" before calling the handler,</span></div><div class="line">          <span class="comment">// in case the handler calls "doEventLoop()" reentrantly.</span></div><div class="line">      (*handler-&gt;handlerProc)(handler-&gt;clientData, resultConditionSet);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (handler == <span class="literal">NULL</span> &amp;&amp; fLastHandledSocketNum &gt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// We didn't call a handler, but we didn't get to check all of them,</span></div><div class="line">    <span class="comment">// so try again from the beginning:</span></div><div class="line">    iter.reset();</div><div class="line">    <span class="keyword">while</span> ((handler = iter.next()) != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="keyword">int</span> sock = handler-&gt;socketNum; <span class="comment">// alias</span></div><div class="line">      <span class="keyword">int</span> resultConditionSet = <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (FD_ISSET(sock, &amp;readSet) &amp;&amp; FD_ISSET(sock, &amp;fReadSet)<span class="comment">/*sanity check*/</span>) resultConditionSet |= SOCKET_READABLE;</div><div class="line">      <span class="keyword">if</span> (FD_ISSET(sock, &amp;writeSet) &amp;&amp; FD_ISSET(sock, &amp;fWriteSet)<span class="comment">/*sanity check*/</span>) resultConditionSet |= SOCKET_WRITABLE;</div><div class="line">      <span class="keyword">if</span> (FD_ISSET(sock, &amp;exceptionSet) &amp;&amp; FD_ISSET(sock, &amp;fExceptionSet)<span class="comment">/*sanity check*/</span>) resultConditionSet |= SOCKET_EXCEPTION;</div><div class="line">      <span class="keyword">if</span> ((resultConditionSet&amp;handler-&gt;conditionSet) != <span class="number">0</span> &amp;&amp; handler-&gt;handlerProc != <span class="literal">NULL</span>) &#123;</div><div class="line">	fLastHandledSocketNum = sock;</div><div class="line">	    <span class="comment">// <span class="doctag">Note:</span> we set "fLastHandledSocketNum" before calling the handler,</span></div><div class="line">            <span class="comment">// in case the handler calls "doEventLoop()" reentrantly.</span></div><div class="line">	(*handler-&gt;handlerProc)(handler-&gt;clientData, resultConditionSet);</div><div class="line">	<span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (handler == <span class="literal">NULL</span>) fLastHandledSocketNum = <span class="number">-1</span>;<span class="comment">//because we didn't call a handler</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Also handle any newly-triggered event (Note that we do this *after* calling a socket handler,</span></div><div class="line">  <span class="comment">// in case the triggered event handler modifies The set of readable sockets.)</span></div><div class="line">  <span class="keyword">if</span> (fTriggersAwaitingHandling != <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (fTriggersAwaitingHandling == fLastUsedTriggerMask) &#123;</div><div class="line">      <span class="comment">// Common-case optimization for a single event trigger:</span></div><div class="line">      fTriggersAwaitingHandling &amp;=~ fLastUsedTriggerMask;</div><div class="line">      <span class="keyword">if</span> (fTriggeredEventHandlers[fLastUsedTriggerNum] != <span class="literal">NULL</span>) &#123;</div><div class="line">	(*fTriggeredEventHandlers[fLastUsedTriggerNum])(fTriggeredEventClientDatas[fLastUsedTriggerNum]);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Look for an event trigger that needs handling (making sure that we make forward progress through all possible triggers):</span></div><div class="line">      <span class="keyword">unsigned</span> i = fLastUsedTriggerNum;</div><div class="line">      EventTriggerId mask = fLastUsedTriggerMask;</div><div class="line"></div><div class="line">      <span class="keyword">do</span> &#123;</div><div class="line">	i = (i+<span class="number">1</span>)%MAX_NUM_EVENT_TRIGGERS;</div><div class="line">	mask &gt;&gt;= <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span> (mask == <span class="number">0</span>) mask = <span class="number">0x80000000</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ((fTriggersAwaitingHandling&amp;mask) != <span class="number">0</span>) &#123;</div><div class="line">	  fTriggersAwaitingHandling &amp;=~ mask;</div><div class="line">	  <span class="keyword">if</span> (fTriggeredEventHandlers[i] != <span class="literal">NULL</span>) &#123;</div><div class="line">	    (*fTriggeredEventHandlers[i])(fTriggeredEventClientDatas[i]);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  fLastUsedTriggerMask = mask;</div><div class="line">	  fLastUsedTriggerNum = i;</div><div class="line">	  <span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">      &#125; <span class="keyword">while</span> (i != fLastUsedTriggerNum);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Also handle any delayed event that may have come due.</span></div><div class="line">  fDelayQueue.handleAlarm();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数有点长，但清晰地分为如下几个部分：</p>
<ol>
<li>根据定时器任务列表中，距当前时间最近的任务所需执行的时间点以及传入的最大延迟时间，计算 <code>select()</code> 所能够等待地最长时间。</li>
<li>执行 <code>select()</code> 等待 socket 上的时间。</li>
<li><code>select()</code> 超时或某个 socket 上的 I/O 事件到来，首先执行发生 I/O 事件的 socket 的 I/O 事件处理程序。这个函数一次最多执行一个 socket 上的 I/O 处理程序。</li>
<li>执行用户事件处理程序。也是一次最多执行一个。</li>
<li>执行定时器任务，同样是一次最多执行一个。</li>
</ol>
<p>live555 的基础设施基本上就是这些了。</p>
<h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><a href="https://www.wolfcstech.com/about/donate.html">打赏</a></h3><p>Done.</p>
<h1 id="live555-源码分析系列文章"><a href="#live555-源码分析系列文章" class="headerlink" title="live555 源码分析系列文章"></a>live555 源码分析系列文章</h1><p><a href="https://www.wolfcstech.com/2017/08/28/live555_src_analysis_introduction/">live555 源码分析：简介</a><br><a href="https://www.wolfcstech.com/2017/08/30/live555_src_analysis_infrasture/">live555 源码分析：基础设施</a><br><a href="https://www.wolfcstech.com/2017/08/31/live555_src_analysis_mediaserver/">live555 源码分析：MediaSever</a><br><a href="https://www.wolfcstech.com/2017/09/01/live555_src_analysis_rtsp_rtp_rtcp_wireshark/">Wireshark 抓包分析 RTSP/RTP/RTCP 基本工作过程</a><br><a href="https://www.wolfcstech.com/2017/09/03/live555_src_analysis_rtspserver/">live555 源码分析：RTSPServer</a><br><a href="https://www.wolfcstech.com/2017/09/04/live555_src_analysis_describe/">live555 源码分析： DESCRIBE 的处理</a><br><a href="https://www.wolfcstech.com/2017/09/05/live555_src_analysis_setup/">live555 源码分析： SETUP 的处理</a><br><a href="https://www.wolfcstech.com/2017/09/05/live555_src_analysis_play/">live555 源码分析： PLAY 的处理</a></p>
</div><div class="tags"><a href="/tags/源码分析/">源码分析</a><a href="/tags/音视频开发/">音视频开发</a><a href="/tags/live555/">live555</a></div><div class="post-nav"><a href="/2017/08/31/live555_src_analysis_mediaserver/" class="pre">live555 源码分析：MediaSever</a><a href="/2017/08/28/live555_src_analysis_introduction/" class="next">live555 源码分析：简介</a></div><div id="disqus_thread"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="widget"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="请输入关键字..."/></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android开发/">Android开发</a><span class="category-list-count">34</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C-开发/">C/C++开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java开发/">Java开发</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux内核/">Linux内核</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/live555/">live555</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/业界趣闻/">业界趣闻</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台开发/">后台开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络协议/">网络协议</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络调试/">网络调试</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随想杂谈/">随想杂谈</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音视频开发/">音视频开发</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/OpenGL/" style="font-size: 15px;">OpenGL</a> <a href="/tags/网络协议/" style="font-size: 15px;">网络协议</a> <a href="/tags/Android开发/" style="font-size: 15px;">Android开发</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/chromium/" style="font-size: 15px;">chromium</a> <a href="/tags/后台开发/" style="font-size: 15px;">后台开发</a> <a href="/tags/Java开发/" style="font-size: 15px;">Java开发</a> <a href="/tags/QUIC/" style="font-size: 15px;">QUIC</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/网络调试/" style="font-size: 15px;">网络调试</a> <a href="/tags/HTTP2/" style="font-size: 15px;">HTTP2</a> <a href="/tags/UDT/" style="font-size: 15px;">UDT</a> <a href="/tags/图形图像/" style="font-size: 15px;">图形图像</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/HTTPS/" style="font-size: 15px;">HTTPS</a> <a href="/tags/C-C-开发/" style="font-size: 15px;">C/C++开发</a> <a href="/tags/音视频开发/" style="font-size: 15px;">音视频开发</a> <a href="/tags/Linux内核/" style="font-size: 15px;">Linux内核</a> <a href="/tags/live555/" style="font-size: 15px;">live555</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/Go-语言/" style="font-size: 15px;">Go 语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-fei"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">二月 2013</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/live555_src_analysis_play/">live555 源码分析： PLAY 的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/live555_src_analysis_setup/">live555 源码分析： SETUP 的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/04/live555_src_analysis_describe/">live555 源码分析： DESCRIBE 的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/03/live555_src_analysis_rtspserver/">live555 源码分析：RTSPServer</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/live555_src_analysis_rtsp_rtp_rtcp_wireshark/">Wireshark 抓包分析 RTSP/RTP/RTCP 基本工作过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/31/live555_src_analysis_mediaserver/">live555 源码分析：MediaSever</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/30/live555_src_analysis_infrasture/">live555 源码分析：基础设施</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/28/live555_src_analysis_introduction/">live555 源码分析：简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/h264_send_with_ortp/">使用 ortp 发送原始 H.264 码流</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/23/h264_play/">原始 H.264 码流播放</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developers" target="_blank">Android Developers</a><ul></ul><a href="https://source.android.com/" title="Android Open Source Project" target="_blank">Android Open Source Project</a><ul></ul><a href="http://www.vants.org/" title="蚂蚁网" target="_blank">蚂蚁网</a></div><div class="widget"><div class="widget-title"><i class="fa fa-commt"> 最近评论</i></div><script type="text/javascript" src="//wolfcstech.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div></div><a id="totop" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.2.0" async></script><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |<a href="/atom.xml">订阅本站</a> |<span>联系博主：<a href="mailto:hanpfei@gmail.com" target="_blank" class="fa fa-email"> </a><a href="undefined" target="_blank" class="fa fa-weibo"></a><a href="https://github.com/hanpfei" target="_blank" class="fa fa-github"> </a></span></p><p><span> Copyright &copy;<a href="/." rel="nofollow">Han Pengfei</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span><span><a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> Theme </a>by<a rel="nofollow" target="_blank" href="https://github.com/chaooo"> Charles.</a></span></p></div></div></div><script>var disqus_shortname = 'wolfcstech';
var disqus_identifier = '2017/08/30/live555_src_analysis_infrasture/';
var disqus_title = 'live555 源码分析：基础设施';
var disqus_url = 'https://www.wolfcstech.com/2017/08/30/live555_src_analysis_infrasture/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//wolfcstech.disqus.com/count.js" async></script><script type="text/javascript" src="/js/search.json.js?v=1.2.0"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3c736b12c32c019fd9ff6c825b6b9b44";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></body></html>